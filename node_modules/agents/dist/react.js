import { t as MessageType } from "./ai-types-CrMqkwc_.js";
import { use, useCallback, useEffect, useMemo, useRef } from "react";
import { usePartySocket } from "partysocket/react";

//#region src/react.tsx
/**
* Convert a camelCase string to a kebab-case string
* @param str The string to convert
* @returns The kebab-case string
*/
function camelCaseToKebabCase(str) {
	if (str === str.toUpperCase() && str !== str.toLowerCase()) return str.toLowerCase().replace(/_/g, "-");
	let kebabified = str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
	kebabified = kebabified.startsWith("-") ? kebabified.slice(1) : kebabified;
	return kebabified.replace(/_/g, "-").replace(/-$/, "");
}
const queryCache = /* @__PURE__ */ new Map();
function arraysEqual(a, b) {
	if (a === b) return true;
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) if (!Object.is(a[i], b[i])) return false;
	return true;
}
function findCacheEntry(targetKey) {
	for (const [existingKey, entry] of queryCache.entries()) if (arraysEqual(existingKey, targetKey)) {
		if (Date.now() > entry.expiresAt) {
			queryCache.delete(existingKey);
			return;
		}
		entry.refCount++;
		return entry.promise;
	}
}
function setCacheEntry(key, value, cacheTtl) {
	for (const [existingKey] of queryCache.entries()) if (arraysEqual(existingKey, key)) {
		queryCache.delete(existingKey);
		break;
	}
	const expiresAt = cacheTtl ? Date.now() + cacheTtl : Date.now() + 300 * 1e3;
	queryCache.set(key, {
		promise: value,
		refCount: 1,
		expiresAt,
		cacheTtl
	});
}
function decrementCacheEntry(targetKey) {
	for (const [existingKey, entry] of queryCache.entries()) if (arraysEqual(existingKey, targetKey)) {
		entry.refCount--;
		if (entry.refCount <= 0) queryCache.delete(existingKey);
		return true;
	}
	return false;
}
function createCacheKey(agentNamespace, name, deps) {
	return [
		agentNamespace,
		name || "default",
		...deps
	];
}
function useAgent(options) {
	const agentNamespace = camelCaseToKebabCase(options.agent);
	const { query, queryDeps, cacheTtl, ...restOptions } = options;
	const pendingCallsRef = useRef(/* @__PURE__ */ new Map());
	const cacheKey = useMemo(() => {
		const deps = queryDeps || [];
		return createCacheKey(agentNamespace, options.name, deps);
	}, [
		agentNamespace,
		options.name,
		queryDeps
	]);
	const queryPromise = useMemo(() => {
		if (!query || typeof query !== "function") return null;
		const existingPromise = findCacheEntry(cacheKey);
		if (existingPromise) return existingPromise;
		const promise = query().catch((error) => {
			console.error(`[useAgent] Query failed for agent "${options.agent}":`, error);
			decrementCacheEntry(cacheKey);
			throw error;
		});
		setCacheEntry(cacheKey, promise, cacheTtl);
		return promise;
	}, [
		cacheKey,
		query,
		options.agent,
		cacheTtl
	]);
	let resolvedQuery;
	if (query) if (typeof query === "function") {
		const queryResult = use(queryPromise);
		if (queryResult) {
			for (const [key, value] of Object.entries(queryResult)) if (value !== null && value !== void 0 && typeof value !== "string" && typeof value !== "number" && typeof value !== "boolean") console.warn(`[useAgent] Query parameter "${key}" is an object and will be converted to "[object Object]". Query parameters should be string, number, boolean, or null.`);
			resolvedQuery = queryResult;
		}
	} else resolvedQuery = query;
	useEffect(() => {
		return () => {
			if (queryPromise) decrementCacheEntry(cacheKey);
		};
	}, [cacheKey, queryPromise]);
	const agent = usePartySocket({
		party: agentNamespace,
		prefix: "agents",
		room: options.name || "default",
		query: resolvedQuery,
		...restOptions,
		onMessage: (message) => {
			if (typeof message.data === "string") {
				let parsedMessage;
				try {
					parsedMessage = JSON.parse(message.data);
				} catch (_error) {
					return options.onMessage?.(message);
				}
				if (parsedMessage.type === MessageType.CF_AGENT_STATE) {
					options.onStateUpdate?.(parsedMessage.state, "server");
					return;
				}
				if (parsedMessage.type === MessageType.CF_AGENT_MCP_SERVERS) {
					options.onMcpUpdate?.(parsedMessage.mcp);
					return;
				}
				if (parsedMessage.type === MessageType.RPC) {
					const response = parsedMessage;
					const pending = pendingCallsRef.current.get(response.id);
					if (!pending) return;
					if (!response.success) {
						pending.reject(new Error(response.error));
						pendingCallsRef.current.delete(response.id);
						pending.stream?.onError?.(response.error);
						return;
					}
					if ("done" in response) if (response.done) {
						pending.resolve(response.result);
						pendingCallsRef.current.delete(response.id);
						pending.stream?.onDone?.(response.result);
					} else pending.stream?.onChunk?.(response.result);
					else {
						pending.resolve(response.result);
						pendingCallsRef.current.delete(response.id);
					}
					return;
				}
			}
			options.onMessage?.(message);
		}
	});
	const call = useCallback((method, args = [], streamOptions) => {
		return new Promise((resolve, reject) => {
			const id = Math.random().toString(36).slice(2);
			pendingCallsRef.current.set(id, {
				reject,
				resolve,
				stream: streamOptions
			});
			const request = {
				args,
				id,
				method,
				type: MessageType.RPC
			};
			agent.send(JSON.stringify(request));
		});
	}, [agent]);
	agent.setState = (state) => {
		agent.send(JSON.stringify({
			state,
			type: MessageType.CF_AGENT_STATE
		}));
		options.onStateUpdate?.(state, "client");
	};
	agent.call = call;
	agent.agent = agentNamespace;
	agent.name = options.name || "default";
	agent.stub = new Proxy({}, { get: (_target, method) => {
		return (...args) => {
			return call(method, args);
		};
	} });
	if (agent.agent !== agent.agent.toLowerCase()) console.warn(`Agent name: ${agent.agent} should probably be in lowercase. Received: ${agent.agent}`);
	return agent;
}

//#endregion
export { useAgent };
//# sourceMappingURL=react.js.map