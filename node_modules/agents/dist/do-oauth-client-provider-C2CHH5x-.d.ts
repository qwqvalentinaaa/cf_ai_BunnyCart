import { OAuthClientProvider } from "@modelcontextprotocol/sdk/client/auth.js";
import {
  OAuthClientInformation,
  OAuthClientInformationFull,
  OAuthClientMetadata,
  OAuthTokens
} from "@modelcontextprotocol/sdk/shared/auth.js";

//#region src/mcp/do-oauth-client-provider.d.ts
interface AgentsOAuthProvider extends OAuthClientProvider {
  authUrl: string | undefined;
  clientId: string | undefined;
  serverId: string | undefined;
}
declare class DurableObjectOAuthClientProvider implements AgentsOAuthProvider {
  storage: DurableObjectStorage;
  clientName: string;
  baseRedirectUrl: string;
  private _authUrl_;
  private _serverId_;
  private _clientId_;
  constructor(
    storage: DurableObjectStorage,
    clientName: string,
    baseRedirectUrl: string
  );
  get clientMetadata(): OAuthClientMetadata;
  get clientUri(): string;
  get redirectUrl(): string;
  get clientId(): string;
  set clientId(clientId_: string);
  get serverId(): string;
  set serverId(serverId_: string);
  keyPrefix(clientId: string): string;
  clientInfoKey(clientId: string): string;
  clientInformation(): Promise<OAuthClientInformation | undefined>;
  saveClientInformation(
    clientInformation: OAuthClientInformationFull
  ): Promise<void>;
  tokenKey(clientId: string): string;
  tokens(): Promise<OAuthTokens | undefined>;
  saveTokens(tokens: OAuthTokens): Promise<void>;
  get authUrl(): string | undefined;
  /**
   * Because this operates on the server side (but we need browser auth), we send this url back to the user
   * and require user interact to initiate the redirect flow
   */
  redirectToAuthorization(authUrl: URL): Promise<void>;
  codeVerifierKey(clientId: string): string;
  saveCodeVerifier(verifier: string): Promise<void>;
  codeVerifier(): Promise<string>;
}
//#endregion
export { DurableObjectOAuthClientProvider as n, AgentsOAuthProvider as t };
//# sourceMappingURL=do-oauth-client-provider-C2CHH5x-.d.ts.map
