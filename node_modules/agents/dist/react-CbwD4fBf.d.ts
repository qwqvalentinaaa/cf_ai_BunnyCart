import { m as MCPServersState, t as Agent } from "./index-Bx5KK3VJ.js";
import { n as RPCMethod, t as Method } from "./serializable-faDkMCai.js";
import { i as StreamOptions } from "./client-BAQA84dr.js";
import { PartySocket } from "partysocket";
import { usePartySocket } from "partysocket/react";

//#region src/react.d.ts
type QueryObject = Record<string, string | null>;
/**
 * Options for the useAgent hook
 * @template State Type of the Agent's state
 */
type UseAgentOptions<State = unknown> = Omit<
  Parameters<typeof usePartySocket>[0],
  "party" | "room" | "query"
> & {
  /** Name of the agent to connect to */
  agent: string;
  /** Name of the specific Agent instance */
  name?: string;
  /** Query parameters - can be static object or async function */
  query?: QueryObject | (() => Promise<QueryObject>);
  /** Dependencies for async query caching */
  queryDeps?: unknown[];
  /** Cache TTL in milliseconds for auth tokens/time-sensitive data */
  cacheTtl?: number;
  /** Called when the Agent's state is updated */
  onStateUpdate?: (state: State, source: "server" | "client") => void;
  /** Called when MCP server state is updated */
  onMcpUpdate?: (mcpServers: MCPServersState) => void;
};
type AllOptional<T> = T extends [infer A, ...infer R]
  ? undefined extends A
    ? AllOptional<R>
    : false
  : true;
type RPCMethods<T> = {
  [K in keyof T as T[K] extends RPCMethod<T[K]> ? K : never]: RPCMethod<T[K]>;
};
type OptionalParametersMethod<T extends RPCMethod> =
  AllOptional<Parameters<T>> extends true ? T : never;
type AgentMethods<T> = Omit<RPCMethods<T>, keyof Agent<any, any>>;
type OptionalAgentMethods<T> = {
  [K in keyof AgentMethods<T> as AgentMethods<T>[K] extends OptionalParametersMethod<
    AgentMethods<T>[K]
  >
    ? K
    : never]: OptionalParametersMethod<AgentMethods<T>[K]>;
};
type RequiredAgentMethods<T> = Omit<
  AgentMethods<T>,
  keyof OptionalAgentMethods<T>
>;
type AgentPromiseReturnType<T, K$1 extends keyof AgentMethods<T>> =
  ReturnType<AgentMethods<T>[K$1]> extends Promise<any>
    ? ReturnType<AgentMethods<T>[K$1]>
    : Promise<ReturnType<AgentMethods<T>[K$1]>>;
type OptionalArgsAgentMethodCall<AgentT> = <
  K$1 extends keyof OptionalAgentMethods<AgentT>
>(
  method: K$1,
  args?: Parameters<OptionalAgentMethods<AgentT>[K$1]>,
  streamOptions?: StreamOptions
) => AgentPromiseReturnType<AgentT, K$1>;
type RequiredArgsAgentMethodCall<AgentT> = <
  K$1 extends keyof RequiredAgentMethods<AgentT>
>(
  method: K$1,
  args: Parameters<RequiredAgentMethods<AgentT>[K$1]>,
  streamOptions?: StreamOptions
) => AgentPromiseReturnType<AgentT, K$1>;
type AgentMethodCall<AgentT> = OptionalArgsAgentMethodCall<AgentT> &
  RequiredArgsAgentMethodCall<AgentT>;
type UntypedAgentMethodCall = <T = unknown>(
  method: string,
  args?: unknown[],
  streamOptions?: StreamOptions
) => Promise<T>;
type AgentStub<T> = {
  [K in keyof AgentMethods<T>]: (
    ...args: Parameters<AgentMethods<T>[K]>
  ) => AgentPromiseReturnType<AgentMethods<T>, K>;
};
type UntypedAgentStub = Record<string, Method>;
/**
 * React hook for connecting to an Agent
 */
declare function useAgent<State = unknown>(
  options: UseAgentOptions<State>
): PartySocket & {
  agent: string;
  name: string;
  setState: (state: State) => void;
  call: UntypedAgentMethodCall;
  stub: UntypedAgentStub;
};
declare function useAgent<
  AgentT extends {
    get state(): State;
  },
  State
>(
  options: UseAgentOptions<State>
): PartySocket & {
  agent: string;
  name: string;
  setState: (state: State) => void;
  call: AgentMethodCall<AgentT>;
  stub: AgentStub<AgentT>;
};
//#endregion
export { useAgent as n, UseAgentOptions as t };
//# sourceMappingURL=react-CbwD4fBf.d.ts.map
