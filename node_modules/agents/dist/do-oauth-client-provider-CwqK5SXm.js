import { nanoid } from "nanoid";

//#region src/mcp/do-oauth-client-provider.ts
var DurableObjectOAuthClientProvider = class {
	constructor(storage, clientName, baseRedirectUrl) {
		this.storage = storage;
		this.clientName = clientName;
		this.baseRedirectUrl = baseRedirectUrl;
		if (!storage) throw new Error("DurableObjectOAuthClientProvider requires a valid DurableObjectStorage instance");
	}
	get clientMetadata() {
		return {
			client_name: this.clientName,
			client_uri: this.clientUri,
			grant_types: ["authorization_code", "refresh_token"],
			redirect_uris: [this.redirectUrl],
			response_types: ["code"],
			token_endpoint_auth_method: "none"
		};
	}
	get clientUri() {
		return new URL(this.redirectUrl).origin;
	}
	get redirectUrl() {
		return `${this.baseRedirectUrl}/${this.serverId}`;
	}
	get clientId() {
		if (!this._clientId_) throw new Error("Trying to access clientId before it was set");
		return this._clientId_;
	}
	set clientId(clientId_) {
		this._clientId_ = clientId_;
	}
	get serverId() {
		if (!this._serverId_) throw new Error("Trying to access serverId before it was set");
		return this._serverId_;
	}
	set serverId(serverId_) {
		this._serverId_ = serverId_;
	}
	keyPrefix(clientId) {
		return `/${this.clientName}/${this.serverId}/${clientId}`;
	}
	clientInfoKey(clientId) {
		return `${this.keyPrefix(clientId)}/client_info/`;
	}
	async clientInformation() {
		if (!this._clientId_) return;
		return await this.storage.get(this.clientInfoKey(this.clientId)) ?? void 0;
	}
	async saveClientInformation(clientInformation) {
		await this.storage.put(this.clientInfoKey(clientInformation.client_id), clientInformation);
		this.clientId = clientInformation.client_id;
	}
	tokenKey(clientId) {
		return `${this.keyPrefix(clientId)}/token`;
	}
	async tokens() {
		if (!this._clientId_) return;
		return await this.storage.get(this.tokenKey(this.clientId)) ?? void 0;
	}
	async saveTokens(tokens) {
		await this.storage.put(this.tokenKey(this.clientId), tokens);
	}
	get authUrl() {
		return this._authUrl_;
	}
	/**
	* Because this operates on the server side (but we need browser auth), we send this url back to the user
	* and require user interact to initiate the redirect flow
	*/
	async redirectToAuthorization(authUrl) {
		const stateToken = nanoid();
		authUrl.searchParams.set("state", stateToken);
		this._authUrl_ = authUrl.toString();
	}
	codeVerifierKey(clientId) {
		return `${this.keyPrefix(clientId)}/code_verifier`;
	}
	async saveCodeVerifier(verifier) {
		const key = this.codeVerifierKey(this.clientId);
		if (await this.storage.get(key)) return;
		await this.storage.put(key, verifier);
	}
	async codeVerifier() {
		const codeVerifier = await this.storage.get(this.codeVerifierKey(this.clientId));
		if (!codeVerifier) throw new Error("No code verifier found");
		return codeVerifier;
	}
};

//#endregion
export { DurableObjectOAuthClientProvider as t };
//# sourceMappingURL=do-oauth-client-provider-CwqK5SXm.js.map