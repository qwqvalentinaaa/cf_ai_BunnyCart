import { t as MessageType } from "./ai-types-CrMqkwc_.js";
import { nanoid } from "nanoid";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport, getToolName, isToolUIPart } from "ai";
import { use, useCallback, useEffect, useMemo, useRef } from "react";

//#region src/ai-react.tsx
const requestCache = /* @__PURE__ */ new Map();
/**
* React hook for building AI chat interfaces using an Agent
* @param options Chat options including the agent connection
* @returns Chat interface controls and state with added clearHistory method
*/
/**
* Automatically detects which tools require confirmation based on their configuration.
* Tools require confirmation if they have no execute function AND are not server-executed.
* @param tools - Record of tool name to tool definition
* @returns Array of tool names that require confirmation
*/
function detectToolsRequiringConfirmation(tools) {
	if (!tools) return [];
	return Object.entries(tools).filter(([_name, tool$1]) => !tool$1.execute).map(([name]) => name);
}
function useAgentChat(options) {
	const { agent, getInitialMessages, messages: optionsInitialMessages, experimental_automaticToolResolution, tools, toolsRequiringConfirmation: manualToolsRequiringConfirmation, autoSendAfterAllConfirmationsResolved = true, resume = true, ...rest } = options;
	const toolsRequiringConfirmation = manualToolsRequiringConfirmation ?? detectToolsRequiringConfirmation(tools);
	const agentUrl = new URL(`${(agent._url || agent._pkurl)?.replace("ws://", "http://").replace("wss://", "https://")}`);
	agentUrl.searchParams.delete("_pk");
	const agentUrlString = agentUrl.toString();
	const initialMessagesCacheKey = `${agentUrlString}|${agent.agent ?? ""}|${agent.name ?? ""}`;
	const agentRef = useRef(agent);
	useEffect(() => {
		agentRef.current = agent;
	}, [agent]);
	async function defaultGetInitialMessagesFetch({ url }) {
		const getMessagesUrl = new URL(url);
		getMessagesUrl.pathname += "/get-messages";
		const response = await fetch(getMessagesUrl.toString(), {
			credentials: options.credentials,
			headers: options.headers
		});
		if (!response.ok) {
			console.warn(`Failed to fetch initial messages: ${response.status} ${response.statusText}`);
			return [];
		}
		const text = await response.text();
		if (!text.trim()) return [];
		try {
			return JSON.parse(text);
		} catch (error) {
			console.warn("Failed to parse initial messages JSON:", error);
			return [];
		}
	}
	const getInitialMessagesFetch = getInitialMessages || defaultGetInitialMessagesFetch;
	function doGetInitialMessages(getInitialMessagesOptions, cacheKey) {
		if (requestCache.has(cacheKey)) return requestCache.get(cacheKey);
		const promise = getInitialMessagesFetch(getInitialMessagesOptions);
		requestCache.set(cacheKey, promise);
		return promise;
	}
	const initialMessagesPromise = getInitialMessages === null ? null : doGetInitialMessages({
		agent: agent.agent,
		name: agent.name,
		url: agentUrlString
	}, initialMessagesCacheKey);
	const initialMessages = initialMessagesPromise ? use(initialMessagesPromise) : optionsInitialMessages ?? [];
	useEffect(() => {
		if (!initialMessagesPromise) return;
		requestCache.set(initialMessagesCacheKey, initialMessagesPromise);
		return () => {
			if (requestCache.get(initialMessagesCacheKey) === initialMessagesPromise) requestCache.delete(initialMessagesCacheKey);
		};
	}, [initialMessagesCacheKey, initialMessagesPromise]);
	const aiFetch = useCallback(async (request, options$1 = {}) => {
		const { method, keepalive, headers, body, redirect, integrity, signal, credentials, mode, referrer, referrerPolicy, window } = options$1;
		const id = nanoid(8);
		const abortController = new AbortController();
		let controller;
		const currentAgent = agentRef.current;
		signal?.addEventListener("abort", () => {
			currentAgent.send(JSON.stringify({
				id,
				type: MessageType.CF_AGENT_CHAT_REQUEST_CANCEL
			}));
			abortController.abort();
			try {
				controller.close();
			} catch {}
		});
		currentAgent.addEventListener("message", (event) => {
			let data;
			try {
				data = JSON.parse(event.data);
			} catch (_error) {
				return;
			}
			if (data.type === MessageType.CF_AGENT_USE_CHAT_RESPONSE) {
				if (data.id === id) if (data.error) {
					controller.error(new Error(data.body));
					abortController.abort();
				} else {
					if (data.body?.trim()) controller.enqueue(new TextEncoder().encode(`data: ${data.body}\n\n`));
					if (data.done) {
						try {
							controller.close();
						} catch {}
						abortController.abort();
					}
				}
			}
		}, { signal: abortController.signal });
		const stream = new ReadableStream({
			start(c) {
				controller = c;
			},
			cancel(reason) {
				console.warn("[agents/ai-react] cancelling stream", id, reason || "no reason");
			}
		});
		currentAgent.send(JSON.stringify({
			id,
			init: {
				body,
				credentials,
				headers,
				integrity,
				keepalive,
				method,
				mode,
				redirect,
				referrer,
				referrerPolicy,
				window
			},
			type: MessageType.CF_AGENT_USE_CHAT_REQUEST,
			url: request.toString()
		}));
		return new Response(stream);
	}, []);
	const customTransport = useMemo(() => ({
		sendMessages: async (options$1) => {
			return new DefaultChatTransport({
				api: agentUrlString,
				fetch: aiFetch
			}).sendMessages(options$1);
		},
		reconnectToStream: async () => null
	}), [agentUrlString, aiFetch]);
	const useChatHelpers = useChat({
		...rest,
		messages: initialMessages,
		transport: customTransport,
		id: agent._pk
	});
	const processedToolCalls = useRef(/* @__PURE__ */ new Set());
	const lastMessage = useChatHelpers.messages[useChatHelpers.messages.length - 1];
	const pendingConfirmations = (() => {
		if (!lastMessage || lastMessage.role !== "assistant") return {
			messageId: void 0,
			toolCallIds: /* @__PURE__ */ new Set()
		};
		const pendingIds = /* @__PURE__ */ new Set();
		for (const part of lastMessage.parts ?? []) if (isToolUIPart(part) && part.state === "input-available" && toolsRequiringConfirmation.includes(getToolName(part))) pendingIds.add(part.toolCallId);
		return {
			messageId: lastMessage.id,
			toolCallIds: pendingIds
		};
	})();
	const pendingConfirmationsRef = useRef(pendingConfirmations);
	pendingConfirmationsRef.current = pendingConfirmations;
	useEffect(() => {
		if (!experimental_automaticToolResolution) return;
		const lastMessage$1 = useChatHelpers.messages[useChatHelpers.messages.length - 1];
		if (!lastMessage$1 || lastMessage$1.role !== "assistant") return;
		const toolCalls = lastMessage$1.parts.filter((part) => isToolUIPart(part) && part.state === "input-available" && !processedToolCalls.current.has(part.toolCallId));
		if (toolCalls.length > 0) (async () => {
			const toolCallsToResolve = toolCalls.filter((part) => isToolUIPart(part) && !toolsRequiringConfirmation.includes(getToolName(part)) && tools?.[getToolName(part)]?.execute);
			if (toolCallsToResolve.length > 0) {
				for (const part of toolCallsToResolve) if (isToolUIPart(part)) {
					processedToolCalls.current.add(part.toolCallId);
					let toolOutput = null;
					const toolName = getToolName(part);
					const tool$1 = tools?.[toolName];
					if (tool$1?.execute && part.input) try {
						toolOutput = await tool$1.execute(part.input);
					} catch (error) {
						toolOutput = `Error executing tool: ${error instanceof Error ? error.message : String(error)}`;
					}
					await useChatHelpers.addToolResult({
						toolCallId: part.toolCallId,
						tool: toolName,
						output: toolOutput
					});
				}
				if (pendingConfirmationsRef.current.toolCallIds.size === 0) useChatHelpers.sendMessage();
			}
		})();
	}, [
		useChatHelpers.messages,
		experimental_automaticToolResolution,
		useChatHelpers.addToolResult,
		useChatHelpers.sendMessage,
		toolsRequiringConfirmation
	]);
	/**
	* Contains the request ID, accumulated message parts, and a unique message ID.
	*/
	const resumedStreamRef = useRef(null);
	useEffect(() => {
		/**
		* Unified message handler that parses JSON once and dispatches based on type.
		* Avoids duplicate parsing overhead from separate listeners.
		*/
		function onAgentMessage(event) {
			if (typeof event.data !== "string") return;
			let data;
			try {
				data = JSON.parse(event.data);
			} catch (_error) {
				return;
			}
			switch (data.type) {
				case MessageType.CF_AGENT_CHAT_CLEAR:
					useChatHelpers.setMessages([]);
					break;
				case MessageType.CF_AGENT_CHAT_MESSAGES:
					useChatHelpers.setMessages(data.messages);
					break;
				case MessageType.CF_AGENT_STREAM_RESUMING:
					if (!resume) return;
					resumedStreamRef.current = null;
					resumedStreamRef.current = {
						id: data.id,
						messageId: nanoid(),
						parts: []
					};
					agentRef.current.send(JSON.stringify({
						type: MessageType.CF_AGENT_STREAM_RESUME_ACK,
						id: data.id
					}));
					break;
				case MessageType.CF_AGENT_USE_CHAT_RESPONSE:
					if (!resume || !resumedStreamRef.current) return;
					if (data.id !== resumedStreamRef.current.id) return;
					if (data.body?.trim()) try {
						const chunkData = JSON.parse(data.body);
						const resumedMsg = resumedStreamRef.current;
						switch (chunkData.type) {
							case "text-start":
								resumedMsg.parts.push({
									type: "text",
									text: "",
									state: "streaming"
								});
								break;
							case "text-delta": {
								const lastTextPart = [...resumedMsg.parts].reverse().find((p) => p.type === "text");
								if (lastTextPart && lastTextPart.type === "text") lastTextPart.text += chunkData.delta;
								else resumedMsg.parts.push({
									type: "text",
									text: chunkData.delta
								});
								break;
							}
							case "text-end": {
								const lastTextPart = [...resumedMsg.parts].reverse().find((p) => p.type === "text");
								if (lastTextPart && "state" in lastTextPart) lastTextPart.state = "done";
								break;
							}
							case "reasoning-start":
								resumedMsg.parts.push({
									type: "reasoning",
									text: "",
									state: "streaming"
								});
								break;
							case "reasoning-delta": {
								const lastReasoningPart = [...resumedMsg.parts].reverse().find((p) => p.type === "reasoning");
								if (lastReasoningPart && lastReasoningPart.type === "reasoning") lastReasoningPart.text += chunkData.delta;
								break;
							}
							case "reasoning-end": {
								const lastReasoningPart = [...resumedMsg.parts].reverse().find((p) => p.type === "reasoning");
								if (lastReasoningPart && "state" in lastReasoningPart) lastReasoningPart.state = "done";
								break;
							}
							case "file":
								resumedMsg.parts.push({
									type: "file",
									mediaType: chunkData.mediaType,
									url: chunkData.url
								});
								break;
							case "source-url":
								resumedMsg.parts.push({
									type: "source-url",
									sourceId: chunkData.sourceId,
									url: chunkData.url,
									title: chunkData.title
								});
								break;
							case "source-document":
								resumedMsg.parts.push({
									type: "source-document",
									sourceId: chunkData.sourceId,
									mediaType: chunkData.mediaType,
									title: chunkData.title,
									filename: chunkData.filename
								});
								break;
							case "tool-input-available":
								resumedMsg.parts.push({
									type: `tool-${chunkData.toolName}`,
									toolCallId: chunkData.toolCallId,
									toolName: chunkData.toolName,
									state: "input-available",
									input: chunkData.input
								});
								break;
							case "tool-output-available": {
								const toolPart = resumedMsg.parts.find((p) => "toolCallId" in p && p.toolCallId === chunkData.toolCallId);
								if (toolPart && "state" in toolPart) {
									toolPart.state = "output-available";
									toolPart.output = chunkData.output;
								}
								break;
							}
							case "step-start":
								resumedMsg.parts.push({ type: "step-start" });
								break;
						}
						useChatHelpers.setMessages((prevMessages) => {
							if (!resumedMsg) return prevMessages;
							const existingIdx = prevMessages.findIndex((m) => m.id === resumedMsg.messageId);
							const partialMessage = {
								id: resumedMsg.messageId,
								role: "assistant",
								parts: [...resumedMsg.parts]
							};
							if (existingIdx >= 0) {
								const updated = [...prevMessages];
								updated[existingIdx] = partialMessage;
								return updated;
							}
							return [...prevMessages, partialMessage];
						});
					} catch (parseError) {
						console.warn("[useAgentChat] Failed to parse resumed stream chunk:", parseError instanceof Error ? parseError.message : parseError, "body:", data.body?.slice(0, 100));
					}
					if (data.done || data.error) resumedStreamRef.current = null;
					break;
			}
		}
		agent.addEventListener("message", onAgentMessage);
		return () => {
			agent.removeEventListener("message", onAgentMessage);
			resumedStreamRef.current = null;
		};
	}, [
		agent,
		useChatHelpers.setMessages,
		resume
	]);
	const addToolResultAndSendMessage = async (args) => {
		const { toolCallId } = args;
		await useChatHelpers.addToolResult(args);
		if (!autoSendAfterAllConfirmationsResolved) {
			useChatHelpers.sendMessage();
			return;
		}
		const pending = pendingConfirmationsRef.current?.toolCallIds;
		if (!pending) {
			useChatHelpers.sendMessage();
			return;
		}
		const wasLast = pending.size === 1 && pending.has(toolCallId);
		if (pending.has(toolCallId)) pending.delete(toolCallId);
		if (wasLast || pending.size === 0) useChatHelpers.sendMessage();
	};
	return {
		...useChatHelpers,
		addToolResult: addToolResultAndSendMessage,
		clearHistory: () => {
			useChatHelpers.setMessages([]);
			agent.send(JSON.stringify({ type: MessageType.CF_AGENT_CHAT_CLEAR }));
		},
		setMessages: (messages) => {
			useChatHelpers.setMessages(messages);
			agent.send(JSON.stringify({
				messages: Array.isArray(messages) ? messages : [],
				type: MessageType.CF_AGENT_CHAT_MESSAGES
			}));
		}
	};
}

//#endregion
export { detectToolsRequiringConfirmation, useAgentChat };
//# sourceMappingURL=ai-react.js.map