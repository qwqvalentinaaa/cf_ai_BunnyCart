import "./client-CsaP9Irq.js";
import "./mcp-BwPscEiF.js";
import "./do-oauth-client-provider-C2CHH5x-.js";
import "./index-BUle9RiP.js";
import "./ai-types-81H_-Uxh.js";
import { n as AgentContext, t as Agent } from "./index-Bx5KK3VJ.js";
import { StreamTextOnFinishCallback, ToolSet, UIMessage } from "ai";

//#region src/ai-chat-agent.d.ts
/**
 * Extension of Agent with built-in chat capabilities
 * @template Env Environment type containing bindings
 */
declare class AIChatAgent<Env = unknown, State = unknown> extends Agent<
  Env,
  State
> {
  /**
   * Map of message `id`s to `AbortController`s
   * useful to propagate request cancellation signals for any external calls made by the agent
   */
  private _chatMessageAbortControllers;
  /**
   * Currently active stream ID for resumable streaming.
   * Stored in memory for quick access; persisted in stream_metadata table.
   */
  private _activeStreamId;
  /**
   * Request ID associated with the active stream.
   */
  private _activeRequestId;
  /**
   * Current chunk index for the active stream
   */
  private _streamChunkIndex;
  /**
   * Buffer for stream chunks pending write to SQLite.
   * Chunks are batched and flushed when buffer reaches CHUNK_BUFFER_SIZE.
   */
  private _chunkBuffer;
  /**
   * Lock to prevent concurrent flush operations
   */
  private _isFlushingChunks;
  /**
   * Timestamp of the last cleanup operation for old streams
   */
  private _lastCleanupTime;
  /** Array of chat messages for the current conversation */
  messages: UIMessage[];
  constructor(ctx: AgentContext, env: Env);
  /**
   * Restore active stream state if the agent was restarted during streaming.
   * Called during construction to recover any interrupted streams.
   * Validates stream freshness to avoid sending stale resume notifications.
   */
  private _restoreActiveStream;
  /**
   * Notify a connection about an active stream that can be resumed.
   * The client should respond with CF_AGENT_STREAM_RESUME_ACK to receive chunks.
   * Uses in-memory state for request ID - no extra DB lookup needed.
   * @param connection - The WebSocket connection to notify
   */
  private _notifyStreamResuming;
  /**
   * Send stream chunks to a connection after receiving ACK.
   * @param connection - The WebSocket connection
   * @param streamId - The stream to replay
   * @param requestId - The original request ID
   */
  private _sendStreamChunks;
  /**
   * Buffer a stream chunk for batch write to SQLite.
   * @param streamId - The stream this chunk belongs to
   * @param body - The serialized chunk body
   */
  private _storeStreamChunk;
  /**
   * Flush buffered chunks to SQLite in a single batch.
   * Uses a lock to prevent concurrent flush operations.
   */
  private _flushChunkBuffer;
  /**
   * Start tracking a new stream for resumable streaming.
   * Creates metadata entry in SQLite and sets up tracking state.
   * @param requestId - The unique ID of the chat request
   * @returns The generated stream ID
   */
  private _startStream;
  /**
   * Mark a stream as completed and flush any pending chunks.
   * @param streamId - The stream to mark as completed
   */
  private _completeStream;
  /**
   * Clean up old completed streams if enough time has passed since last cleanup.
   * This prevents database growth while avoiding cleanup overhead on every stream completion.
   */
  private _maybeCleanupOldStreams;
  private _broadcastChatMessage;
  private _loadMessagesFromDb;
  onRequest(request: Request): Promise<Response>;
  private _tryCatchChat;
  /**
   * Handle incoming chat messages and generate a response
   * @param onFinish Callback to be called when the response is finished
   * @param options.signal A signal to pass to any child requests which can be used to cancel them
   * @returns Response to send to the client or undefined
   */
  onChatMessage(
    onFinish: StreamTextOnFinishCallback<ToolSet>,
    options?: {
      abortSignal: AbortSignal | undefined;
    }
  ): Promise<Response | undefined>;
  /**
   * Save messages on the server side
   * @param messages Chat messages to save
   */
  saveMessages(messages: UIMessage[]): Promise<void>;
  persistMessages(
    messages: UIMessage[],
    excludeBroadcastIds?: string[]
  ): Promise<void>;
  private _reply;
  /**
   * Mark a stream as errored and clean up state.
   * @param streamId - The stream to mark as errored
   */
  private _markStreamError;
  /**
   * For the given message id, look up its associated AbortController
   * If the AbortController does not exist, create and store one in memory
   *
   * returns the AbortSignal associated with the AbortController
   */
  private _getAbortSignal;
  /**
   * Remove an abort controller from the cache of pending message responses
   */
  private _removeAbortController;
  /**
   * Propagate an abort signal for any requests associated with the given message id
   */
  private _cancelChatRequest;
  /**
   * Abort all pending requests and clear the cache of AbortControllers
   */
  private _destroyAbortControllers;
  /**
   * When the DO is destroyed, cancel all pending requests and clean up resources
   */
  destroy(): Promise<void>;
}
//#endregion
export { AIChatAgent };
//# sourceMappingURL=ai-chat-agent.d.ts.map
