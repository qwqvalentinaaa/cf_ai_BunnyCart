{"version":3,"file":"x402.js","names":["decoded: PaymentPayload","result: CallToolResult","listTools: typeof _listTools"],"sources":["../../src/mcp/x402.ts"],"sourcesContent":["/**\n * X402 MCP Integration\n *\n * Based on:\n * - Coinbase's x402 (Apache 2.0): https://github.com/coinbase/x402\n * - @ethanniser and his work at https://github.com/ethanniser/x402-mcp\n */\n\nimport type {\n  McpServer,\n  RegisteredTool,\n  ToolCallback\n} from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport type { Client as MCPClient } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type {\n  CallToolResultSchema,\n  CompatibilityCallToolResultSchema,\n  CallToolRequest,\n  CallToolResult,\n  ToolAnnotations\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { ZodRawShape } from \"zod\";\nimport { base, baseSepolia, type Chain } from \"viem/chains\";\n\nimport { processPriceToAtomicAmount } from \"x402/shared\";\nimport { exact } from \"x402/schemes\";\nimport { useFacilitator } from \"x402/verify\";\nimport type {\n  FacilitatorConfig,\n  Network,\n  PaymentPayload,\n  PaymentRequirements,\n  Wallet\n} from \"x402/types\";\nimport type { RequestOptions } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport { createWalletClient, http, type Account } from \"viem\";\nimport { createPaymentHeader } from \"x402/client\";\n\n/*\n  ======= SERVER SIDE =======\n*/\n\nexport type X402Config = {\n  network: Network;\n  recipient: `0x${string}`;\n  facilitator: FacilitatorConfig;\n  version?: number;\n};\n\nexport interface X402AugmentedServer {\n  paidTool<Args extends ZodRawShape>(\n    name: string,\n    description: string,\n    priceUSD: number,\n    paramsSchema: Args,\n    annotations: ToolAnnotations,\n    cb: ToolCallback<Args>\n  ): RegisteredTool;\n}\n\nexport function withX402<T extends McpServer>(\n  server: McpServer,\n  cfg: X402Config\n): T & X402AugmentedServer {\n  const { verify, settle } = useFacilitator(cfg.facilitator);\n  const x402Version = cfg.version ?? 1;\n\n  function paidTool<Args extends ZodRawShape>(\n    name: string,\n    description: string,\n    priceUSD: number,\n    paramsSchema: Args,\n    annotations: ToolAnnotations,\n    cb: ToolCallback<Args>\n  ): RegisteredTool {\n    return server.registerTool(\n      name,\n      {\n        description,\n        inputSchema: paramsSchema,\n        annotations,\n        _meta: {\n          \"agents-x402/paymentRequired\": true,\n          \"agents-x402/priceUSD\": priceUSD\n        }\n      },\n      (async (args, extra) => {\n        // Build PaymentRequirements for this call\n        const atomic = processPriceToAtomicAmount(priceUSD, cfg.network);\n        if (\"error\" in atomic) {\n          const payload = { x402Version, error: \"PRICE_COMPUTE_FAILED\" };\n          return {\n            isError: true,\n            _meta: { \"x402/error\": payload },\n            content: [{ type: \"text\", text: JSON.stringify(payload) }]\n          } as const;\n        }\n        const { maxAmountRequired, asset } = atomic;\n        const requirements = {\n          scheme: \"exact\" as const,\n          network: cfg.network,\n          maxAmountRequired,\n          payTo: cfg.recipient,\n          asset: asset.address,\n          maxTimeoutSeconds: 300,\n          resource: `x402://${name}`,\n          mimeType: \"application/json\" as const,\n          description,\n          extra: \"eip712\" in asset ? asset.eip712 : undefined\n        };\n\n        // Get token either from MCP _meta or from header\n        const headers = extra?.requestInfo?.headers ?? {};\n        const token =\n          (extra?._meta?.[\"x402/payment\"] as string | undefined) ??\n          headers[\"X-PAYMENT\"];\n\n        const paymentRequired = (\n          reason = \"PAYMENT_REQUIRED\",\n          extraFields: Record<string, unknown> = {}\n        ) => {\n          const payload = {\n            x402Version,\n            error: reason,\n            accepts: [requirements],\n            ...extraFields\n          };\n          return {\n            isError: true,\n            _meta: { \"x402/error\": payload },\n            content: [{ type: \"text\", text: JSON.stringify(payload) }]\n          } as const;\n        };\n\n        if (!token || typeof token !== \"string\") return paymentRequired();\n\n        // Decode & verify\n        let decoded: PaymentPayload;\n        try {\n          decoded = exact.evm.decodePayment(token);\n          decoded.x402Version = x402Version;\n        } catch {\n          return paymentRequired(\"INVALID_PAYMENT\");\n        }\n\n        const vr = await verify(decoded, requirements);\n        if (!vr.isValid) {\n          return paymentRequired(vr.invalidReason ?? \"INVALID_PAYMENT\", {\n            payer: vr.payer\n          });\n        }\n\n        // Execute tool\n        let result: CallToolResult;\n        let failed = false;\n        try {\n          result = await cb(args, extra);\n          if (\n            result &&\n            typeof result === \"object\" &&\n            \"isError\" in result &&\n            result.isError\n          ) {\n            failed = true;\n          }\n        } catch (e) {\n          failed = true;\n          result = {\n            isError: true,\n            content: [\n              { type: \"text\", text: `Tool execution failed: ${String(e)}` }\n            ]\n          };\n        }\n\n        // Settle only on success\n        if (!failed) {\n          try {\n            const s = await settle(decoded, requirements);\n            if (s.success) {\n              result._meta ??= {};\n              result._meta[\"x402/payment-response\"] = {\n                success: true,\n                transaction: s.transaction,\n                network: s.network,\n                payer: s.payer\n              };\n            } else {\n              return paymentRequired(s.errorReason ?? \"SETTLEMENT_FAILED\");\n            }\n          } catch {\n            return paymentRequired(\"SETTLEMENT_FAILED\");\n          }\n        }\n\n        return result;\n      }) as ToolCallback<Args>\n    );\n  }\n\n  Object.defineProperty(server, \"paidTool\", {\n    value: paidTool,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  // Tell TS the object now also has the paidTool method\n  return server as T & X402AugmentedServer;\n}\n\n/*\n  ======= CLIENT SIDE =======\n*/\n\nconst toChain = (network: Network): Chain => {\n  switch (network) {\n    case \"base\":\n      return base;\n    case \"base-sepolia\":\n      return baseSepolia;\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n};\n\nexport interface X402AugmentedClient {\n  callTool(\n    x402ConfirmationCallback:\n      | ((payment: PaymentRequirements[]) => Promise<boolean>)\n      | null,\n    params: CallToolRequest[\"params\"],\n    resultSchema?:\n      | typeof CallToolResultSchema\n      | typeof CompatibilityCallToolResultSchema,\n    options?: RequestOptions\n  ): Promise<CallToolResult>;\n}\n\nexport type X402ClientConfig = {\n  network: Network; // we only support base and base-sepolia for now\n  account: Account;\n  maxPaymentValue?: bigint;\n  version?: number;\n  confirmationCallback?: (payment: PaymentRequirements[]) => Promise<boolean>; // Confirmation callback for payment\n};\n\nexport function withX402Client<T extends MCPClient>(\n  client: T,\n  x402Config: X402ClientConfig\n): X402AugmentedClient & T {\n  const { network, account, version } = x402Config;\n  const wallet = createWalletClient({\n    account,\n    transport: http(),\n    chain: toChain(network)\n  });\n\n  const maxPaymentValue = x402Config.maxPaymentValue ?? BigInt(0.1 * 10 ** 6); // 0.10 USDC\n\n  const _listTools = client.listTools.bind(client);\n\n  // Wrap the original method to include payment information in the description\n  const listTools: typeof _listTools = async (params, options) => {\n    const toolsRes = await _listTools(params, options);\n    toolsRes.tools = toolsRes.tools.map((tool) => {\n      let description = tool.description;\n      // Check _meta for payment information (agents-x402/ is our extension for pre-advertising prices)\n      if (tool._meta?.[\"agents-x402/paymentRequired\"]) {\n        const cost = tool._meta?.[\"agents-x402/priceUSD\"]\n          ? `$${tool._meta?.[\"agents-x402/priceUSD\"]}`\n          : \"an unknown amount\";\n        description += ` (This is a paid tool, you will be charged ${cost} for its execution)`;\n      }\n      return {\n        ...tool,\n        description\n      };\n    });\n\n    // Wrap each tool to add payment support\n\n    return toolsRes;\n  };\n\n  const _callTool = client.callTool.bind(client);\n\n  const callToolWithPayment = async (\n    x402ConfirmationCallback:\n      | ((payment: PaymentRequirements[]) => Promise<boolean>)\n      | null,\n    params: CallToolRequest[\"params\"],\n    resultSchema?:\n      | typeof CallToolResultSchema\n      | typeof CompatibilityCallToolResultSchema,\n    options?: RequestOptions\n  ): ReturnType<typeof client.callTool> => {\n    // call the tool\n    const res = await _callTool(params, resultSchema, options);\n    console.log(\"res\", res);\n\n    // If it errored and returned accepts, we need to confirm payment\n    const maybeX402Error = res._meta?.[\"x402/error\"] as\n      | { accepts: PaymentRequirements[] }\n      | undefined;\n\n    if (\n      res.isError &&\n      maybeX402Error &&\n      maybeX402Error.accepts &&\n      Array.isArray(maybeX402Error.accepts) &&\n      maybeX402Error.accepts.length > 0\n    ) {\n      const accepts = maybeX402Error.accepts;\n      const confirmationCallback =\n        x402ConfirmationCallback ?? x402Config.confirmationCallback;\n\n      // Use the x402 confirmation callback if provided\n      if (confirmationCallback && !(await confirmationCallback(accepts))) {\n        return {\n          isError: true,\n          content: [{ type: \"text\", text: \"User declined payment\" }]\n        };\n      }\n\n      // Pick the first exact-scheme requirement that matches our network\n      // (we're only setting one on the McpAgent side for now)\n      const req =\n        accepts.find((a) => a?.scheme === \"exact\" && a?.network === network) ??\n        accepts[0];\n\n      if (!req || req.scheme !== \"exact\") return res;\n\n      const maxAmountRequired = BigInt(req.maxAmountRequired);\n      if (maxAmountRequired > maxPaymentValue) {\n        return {\n          isError: true,\n          content: [\n            {\n              type: \"text\",\n              text: `Payment exceeds client cap: ${maxAmountRequired} > ${maxPaymentValue}`\n            }\n          ]\n        };\n      }\n\n      // Use x402/client to get the X-PAYMENT token\n      const token = await createPaymentHeader(\n        wallet as Wallet,\n        version ?? 1,\n        req\n      );\n\n      // Call the tool with the payment token\n      return _callTool(\n        {\n          ...params,\n          _meta: {\n            ...params._meta,\n            \"x402/payment\": token\n          }\n        },\n        resultSchema,\n        options\n      );\n    }\n\n    return res;\n  };\n\n  const _client = client as X402AugmentedClient & T;\n  _client.listTools = listTools;\n  Object.defineProperty(_client, \"callTool\", {\n    value: callToolWithPayment,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n\n  return _client;\n}\n"],"mappings":"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"}