import { a as MCPConnectionResult, d as BaseTransportType, f as CORSOptions, i as MCPClientOAuthResult, m as ServeOptions, o as MCPDiscoverResult, p as MaybePromise, r as MCPClientOAuthCallbackConfig, s as MCPServerOptions } from "../client-CsaP9Irq.js";
import "../mcp-BwPscEiF.js";
import "../do-oauth-client-provider-C2CHH5x-.js";
import "../index-BUle9RiP.js";
import "../ai-types-81H_-Uxh.js";
import { c as ConnectionContext, s as Connection, t as Agent } from "../index-Bx5KK3VJ.js";
import { SSEClientTransport, SSEClientTransportOptions } from "@modelcontextprotocol/sdk/client/sse.js";
import { StreamableHTTPClientTransport, StreamableHTTPClientTransportOptions } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { ElicitRequest, ElicitRequestSchema, ElicitResult, ElicitResult as ElicitResult$1, JSONRPCMessage, MessageExtraInfo } from "@modelcontextprotocol/sdk/types.js";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { Transport, TransportSendOptions } from "@modelcontextprotocol/sdk/shared/transport.js";

//#region src/mcp/client-transports.d.ts
/**
 * @deprecated Use SSEClientTransport from @modelcontextprotocol/sdk/client/sse.js instead. This alias will be removed in the next major version.
 */
declare class SSEEdgeClientTransport extends SSEClientTransport {
  constructor(url: URL, options: SSEClientTransportOptions);
}
/**
 * @deprecated Use StreamableHTTPClientTransport from @modelcontextprotocol/sdk/client/streamableHttp.js instead. This alias will be removed in the next major version.
 */
declare class StreamableHTTPEdgeClientTransport extends StreamableHTTPClientTransport {
  constructor(url: URL, options: StreamableHTTPClientTransportOptions);
}
//#endregion
//#region src/mcp/worker-transport.d.ts
declare const SUPPORTED_PROTOCOL_VERSIONS: readonly ["2025-03-26", "2025-06-18"];
type ProtocolVersion = (typeof SUPPORTED_PROTOCOL_VERSIONS)[number];
interface MCPStorageApi {
  get(): Promise<TransportState | undefined> | TransportState | undefined;
  set(state: TransportState): Promise<void> | void;
}
interface TransportState {
  sessionId?: string;
  initialized: boolean;
  protocolVersion?: ProtocolVersion;
}
interface WorkerTransportOptions {
  sessionIdGenerator?: () => string;
  /**
   * Enable traditional Request/Response mode, this will disable streaming.
   */
  enableJsonResponse?: boolean;
  onsessioninitialized?: (sessionId: string) => void;
  corsOptions?: CORSOptions;
  /**
   * Optional storage api for persisting transport state.
   * Use this to store session state in Durable Object/Agent storage
   * so it survives hibernation/restart.
   */
  storage?: MCPStorageApi;
}
declare class WorkerTransport implements Transport {
  started: boolean;
  private initialized;
  private sessionIdGenerator?;
  private enableJsonResponse;
  private onsessioninitialized?;
  private standaloneSseStreamId;
  private streamMapping;
  private requestToStreamMapping;
  private requestResponseMap;
  private corsOptions?;
  private protocolVersion?;
  private storage?;
  private stateRestored;
  sessionId?: string;
  onclose?: () => void;
  onerror?: (error: Error) => void;
  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;
  constructor(options?: WorkerTransportOptions);
  /**
   * Restore transport state from persistent storage.
   * This is automatically called on start.
   */
  private restoreState;
  /**
   * Persist current transport state to storage.
   */
  private saveState;
  start(): Promise<void>;
  private validateProtocolVersion;
  private getHeaders;
  handleRequest(request: Request, parsedBody?: unknown): Promise<Response>;
  private handleGetRequest;
  private handlePostRequest;
  private handleDeleteRequest;
  private handleOptionsRequest;
  private handleUnsupportedRequest;
  private validateSession;
  close(): Promise<void>;
  send(message: JSONRPCMessage, options?: TransportSendOptions): Promise<void>;
}
//#endregion
//#region src/mcp/auth-context.d.ts
interface McpAuthContext {
  props: Record<string, unknown>;
}
declare function getMcpAuthContext(): McpAuthContext | undefined;
//#endregion
//#region src/mcp/handler.d.ts
interface CreateMcpHandlerOptions extends WorkerTransportOptions {
  /**
   * The route path that this MCP handler should respond to.
   * If specified, the handler will only process requests that match this route.
   * @default "/mcp"
   */
  route?: string;
  /**
   * An optional auth context to use for handling MCP requests.
   * If not provided, the handler will look for props in the execution context.
   */
  authContext?: McpAuthContext;
  /**
   * An optional transport to use for handling MCP requests.
   * If not provided, a WorkerTransport will be created with the provided WorkerTransportOptions.
   */
  transport?: WorkerTransport;
}
declare function createMcpHandler(server: McpServer | Server, options?: CreateMcpHandlerOptions): (request: Request, env: unknown, ctx: ExecutionContext) => Promise<Response>;
/**
 * @deprecated This has been renamed to createMcpHandler, and experimental_createMcpHandler will be removed in the next major version
 */
declare function experimental_createMcpHandler(server: McpServer | Server, options?: CreateMcpHandlerOptions): (request: Request, env: unknown, ctx: ExecutionContext) => Promise<Response>;
//#endregion
//#region src/mcp/index.d.ts
declare abstract class McpAgent<Env = unknown, State = unknown, Props extends Record<string, unknown> = Record<string, unknown>> extends Agent<Env, State, Props> {
  private _transport?;
  props?: Props;
  abstract server: MaybePromise<McpServer | Server>;
  abstract init(): Promise<void>;
  setInitializeRequest(initializeRequest: JSONRPCMessage): Promise<void>;
  getInitializeRequest(): Promise<JSONRPCMessage | undefined>;
  /** Read the transport type for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getTransportType(): BaseTransportType;
  /** Read the sessionId for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getSessionId(): string;
  /** Get the unique WebSocket. SSE transport only. */
  getWebSocket(): Connection<unknown> | null;
  /** Returns a new transport matching the type of the Agent. */
  private initTransport;
  /** Update and store the props */
  updateProps(props?: Props): Promise<void>;
  reinitializeServer(): Promise<void>;
  /** Sets up the MCP transport and server every time the Agent is started.*/
  onStart(props?: Props): Promise<void>;
  /** Validates new WebSocket connections. */
  onConnect(conn: Connection, {
    request: req
  }: ConnectionContext): Promise<void>;
  /** Handles MCP Messages for the legacy SSE transport. */
  onSSEMcpMessage(_sessionId: string, messageBody: unknown, extraInfo?: MessageExtraInfo): Promise<Error | null>;
  /** Elicit user input with a message and schema */
  elicitInput(params: {
    message: string;
    requestedSchema: unknown;
  }): Promise<ElicitResult$1>;
  /** Wait for elicitation response through storage polling */
  private _waitForElicitationResponse;
  /** Handle elicitation responses */
  private _handleElicitationResponse;
  /** Return a handler for the given path for this MCP.
   * Defaults to Streamable HTTP transport.
   */
  static serve(path: string, {
    binding,
    corsOptions,
    transport,
    jurisdiction
  }?: ServeOptions): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
  /**
   * Legacy api
   **/
  static mount(path: string, opts?: Omit<ServeOptions, "transport">): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
  static serveSSE(path: string, opts?: Omit<ServeOptions, "transport">): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
}
//#endregion
export { type CreateMcpHandlerOptions, type ElicitRequest, ElicitRequestSchema, type ElicitResult, type MCPClientOAuthCallbackConfig, type MCPClientOAuthResult, type MCPConnectionResult, type MCPDiscoverResult, type MCPServerOptions, McpAgent, type McpAuthContext, SSEEdgeClientTransport, StreamableHTTPEdgeClientTransport, type TransportState, WorkerTransport, type WorkerTransportOptions, createMcpHandler, experimental_createMcpHandler, getMcpAuthContext };
//# sourceMappingURL=index.d.ts.map