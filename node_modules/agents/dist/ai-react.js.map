{"version":3,"file":"ai-react.js","names":["tool","options","controller: ReadableStreamDefaultController","data: OutgoingMessage<ChatMessage>","customTransport: ChatTransport<ChatMessage>","lastMessage","addToolResultAndSendMessage: typeof useChatHelpers.addToolResult"],"sources":["../src/ai-react.tsx"],"sourcesContent":["import { useChat, type UseChatOptions } from \"@ai-sdk/react\";\nimport { getToolName, isToolUIPart } from \"ai\";\nimport type {\n  ChatInit,\n  ChatTransport,\n  UIMessage as Message,\n  UIMessage\n} from \"ai\";\nimport { DefaultChatTransport } from \"ai\";\nimport { nanoid } from \"nanoid\";\nimport { use, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport type { OutgoingMessage } from \"./ai-types\";\nimport { MessageType } from \"./ai-types\";\nimport type { useAgent } from \"./react\";\n\nexport type AITool<Input = unknown, Output = unknown> = {\n  description?: string;\n  inputSchema?: unknown;\n  execute?: (input: Input) => Output | Promise<Output>;\n};\n\ntype GetInitialMessagesOptions = {\n  agent: string;\n  name: string;\n  url: string;\n};\n\n// v5 useChat parameters\ntype UseChatParams<M extends UIMessage = UIMessage> = ChatInit<M> &\n  UseChatOptions<M>;\n\n/**\n * Options for the useAgentChat hook\n */\ntype UseAgentChatOptions<\n  State,\n  ChatMessage extends UIMessage = UIMessage\n> = Omit<UseChatParams<ChatMessage>, \"fetch\"> & {\n  /** Agent connection from useAgent */\n  agent: ReturnType<typeof useAgent<State>>;\n  getInitialMessages?:\n    | undefined\n    | null\n    | ((options: GetInitialMessagesOptions) => Promise<ChatMessage[]>);\n  /** Request credentials */\n  credentials?: RequestCredentials;\n  /** Request headers */\n  headers?: HeadersInit;\n  /**\n   * @description Whether to automatically resolve tool calls that do not require human interaction.\n   * @experimental\n   */\n  experimental_automaticToolResolution?: boolean;\n  /**\n   * @description Tools object for automatic detection of confirmation requirements.\n   * Tools without execute function will require confirmation.\n   */\n  tools?: Record<string, AITool<unknown, unknown>>;\n  /**\n   * @description Manual override for tools requiring confirmation.\n   * If not provided, will auto-detect from tools object.\n   */\n  toolsRequiringConfirmation?: string[];\n  /**\n   * When true (default), automatically sends the next message only after\n   * all pending confirmation-required tool calls have been resolved.\n   * @default true\n   */\n  autoSendAfterAllConfirmationsResolved?: boolean;\n  /**\n   * Set to false to disable automatic stream resumption.\n   * @default true\n   */\n  resume?: boolean;\n};\n\nconst requestCache = new Map<string, Promise<Message[]>>();\n\n/**\n * React hook for building AI chat interfaces using an Agent\n * @param options Chat options including the agent connection\n * @returns Chat interface controls and state with added clearHistory method\n */\n/**\n * Automatically detects which tools require confirmation based on their configuration.\n * Tools require confirmation if they have no execute function AND are not server-executed.\n * @param tools - Record of tool name to tool definition\n * @returns Array of tool names that require confirmation\n */\nexport function detectToolsRequiringConfirmation(\n  tools?: Record<string, AITool<unknown, unknown>>\n): string[] {\n  if (!tools) return [];\n\n  return Object.entries(tools)\n    .filter(([_name, tool]) => !tool.execute)\n    .map(([name]) => name);\n}\n\nexport function useAgentChat<\n  State = unknown,\n  ChatMessage extends UIMessage = UIMessage\n>(\n  options: UseAgentChatOptions<State, ChatMessage>\n): ReturnType<typeof useChat<ChatMessage>> & {\n  clearHistory: () => void;\n} {\n  const {\n    agent,\n    getInitialMessages,\n    messages: optionsInitialMessages,\n    experimental_automaticToolResolution,\n    tools,\n    toolsRequiringConfirmation: manualToolsRequiringConfirmation,\n    autoSendAfterAllConfirmationsResolved = true,\n    resume = true, // Enable stream resumption by default\n    ...rest\n  } = options;\n\n  // Auto-detect tools requiring confirmation, or use manual override\n  const toolsRequiringConfirmation =\n    manualToolsRequiringConfirmation ?? detectToolsRequiringConfirmation(tools);\n\n  const agentUrl = new URL(\n    `${// @ts-expect-error we're using a protected _url property that includes query params\n    ((agent._url as string | null) || agent._pkurl)\n      ?.replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")}`\n  );\n\n  agentUrl.searchParams.delete(\"_pk\");\n  const agentUrlString = agentUrl.toString();\n\n  // we need to include agent.name in cache key to prevent collisions during agent switching.\n  // The URL may be stale between updateProperties() and reconnect(), but agent.name\n  // is updated synchronously, so each thread gets its own cache entry\n  const initialMessagesCacheKey = `${agentUrlString}|${agent.agent ?? \"\"}|${agent.name ?? \"\"}`;\n\n  // Keep a ref to always point to the latest agent instance\n  const agentRef = useRef(agent);\n  useEffect(() => {\n    agentRef.current = agent;\n  }, [agent]);\n\n  async function defaultGetInitialMessagesFetch({\n    url\n  }: GetInitialMessagesOptions) {\n    const getMessagesUrl = new URL(url);\n    getMessagesUrl.pathname += \"/get-messages\";\n    const response = await fetch(getMessagesUrl.toString(), {\n      credentials: options.credentials,\n      headers: options.headers\n    });\n\n    if (!response.ok) {\n      console.warn(\n        `Failed to fetch initial messages: ${response.status} ${response.statusText}`\n      );\n      return [];\n    }\n\n    const text = await response.text();\n    if (!text.trim()) {\n      return [];\n    }\n\n    try {\n      return JSON.parse(text) as ChatMessage[];\n    } catch (error) {\n      console.warn(\"Failed to parse initial messages JSON:\", error);\n      return [];\n    }\n  }\n\n  const getInitialMessagesFetch =\n    getInitialMessages || defaultGetInitialMessagesFetch;\n\n  function doGetInitialMessages(\n    getInitialMessagesOptions: GetInitialMessagesOptions,\n    cacheKey: string\n  ) {\n    if (requestCache.has(cacheKey)) {\n      return requestCache.get(cacheKey)! as Promise<ChatMessage[]>;\n    }\n    const promise = getInitialMessagesFetch(getInitialMessagesOptions);\n    requestCache.set(cacheKey, promise);\n    return promise;\n  }\n\n  const initialMessagesPromise =\n    getInitialMessages === null\n      ? null\n      : doGetInitialMessages(\n          {\n            agent: agent.agent,\n            name: agent.name,\n            url: agentUrlString\n          },\n          initialMessagesCacheKey\n        );\n  const initialMessages = initialMessagesPromise\n    ? use(initialMessagesPromise)\n    : (optionsInitialMessages ?? []);\n\n  useEffect(() => {\n    if (!initialMessagesPromise) {\n      return;\n    }\n    requestCache.set(initialMessagesCacheKey, initialMessagesPromise!);\n    return () => {\n      if (\n        requestCache.get(initialMessagesCacheKey) === initialMessagesPromise\n      ) {\n        requestCache.delete(initialMessagesCacheKey);\n      }\n    };\n  }, [initialMessagesCacheKey, initialMessagesPromise]);\n\n  const aiFetch = useCallback(\n    async (request: RequestInfo | URL, options: RequestInit = {}) => {\n      const {\n        method,\n        keepalive,\n        headers,\n        body,\n        redirect,\n        integrity,\n        signal,\n        credentials,\n        mode,\n        referrer,\n        referrerPolicy,\n        window\n      } = options;\n      const id = nanoid(8);\n      const abortController = new AbortController();\n      let controller: ReadableStreamDefaultController;\n      const currentAgent = agentRef.current;\n\n      signal?.addEventListener(\"abort\", () => {\n        currentAgent.send(\n          JSON.stringify({\n            id,\n            type: MessageType.CF_AGENT_CHAT_REQUEST_CANCEL\n          })\n        );\n\n        // NOTE - If we wanted to, we could preserve the \"interrupted\" message here, with the code below\n        //        However, I think it might be the responsibility of the library user to implement that behavior manually?\n        //        Reasoning: This code could be subject to collisions, as it \"force saves\" the messages we have locally\n        //\n        // agent.send(JSON.stringify({\n        //   type: MessageType.CF_AGENT_CHAT_MESSAGES,\n        //   messages: ... /* some way of getting current messages ref? */\n        // }))\n        abortController.abort();\n        // Make sure to also close the stream (cf. https://github.com/cloudflare/agents-starter/issues/69)\n        try {\n          controller.close();\n        } catch {\n          // Stream may already be errored or closed\n        }\n      });\n\n      currentAgent.addEventListener(\n        \"message\",\n        (event) => {\n          let data: OutgoingMessage<ChatMessage>;\n          try {\n            data = JSON.parse(event.data) as OutgoingMessage<ChatMessage>;\n          } catch (_error) {\n            // silently ignore invalid messages for now\n            // TODO: log errors with log levels\n            return;\n          }\n          if (data.type === MessageType.CF_AGENT_USE_CHAT_RESPONSE) {\n            if (data.id === id) {\n              if (data.error) {\n                controller.error(new Error(data.body));\n                abortController.abort();\n              } else {\n                // Only enqueue non-empty data to prevent JSON parsing errors\n                if (data.body?.trim()) {\n                  controller.enqueue(\n                    new TextEncoder().encode(`data: ${data.body}\\n\\n`)\n                  );\n                }\n                if (data.done) {\n                  try {\n                    controller.close();\n                  } catch {\n                    // Stream may already be errored or closed\n                  }\n                  abortController.abort();\n                }\n              }\n            }\n          }\n        },\n        { signal: abortController.signal }\n      );\n\n      const stream = new ReadableStream({\n        start(c) {\n          controller = c;\n        },\n        cancel(reason?: unknown) {\n          console.warn(\n            \"[agents/ai-react] cancelling stream\",\n            id,\n            reason || \"no reason\"\n          );\n        }\n      });\n\n      currentAgent.send(\n        JSON.stringify({\n          id,\n          init: {\n            body,\n            credentials,\n            headers,\n            integrity,\n            keepalive,\n            method,\n            mode,\n            redirect,\n            referrer,\n            referrerPolicy,\n            window\n          },\n          type: MessageType.CF_AGENT_USE_CHAT_REQUEST,\n          url: request.toString()\n        })\n      );\n\n      return new Response(stream);\n    },\n    []\n  );\n\n  const customTransport: ChatTransport<ChatMessage> = useMemo(\n    () => ({\n      sendMessages: async (\n        options: Parameters<\n          typeof DefaultChatTransport.prototype.sendMessages\n        >[0]\n      ) => {\n        const transport = new DefaultChatTransport<ChatMessage>({\n          api: agentUrlString,\n          fetch: aiFetch\n        });\n        return transport.sendMessages(options);\n      },\n      reconnectToStream: async () => null\n    }),\n    [agentUrlString, aiFetch]\n  );\n\n  const useChatHelpers = useChat<ChatMessage>({\n    ...rest,\n    messages: initialMessages,\n    transport: customTransport,\n    id: agent._pk\n    // Note: We handle stream resumption via WebSocket instead of HTTP,\n    // so we don't pass 'resume' to useChat. The onStreamResuming handler\n    // automatically resumes active streams when the WebSocket reconnects.\n  });\n\n  const processedToolCalls = useRef(new Set<string>());\n\n  // Calculate pending confirmations for the latest assistant message\n  const lastMessage =\n    useChatHelpers.messages[useChatHelpers.messages.length - 1];\n\n  const pendingConfirmations = (() => {\n    if (!lastMessage || lastMessage.role !== \"assistant\") {\n      return { messageId: undefined, toolCallIds: new Set<string>() };\n    }\n\n    const pendingIds = new Set<string>();\n    for (const part of lastMessage.parts ?? []) {\n      if (\n        isToolUIPart(part) &&\n        part.state === \"input-available\" &&\n        toolsRequiringConfirmation.includes(getToolName(part))\n      ) {\n        pendingIds.add(part.toolCallId);\n      }\n    }\n    return { messageId: lastMessage.id, toolCallIds: pendingIds };\n  })();\n\n  const pendingConfirmationsRef = useRef(pendingConfirmations);\n  pendingConfirmationsRef.current = pendingConfirmations;\n\n  // tools can be a different object everytime it's called,\n  // which might lead to this effect being called multiple times with different tools objects.\n  // we need to fix this, but that's a bigger refactor.\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we need to fix this\n  useEffect(() => {\n    if (!experimental_automaticToolResolution) {\n      return;\n    }\n\n    const lastMessage =\n      useChatHelpers.messages[useChatHelpers.messages.length - 1];\n    if (!lastMessage || lastMessage.role !== \"assistant\") {\n      return;\n    }\n\n    const toolCalls = lastMessage.parts.filter(\n      (part) =>\n        isToolUIPart(part) &&\n        part.state === \"input-available\" &&\n        !processedToolCalls.current.has(part.toolCallId)\n    );\n\n    if (toolCalls.length > 0) {\n      (async () => {\n        const toolCallsToResolve = toolCalls.filter(\n          (part) =>\n            isToolUIPart(part) &&\n            !toolsRequiringConfirmation.includes(getToolName(part)) &&\n            tools?.[getToolName(part)]?.execute // Only execute if client has execute function\n        );\n\n        if (toolCallsToResolve.length > 0) {\n          for (const part of toolCallsToResolve) {\n            if (isToolUIPart(part)) {\n              processedToolCalls.current.add(part.toolCallId);\n              let toolOutput = null;\n              const toolName = getToolName(part);\n              const tool = tools?.[toolName];\n\n              if (tool?.execute && part.input) {\n                try {\n                  toolOutput = await tool.execute(part.input);\n                } catch (error) {\n                  toolOutput = `Error executing tool: ${error instanceof Error ? error.message : String(error)}`;\n                }\n              }\n\n              await useChatHelpers.addToolResult({\n                toolCallId: part.toolCallId,\n                tool: toolName,\n                output: toolOutput\n              });\n            }\n          }\n          // If there are NO pending confirmations for the latest assistant message,\n          // we can continue the conversation. Otherwise, wait for the UI to resolve\n          // those confirmations; the addToolResult wrapper will send when the last\n          // pending confirmation is resolved.\n          if (pendingConfirmationsRef.current.toolCallIds.size === 0) {\n            useChatHelpers.sendMessage();\n          }\n        }\n      })();\n    }\n  }, [\n    useChatHelpers.messages,\n    experimental_automaticToolResolution,\n    useChatHelpers.addToolResult,\n    useChatHelpers.sendMessage,\n    toolsRequiringConfirmation\n  ]);\n\n  /**\n   * Contains the request ID, accumulated message parts, and a unique message ID.\n   */\n  const resumedStreamRef = useRef<{\n    id: string;\n    messageId: string;\n    parts: ChatMessage[\"parts\"];\n  } | null>(null);\n\n  useEffect(() => {\n    /**\n     * Unified message handler that parses JSON once and dispatches based on type.\n     * Avoids duplicate parsing overhead from separate listeners.\n     */\n    function onAgentMessage(event: MessageEvent) {\n      if (typeof event.data !== \"string\") return;\n\n      let data: OutgoingMessage<ChatMessage>;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage<ChatMessage>;\n      } catch (_error) {\n        return;\n      }\n\n      switch (data.type) {\n        case MessageType.CF_AGENT_CHAT_CLEAR:\n          useChatHelpers.setMessages([]);\n          break;\n\n        case MessageType.CF_AGENT_CHAT_MESSAGES:\n          useChatHelpers.setMessages(data.messages);\n          break;\n\n        case MessageType.CF_AGENT_STREAM_RESUMING:\n          if (!resume) return;\n          // Clear any previous incomplete resumed stream to prevent memory leak\n          resumedStreamRef.current = null;\n          // Initialize resumed stream state with unique ID\n          resumedStreamRef.current = {\n            id: data.id,\n            messageId: nanoid(),\n            parts: []\n          };\n          // Send ACK to server - we're ready to receive chunks\n          agentRef.current.send(\n            JSON.stringify({\n              type: MessageType.CF_AGENT_STREAM_RESUME_ACK,\n              id: data.id\n            })\n          );\n          break;\n\n        case MessageType.CF_AGENT_USE_CHAT_RESPONSE:\n          // Handle resumed stream chunks\n          if (!resume || !resumedStreamRef.current) return;\n          if (data.id !== resumedStreamRef.current.id) return;\n\n          if (data.body?.trim()) {\n            try {\n              const chunkData = JSON.parse(data.body);\n              const resumedMsg = resumedStreamRef.current;\n\n              // Handle all chunk types for complete message reconstruction\n              switch (chunkData.type) {\n                case \"text-start\": {\n                  resumedMsg.parts.push({\n                    type: \"text\",\n                    text: \"\",\n                    state: \"streaming\"\n                  });\n                  break;\n                }\n                case \"text-delta\": {\n                  const lastTextPart = [...resumedMsg.parts]\n                    .reverse()\n                    .find((p) => p.type === \"text\");\n                  if (lastTextPart && lastTextPart.type === \"text\") {\n                    lastTextPart.text += chunkData.delta;\n                  } else {\n                    // Handle plain text responses (no text-start)\n                    resumedMsg.parts.push({\n                      type: \"text\",\n                      text: chunkData.delta\n                    });\n                  }\n                  break;\n                }\n                case \"text-end\": {\n                  const lastTextPart = [...resumedMsg.parts]\n                    .reverse()\n                    .find((p) => p.type === \"text\");\n                  if (lastTextPart && \"state\" in lastTextPart) {\n                    lastTextPart.state = \"done\";\n                  }\n                  break;\n                }\n                case \"reasoning-start\": {\n                  resumedMsg.parts.push({\n                    type: \"reasoning\",\n                    text: \"\",\n                    state: \"streaming\"\n                  });\n                  break;\n                }\n                case \"reasoning-delta\": {\n                  const lastReasoningPart = [...resumedMsg.parts]\n                    .reverse()\n                    .find((p) => p.type === \"reasoning\");\n                  if (\n                    lastReasoningPart &&\n                    lastReasoningPart.type === \"reasoning\"\n                  ) {\n                    lastReasoningPart.text += chunkData.delta;\n                  }\n                  break;\n                }\n                case \"reasoning-end\": {\n                  const lastReasoningPart = [...resumedMsg.parts]\n                    .reverse()\n                    .find((p) => p.type === \"reasoning\");\n                  if (lastReasoningPart && \"state\" in lastReasoningPart) {\n                    lastReasoningPart.state = \"done\";\n                  }\n                  break;\n                }\n                case \"file\": {\n                  resumedMsg.parts.push({\n                    type: \"file\",\n                    mediaType: chunkData.mediaType,\n                    url: chunkData.url\n                  });\n                  break;\n                }\n                case \"source-url\": {\n                  resumedMsg.parts.push({\n                    type: \"source-url\",\n                    sourceId: chunkData.sourceId,\n                    url: chunkData.url,\n                    title: chunkData.title\n                  });\n                  break;\n                }\n                case \"source-document\": {\n                  resumedMsg.parts.push({\n                    type: \"source-document\",\n                    sourceId: chunkData.sourceId,\n                    mediaType: chunkData.mediaType,\n                    title: chunkData.title,\n                    filename: chunkData.filename\n                  });\n                  break;\n                }\n                case \"tool-input-available\": {\n                  // Add tool call part when input is available\n                  resumedMsg.parts.push({\n                    type: `tool-${chunkData.toolName}`,\n                    toolCallId: chunkData.toolCallId,\n                    toolName: chunkData.toolName,\n                    state: \"input-available\",\n                    input: chunkData.input\n                  } as ChatMessage[\"parts\"][number]);\n                  break;\n                }\n                case \"tool-output-available\": {\n                  // Update existing tool part with output\n                  const toolPart = resumedMsg.parts.find(\n                    (p) =>\n                      \"toolCallId\" in p && p.toolCallId === chunkData.toolCallId\n                  );\n                  if (toolPart && \"state\" in toolPart) {\n                    (toolPart as Record<string, unknown>).state =\n                      \"output-available\";\n                    (toolPart as Record<string, unknown>).output =\n                      chunkData.output;\n                  }\n                  break;\n                }\n                case \"step-start\": {\n                  resumedMsg.parts.push({ type: \"step-start\" });\n                  break;\n                }\n                // Other chunk types (tool-input-start, tool-input-delta, etc.)\n                // are intermediate states - the final state will be captured above\n              }\n\n              // Update messages with the partial response\n              useChatHelpers.setMessages((prevMessages: ChatMessage[]) => {\n                if (!resumedMsg) return prevMessages;\n\n                const existingIdx = prevMessages.findIndex(\n                  (m) => m.id === resumedMsg.messageId\n                );\n\n                const partialMessage = {\n                  id: resumedMsg.messageId,\n                  role: \"assistant\" as const,\n                  parts: [...resumedMsg.parts]\n                } as unknown as ChatMessage;\n\n                if (existingIdx >= 0) {\n                  const updated = [...prevMessages];\n                  updated[existingIdx] = partialMessage;\n                  return updated;\n                }\n                return [...prevMessages, partialMessage];\n              });\n            } catch (parseError) {\n              // Log corrupted chunk for debugging - could indicate data loss\n              console.warn(\n                \"[useAgentChat] Failed to parse resumed stream chunk:\",\n                parseError instanceof Error ? parseError.message : parseError,\n                \"body:\",\n                data.body?.slice(0, 100) // Truncate for logging\n              );\n            }\n          }\n\n          // Clear on completion or error\n          if (data.done || data.error) {\n            resumedStreamRef.current = null;\n          }\n          break;\n      }\n    }\n\n    agent.addEventListener(\"message\", onAgentMessage);\n    return () => {\n      agent.removeEventListener(\"message\", onAgentMessage);\n      // Clear resumed stream state on cleanup to prevent memory leak\n      resumedStreamRef.current = null;\n    };\n  }, [agent, useChatHelpers.setMessages, resume]);\n\n  // Wrapper that sends only when the last pending confirmation is resolved\n  const addToolResultAndSendMessage: typeof useChatHelpers.addToolResult =\n    async (args) => {\n      const { toolCallId } = args;\n\n      await useChatHelpers.addToolResult(args);\n\n      if (!autoSendAfterAllConfirmationsResolved) {\n        // always send immediately\n        useChatHelpers.sendMessage();\n        return;\n      }\n\n      // wait for all confirmations\n      const pending = pendingConfirmationsRef.current?.toolCallIds;\n      if (!pending) {\n        useChatHelpers.sendMessage();\n        return;\n      }\n\n      const wasLast = pending.size === 1 && pending.has(toolCallId);\n      if (pending.has(toolCallId)) {\n        pending.delete(toolCallId);\n      }\n\n      if (wasLast || pending.size === 0) {\n        useChatHelpers.sendMessage();\n      }\n    };\n\n  return {\n    ...useChatHelpers,\n    addToolResult: addToolResultAndSendMessage,\n    clearHistory: () => {\n      useChatHelpers.setMessages([]);\n      agent.send(\n        JSON.stringify({\n          type: MessageType.CF_AGENT_CHAT_CLEAR\n        })\n      );\n    },\n    setMessages: (\n      messages: Parameters<typeof useChatHelpers.setMessages>[0]\n    ) => {\n      useChatHelpers.setMessages(messages);\n      agent.send(\n        JSON.stringify({\n          messages: Array.isArray(messages) ? messages : [],\n          type: MessageType.CF_AGENT_CHAT_MESSAGES\n        })\n      );\n    }\n  };\n}\n"],"mappings":"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"}