import { builtinModules } from "node:module";
import * as vite from "vite";
import assert from "node:assert";
import { CoreHeaders, Log, LogLevel, Miniflare, Request as Request$1, Response as Response$1, coupleWebSocket, getDefaultDevRegistryPath, getNodeCompat, kUnsafeEphemeralUniqueKey } from "miniflare";
import { maybeStartOrUpdateRemoteProxySession, unstable_convertConfigBindingsToStartWorkerBindings, unstable_getDurableObjectClassNameToUseSQLiteMap, unstable_getMiniflareWorkerOptions, unstable_getVarsForDev, unstable_readConfig } from "wrangler";
import * as path$2 from "node:path";
import path, { relative } from "node:path";
import * as util$1 from "node:util";
import { format, inspect } from "node:util";
import { createHeaders, createRequest, sendResponse } from "@remix-run/node-fetch-server";
import * as fs$1 from "node:fs";
import fs, { readFileSync, realpathSync, statSync } from "node:fs";
import { getCloudflarePreset } from "@cloudflare/unenv-preset";
import { URL as URL$1, fileURLToPath, pathToFileURL } from "node:url";
import process$1 from "node:process";
import v8 from "node:v8";
import { defineEnv } from "unenv";
import * as fsp from "node:fs/promises";
import colors from "picocolors";
import getPort, { portNumbers } from "get-port";
import { execFileSync, spawn } from "child_process";
import { existsSync, readFileSync as readFileSync$1, statSync as statSync$1 } from "fs";
import { spawn as spawn$1 } from "node:child_process";
import { randomUUID } from "crypto";
import path$1 from "path";
import { globSync } from "tinyglobby";
import { WebSocketServer } from "ws";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i$1 = 0, n$1 = keys.length, key; i$1 < n$1; i$1++) {
		key = keys[i$1];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target$1) => (target$1 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target$1, "default", {
	value: mod,
	enumerable: true
}) : target$1, mod));

//#endregion
//#region src/utils.ts
const debuglog = util$1.debuglog("@cloudflare:vite-plugin");
/**
* Creates an internal plugin to be used inside the main `vite-plugin-cloudflare` plugin.
* The provided `name` will be prefixed with `vite-plugin-cloudflare:`.
*/
function createPlugin(name, pluginFactory) {
	return (ctx) => {
		return {
			name: `vite-plugin-cloudflare:${name}`,
			sharedDuringBuild: true,
			...pluginFactory(ctx)
		};
	};
}
function getOutputDirectory(userConfig, environmentName) {
	const rootOutputDirectory = userConfig.build?.outDir ?? "dist";
	return userConfig.environments?.[environmentName]?.build?.outDir ?? path$2.join(rootOutputDirectory, environmentName);
}
const postfixRE = /[?#].*$/;
function cleanUrl(url) {
	return url.replace(postfixRE, "");
}
function withTrailingSlash(path$3) {
	return path$3.endsWith("/") ? path$3 : `${path$3}/`;
}
function createRequestHandler(handler) {
	return async (req, res, next) => {
		let request$1;
		try {
			if (req.originalUrl) req.url = req.originalUrl;
			request$1 = createRequest(req, res);
			let response = await handler(toMiniflareRequest(request$1), req);
			if (req.httpVersionMajor === 2) {
				response = new Response$1(response.body, response);
				response.headers.delete("transfer-encoding");
			}
			await sendResponse(res, response);
		} catch (error) {
			if (request$1?.signal.aborted) return;
			next(error);
		}
	};
}
function toMiniflareRequest(request$1) {
	const host = request$1.headers.get("Host");
	const xForwardedHost = request$1.headers.get("X-Forwarded-Host");
	if (host && !xForwardedHost) request$1.headers.set("X-Forwarded-Host", host);
	const secFetchMode = request$1.headers.get("Sec-Fetch-Mode");
	if (secFetchMode) request$1.headers.set(CoreHeaders.SEC_FETCH_MODE, secFetchMode);
	return new Request$1(request$1.url, {
		method: request$1.method,
		headers: [["accept-encoding", "identity"], ...request$1.headers],
		body: request$1.body,
		duplex: "half",
		signal: request$1.signal
	});
}

//#endregion
//#region src/export-types.ts
function getWorkerNameToWorkerEntrypointExportsMap(workers) {
	const workerNameToWorkerEntrypointExportsMap = new Map(workers.map((worker) => [worker.config.name, /* @__PURE__ */ new Set()]));
	for (const worker of workers) for (const value of worker.config.services ?? []) if (value.entrypoint !== void 0 && value.entrypoint !== "default") workerNameToWorkerEntrypointExportsMap.get(value.service)?.add(value.entrypoint);
	return workerNameToWorkerEntrypointExportsMap;
}
function getWorkerNameToDurableObjectExportsMap(workers) {
	const workerNameToDurableObjectExportsMap = new Map(workers.map((worker) => [worker.config.name, new Set(unstable_getDurableObjectClassNameToUseSQLiteMap(worker.config.migrations).keys())]));
	for (const worker of workers) for (const value of worker.config.durable_objects.bindings) if (value.script_name) workerNameToDurableObjectExportsMap.get(value.script_name)?.add(value.class_name);
	else workerNameToDurableObjectExportsMap.get(worker.config.name)?.add(value.class_name);
	return workerNameToDurableObjectExportsMap;
}
function getWorkerNameToWorkflowEntrypointExportsMap(workers) {
	const workerNameToWorkflowEntrypointExportsMap = new Map(workers.map((worker) => [worker.config.name, /* @__PURE__ */ new Set()]));
	for (const worker of workers) for (const value of worker.config.workflows) if (value.script_name) workerNameToWorkflowEntrypointExportsMap.get(value.script_name)?.add(value.class_name);
	else workerNameToWorkflowEntrypointExportsMap.get(worker.config.name)?.add(value.class_name);
	return workerNameToWorkflowEntrypointExportsMap;
}
/**
* Derives initial export types for all Workers from the Worker config files and returns them in a Map
*/
function getInitialWorkerNameToExportTypesMap(resolvedPluginConfig) {
	const workers = [...resolvedPluginConfig.environmentNameToWorkerMap.values()];
	const workerNameToWorkerEntrypointExportsMap = getWorkerNameToWorkerEntrypointExportsMap(workers);
	const workerNameToDurableObjectExportsMap = getWorkerNameToDurableObjectExportsMap(workers);
	const workerNameToWorkflowEntrypointExportsMap = getWorkerNameToWorkflowEntrypointExportsMap(workers);
	return new Map(workers.map((worker) => {
		const workerEntrypointExports = workerNameToWorkerEntrypointExportsMap.get(worker.config.name);
		assert(workerEntrypointExports, `WorkerEntrypoint exports not found for Worker "${worker.config.name}"`);
		const durableObjectExports = workerNameToDurableObjectExportsMap.get(worker.config.name);
		assert(durableObjectExports, `DurableObject exports not found for Worker "${worker.config.name}"`);
		const workflowEntrypointExports = workerNameToWorkflowEntrypointExportsMap.get(worker.config.name);
		assert(workflowEntrypointExports, `WorkflowEntrypoint exports not found for Worker "${worker.config.name}"`);
		const exportTypes = {};
		for (const exportName of workerEntrypointExports) exportTypes[exportName] = "WorkerEntrypoint";
		for (const exportName of durableObjectExports) exportTypes[exportName] = "DurableObject";
		for (const exportName of workflowEntrypointExports) exportTypes[exportName] = "WorkflowEntrypoint";
		return [worker.config.name, exportTypes];
	}));
}
/**
* Fetches the export types for all Workers and returns them in a Map
*/
async function getCurrentWorkerNameToExportTypesMap(resolvedPluginConfig, viteDevServer, miniflare) {
	await viteDevServer.environments.client.pluginContainer.buildStart();
	const results = await Promise.all([...resolvedPluginConfig.environmentNameToWorkerMap].map(async ([environmentName, worker]) => {
		debuglog(`Fetching export types for worker "${worker.config.name}"`);
		const exportTypes = await viteDevServer.environments[environmentName].fetchWorkerExportTypes(miniflare, worker.config);
		return [worker.config.name, exportTypes];
	}));
	return new Map(results);
}
/**
* Compares the export types for all Workers and returns `true` if any have changed
*/
function compareWorkerNameToExportTypesMaps(oldWorkerNameToExportTypesMap, newWorkerNameToExportTypesMap) {
	for (const workerName of newWorkerNameToExportTypesMap.keys()) {
		const oldExportTypes = oldWorkerNameToExportTypesMap.get(workerName);
		assert(oldExportTypes, "Expected old export types to be defined");
		const newExportTypes = newWorkerNameToExportTypesMap.get(workerName);
		assert(newExportTypes, "Expected new export types to be defined");
		if (compareExportTypes(oldExportTypes, newExportTypes)) return true;
	}
	return false;
}
/**
* Compares two `ExportTypes` objects and returns true if they do not match.
* Checks for added/removed exports and changed export types.
*/
function compareExportTypes(oldExportTypes, newExportTypes) {
	const oldKeys = Object.keys(oldExportTypes);
	const newKeys = Object.keys(newExportTypes);
	if (oldKeys.length !== newKeys.length) return true;
	for (const key of newKeys) if (!(key in oldExportTypes) || oldExportTypes[key] !== newExportTypes[key]) return true;
	return false;
}

//#endregion
//#region src/context.ts
/**
* Used to provide context to internal plugins.
* It should be reinstantiated each time the main plugin is created.
*/
var PluginContext = class {
	#sharedContext;
	#resolvedPluginConfig;
	#resolvedViteConfig;
	constructor(sharedContext$1) {
		this.#sharedContext = sharedContext$1;
	}
	/** Creates a new Miniflare instance or updates the existing instance */
	async startOrUpdateMiniflare(options) {
		if (!this.#sharedContext.miniflare) {
			debuglog("Creating new Miniflare instance");
			this.#sharedContext.miniflare = new Miniflare(options);
		} else {
			debuglog("Updating the existing Miniflare instance");
			await this.#sharedContext.miniflare.setOptions(options);
		}
		debuglog("Miniflare is ready");
	}
	async disposeMiniflare() {
		await this.#sharedContext.miniflare?.dispose();
		this.#sharedContext.miniflare = void 0;
	}
	get miniflare() {
		assert(this.#sharedContext.miniflare, "Expected `miniflare` to be defined");
		return this.#sharedContext.miniflare;
	}
	/**
	* Gets the resolved inspector port provided by Miniflare
	*/
	async getResolvedInspectorPort() {
		if (this.resolvedPluginConfig.inspectorPort === false || !this.#sharedContext.miniflare) return null;
		const miniflareInspectorUrl = await this.#sharedContext.miniflare.getInspectorURL();
		return Number.parseInt(miniflareInspectorUrl.port);
	}
	setWorkerNameToExportTypesMap(workerNameToExportTypesMap) {
		this.#sharedContext.workerNameToExportTypesMap = workerNameToExportTypesMap;
	}
	get workerNameToExportTypesMap() {
		if (!this.#sharedContext.workerNameToExportTypesMap) {
			if (this.resolvedPluginConfig.type !== "workers") return /* @__PURE__ */ new Map();
			return getInitialWorkerNameToExportTypesMap(this.resolvedPluginConfig);
		}
		return this.#sharedContext.workerNameToExportTypesMap;
	}
	setHasShownWorkerConfigWarnings(hasShownWorkerConfigWarnings) {
		this.#sharedContext.hasShownWorkerConfigWarnings = hasShownWorkerConfigWarnings;
	}
	get hasShownWorkerConfigWarnings() {
		return this.#sharedContext.hasShownWorkerConfigWarnings;
	}
	setIsRestartingDevServer(isRestartingDevServer) {
		this.#sharedContext.isRestartingDevServer = isRestartingDevServer;
	}
	get isRestartingDevServer() {
		return this.#sharedContext.isRestartingDevServer;
	}
	setResolvedPluginConfig(resolvedPluginConfig) {
		this.#resolvedPluginConfig = resolvedPluginConfig;
	}
	get resolvedPluginConfig() {
		assert(this.#resolvedPluginConfig, "Expected `resolvedPluginConfig` to be defined");
		return this.#resolvedPluginConfig;
	}
	setResolvedViteConfig(resolvedViteConfig) {
		this.#resolvedViteConfig = resolvedViteConfig;
	}
	get resolvedViteConfig() {
		assert(this.#resolvedViteConfig, "Expected `resolvedViteConfig` to be defined");
		return this.#resolvedViteConfig;
	}
	getWorkerConfig(environmentName) {
		return this.resolvedPluginConfig.type === "workers" ? this.resolvedPluginConfig.environmentNameToWorkerMap.get(environmentName)?.config : void 0;
	}
	get entryWorkerConfig() {
		if (this.resolvedPluginConfig.type !== "workers") return;
		return this.resolvedPluginConfig.environmentNameToWorkerMap.get(this.resolvedPluginConfig.entryWorkerEnvironmentName)?.config;
	}
	getNodeJsCompat(environmentName) {
		return this.resolvedPluginConfig.type === "workers" ? this.resolvedPluginConfig.environmentNameToWorkerMap.get(environmentName)?.nodeJsCompat : void 0;
	}
};
function assertIsNotPreview(ctx) {
	assert(ctx.resolvedPluginConfig.type !== "preview", `Expected "assets-only" or "workers" plugin config`);
}
function assertIsPreview(ctx) {
	assert(ctx.resolvedPluginConfig.type === "preview", `Expected "preview" plugin config`);
}

//#endregion
//#region ../workers-shared/utils/configuration/constants.ts
const REDIRECTS_VERSION = 1;
const HEADERS_VERSION = 2;
const PERMITTED_STATUS_CODES = new Set([
	200,
	301,
	302,
	303,
	307,
	308
]);
const HEADER_SEPARATOR = ":";
const MAX_LINE_LENGTH = 2e3;
const MAX_HEADER_RULES = 100;
const MAX_DYNAMIC_REDIRECT_RULES = 100;
const MAX_STATIC_REDIRECT_RULES = 2e3;
const UNSET_OPERATOR = "! ";
const SPLAT_REGEX = /\*/g;
const PLACEHOLDER_REGEX = /:[A-Za-z]\w*/g;
/** Max number of rules in `run_worker_first` */
const MAX_ROUTES_RULES = 100;
/** Max char length of each rule in `run_worker_first` */
const MAX_ROUTES_RULE_LENGTH = 100;

//#endregion
//#region ../workers-shared/utils/configuration/parseStaticRouting.ts
function parseStaticRouting(input) {
	if (input.length === 0) throw new Error("No `run_worker_first` rules were provided; must provide at least 1 rule.");
	if (input.length > MAX_ROUTES_RULES) throw new Error(`Too many \`run_worker_first\` rules were provided; ${input.length} rules provided exceeds max of ${MAX_ROUTES_RULES}.`);
	const rawAssetWorkerRules = [];
	const assetWorkerRules = [];
	const userWorkerRules = [];
	const invalidRules = [];
	for (const rule of input) if (rule.startsWith("!/")) {
		assetWorkerRules.push(rule.slice(1));
		rawAssetWorkerRules.push(rule);
	} else if (rule.startsWith("/")) userWorkerRules.push(rule);
	else if (rule.startsWith("!")) invalidRules.push(`'${rule}': negative rules must start with '!/'`);
	else invalidRules.push(`'${rule}': rules must start with '/' or '!/'`);
	if (assetWorkerRules.length > 0 && userWorkerRules.length === 0) throw new Error("Only negative `run_worker_first` rules were provided; must provide at least 1 non-negative rule");
	const invalidAssetWorkerRules = validateStaticRoutingRules(rawAssetWorkerRules);
	const invalidUserWorkerRules = validateStaticRoutingRules(userWorkerRules);
	const errorMessage = formatInvalidRoutes([
		...invalidRules,
		...invalidUserWorkerRules,
		...invalidAssetWorkerRules
	]);
	if (errorMessage) throw new Error(errorMessage);
	return {
		asset_worker: assetWorkerRules,
		user_worker: userWorkerRules
	};
}
function validateStaticRoutingRules(rules) {
	const invalid = [];
	const seen = /* @__PURE__ */ new Set();
	for (const rule of rules) {
		if (rule.length > MAX_ROUTES_RULE_LENGTH) invalid.push(`'${rule}': all rules must be less than ${MAX_ROUTES_RULE_LENGTH} characters in length`);
		if (seen.has(rule)) invalid.push(`'${rule}': rule is a duplicate; rules must be unique`);
		if (rule.endsWith("*")) {
			for (const otherRule of rules) if (otherRule !== rule && otherRule.startsWith(rule.slice(0, -1))) invalid.push(`'${otherRule}': rule '${rule}' makes it redundant`);
		}
		seen.add(rule);
	}
	return invalid;
}
const formatInvalidRoutes = (invalidRules) => {
	if (invalidRules.length === 0) return;
	return `Invalid routes in \`run_worker_first\`:\n` + invalidRules.join("\n");
};

//#endregion
//#region src/deploy-config.ts
function getDeployConfigPath(root) {
	return path$2.resolve(root, ".wrangler", "deploy", "config.json");
}
function getWorkerConfigs(root) {
	const deployConfigPath = getDeployConfigPath(root);
	const deployConfig = JSON.parse(fs$1.readFileSync(deployConfigPath, "utf-8"));
	return [{ configPath: deployConfig.configPath }, ...deployConfig.auxiliaryWorkers].map(({ configPath }) => {
		return unstable_readConfig({ config: path$2.resolve(path$2.dirname(deployConfigPath), configPath) });
	});
}
function getRelativePathToWorkerConfig(deployConfigDirectory, root, outputDirectory) {
	return path$2.relative(deployConfigDirectory, path$2.resolve(root, outputDirectory, "wrangler.json"));
}
function writeDeployConfig(resolvedPluginConfig, resolvedViteConfig) {
	const deployConfigPath = getDeployConfigPath(resolvedViteConfig.root);
	const deployConfigDirectory = path$2.dirname(deployConfigPath);
	fs$1.mkdirSync(deployConfigDirectory, { recursive: true });
	if (resolvedPluginConfig.type === "assets-only") {
		const clientOutputDirectory = resolvedViteConfig.environments.client?.build.outDir;
		assert(clientOutputDirectory, "Unexpected error: client environment output directory is undefined");
		const deployConfig = {
			configPath: getRelativePathToWorkerConfig(deployConfigDirectory, resolvedViteConfig.root, clientOutputDirectory),
			auxiliaryWorkers: []
		};
		fs$1.writeFileSync(deployConfigPath, JSON.stringify(deployConfig));
	} else {
		let entryWorkerConfigPath;
		const auxiliaryWorkers = [];
		for (const environmentName of resolvedPluginConfig.environmentNameToWorkerMap.keys()) {
			const outputDirectory = resolvedViteConfig.environments[environmentName]?.build.outDir;
			assert(outputDirectory, `Unexpected error: ${environmentName} environment output directory is undefined`);
			const configPath = getRelativePathToWorkerConfig(deployConfigDirectory, resolvedViteConfig.root, outputDirectory);
			if (environmentName === resolvedPluginConfig.entryWorkerEnvironmentName) entryWorkerConfigPath = configPath;
			else auxiliaryWorkers.push({ configPath });
		}
		assert(entryWorkerConfigPath, `Unexpected error: entryWorkerConfigPath is undefined`);
		const deployConfig = {
			configPath: entryWorkerConfigPath,
			auxiliaryWorkers
		};
		fs$1.writeFileSync(deployConfigPath, JSON.stringify(deployConfig));
	}
}

//#endregion
//#region ../../node_modules/.pnpm/acorn@8.14.0/node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [
	509,
	0,
	227,
	0,
	150,
	4,
	294,
	9,
	1368,
	2,
	2,
	1,
	6,
	3,
	41,
	2,
	5,
	0,
	166,
	1,
	574,
	3,
	9,
	9,
	7,
	9,
	32,
	4,
	318,
	1,
	80,
	3,
	71,
	10,
	50,
	3,
	123,
	2,
	54,
	14,
	32,
	10,
	3,
	1,
	11,
	3,
	46,
	10,
	8,
	0,
	46,
	9,
	7,
	2,
	37,
	13,
	2,
	9,
	6,
	1,
	45,
	0,
	13,
	2,
	49,
	13,
	9,
	3,
	2,
	11,
	83,
	11,
	7,
	0,
	3,
	0,
	158,
	11,
	6,
	9,
	7,
	3,
	56,
	1,
	2,
	6,
	3,
	1,
	3,
	2,
	10,
	0,
	11,
	1,
	3,
	6,
	4,
	4,
	68,
	8,
	2,
	0,
	3,
	0,
	2,
	3,
	2,
	4,
	2,
	0,
	15,
	1,
	83,
	17,
	10,
	9,
	5,
	0,
	82,
	19,
	13,
	9,
	214,
	6,
	3,
	8,
	28,
	1,
	83,
	16,
	16,
	9,
	82,
	12,
	9,
	9,
	7,
	19,
	58,
	14,
	5,
	9,
	243,
	14,
	166,
	9,
	71,
	5,
	2,
	1,
	3,
	3,
	2,
	0,
	2,
	1,
	13,
	9,
	120,
	6,
	3,
	6,
	4,
	0,
	29,
	9,
	41,
	6,
	2,
	3,
	9,
	0,
	10,
	10,
	47,
	15,
	343,
	9,
	54,
	7,
	2,
	7,
	17,
	9,
	57,
	21,
	2,
	13,
	123,
	5,
	4,
	0,
	2,
	1,
	2,
	6,
	2,
	0,
	9,
	9,
	49,
	4,
	2,
	1,
	2,
	4,
	9,
	9,
	330,
	3,
	10,
	1,
	2,
	0,
	49,
	6,
	4,
	4,
	14,
	10,
	5350,
	0,
	7,
	14,
	11465,
	27,
	2343,
	9,
	87,
	9,
	39,
	4,
	60,
	6,
	26,
	9,
	535,
	9,
	470,
	0,
	2,
	54,
	8,
	3,
	82,
	0,
	12,
	1,
	19628,
	1,
	4178,
	9,
	519,
	45,
	3,
	22,
	543,
	4,
	4,
	5,
	9,
	7,
	3,
	6,
	31,
	3,
	149,
	2,
	1418,
	49,
	513,
	54,
	5,
	49,
	9,
	0,
	15,
	0,
	23,
	4,
	2,
	14,
	1361,
	6,
	2,
	16,
	3,
	6,
	2,
	1,
	2,
	4,
	101,
	0,
	161,
	6,
	10,
	9,
	357,
	0,
	62,
	13,
	499,
	13,
	245,
	1,
	2,
	9,
	726,
	6,
	110,
	6,
	6,
	9,
	4759,
	9,
	787719,
	239
];
var astralIdentifierStartCodes = [
	0,
	11,
	2,
	25,
	2,
	18,
	2,
	1,
	2,
	14,
	3,
	13,
	35,
	122,
	70,
	52,
	268,
	28,
	4,
	48,
	48,
	31,
	14,
	29,
	6,
	37,
	11,
	29,
	3,
	35,
	5,
	7,
	2,
	4,
	43,
	157,
	19,
	35,
	5,
	35,
	5,
	39,
	9,
	51,
	13,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	2,
	10,
	2,
	14,
	2,
	6,
	2,
	1,
	4,
	51,
	13,
	310,
	10,
	21,
	11,
	7,
	25,
	5,
	2,
	41,
	2,
	8,
	70,
	5,
	3,
	0,
	2,
	43,
	2,
	1,
	4,
	0,
	3,
	22,
	11,
	22,
	10,
	30,
	66,
	18,
	2,
	1,
	11,
	21,
	11,
	25,
	71,
	55,
	7,
	1,
	65,
	0,
	16,
	3,
	2,
	2,
	2,
	28,
	43,
	28,
	4,
	28,
	36,
	7,
	2,
	27,
	28,
	53,
	11,
	21,
	11,
	18,
	14,
	17,
	111,
	72,
	56,
	50,
	14,
	50,
	14,
	35,
	39,
	27,
	10,
	22,
	251,
	41,
	7,
	1,
	17,
	2,
	60,
	28,
	11,
	0,
	9,
	21,
	43,
	17,
	47,
	20,
	28,
	22,
	13,
	52,
	58,
	1,
	3,
	0,
	14,
	44,
	33,
	24,
	27,
	35,
	30,
	0,
	3,
	0,
	9,
	34,
	4,
	0,
	13,
	47,
	15,
	3,
	22,
	0,
	2,
	0,
	36,
	17,
	2,
	24,
	20,
	1,
	64,
	6,
	2,
	0,
	2,
	3,
	2,
	14,
	2,
	9,
	8,
	46,
	39,
	7,
	3,
	1,
	3,
	21,
	2,
	6,
	2,
	1,
	2,
	4,
	4,
	0,
	19,
	0,
	13,
	4,
	31,
	9,
	2,
	0,
	3,
	0,
	2,
	37,
	2,
	0,
	26,
	0,
	2,
	0,
	45,
	52,
	19,
	3,
	21,
	2,
	31,
	47,
	21,
	1,
	2,
	0,
	185,
	46,
	42,
	3,
	37,
	47,
	21,
	0,
	60,
	42,
	14,
	0,
	72,
	26,
	38,
	6,
	186,
	43,
	117,
	63,
	32,
	7,
	3,
	0,
	3,
	7,
	2,
	1,
	2,
	23,
	16,
	0,
	2,
	0,
	95,
	7,
	3,
	38,
	17,
	0,
	2,
	0,
	29,
	0,
	11,
	39,
	8,
	0,
	22,
	0,
	12,
	45,
	20,
	0,
	19,
	72,
	200,
	32,
	32,
	8,
	2,
	36,
	18,
	0,
	50,
	29,
	113,
	6,
	2,
	1,
	2,
	37,
	22,
	0,
	26,
	5,
	2,
	1,
	2,
	31,
	15,
	0,
	328,
	18,
	16,
	0,
	2,
	12,
	2,
	33,
	125,
	0,
	80,
	921,
	103,
	110,
	18,
	195,
	2637,
	96,
	16,
	1071,
	18,
	5,
	26,
	3994,
	6,
	582,
	6842,
	29,
	1763,
	568,
	8,
	30,
	18,
	78,
	18,
	29,
	19,
	47,
	17,
	3,
	32,
	20,
	6,
	18,
	433,
	44,
	212,
	63,
	129,
	74,
	6,
	0,
	67,
	12,
	65,
	1,
	2,
	0,
	29,
	6135,
	9,
	1237,
	42,
	9,
	8936,
	3,
	2,
	6,
	2,
	1,
	2,
	290,
	16,
	0,
	30,
	2,
	3,
	0,
	15,
	3,
	9,
	395,
	2309,
	106,
	6,
	12,
	4,
	8,
	8,
	9,
	5991,
	84,
	2,
	70,
	2,
	1,
	3,
	0,
	3,
	1,
	3,
	3,
	2,
	11,
	2,
	0,
	2,
	6,
	2,
	64,
	2,
	3,
	3,
	7,
	2,
	6,
	2,
	27,
	2,
	3,
	2,
	4,
	2,
	0,
	4,
	6,
	2,
	339,
	3,
	24,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	30,
	2,
	24,
	2,
	7,
	1845,
	30,
	7,
	5,
	262,
	61,
	147,
	44,
	11,
	6,
	17,
	0,
	322,
	29,
	19,
	43,
	485,
	27,
	229,
	29,
	3,
	0,
	496,
	6,
	2,
	3,
	2,
	1,
	2,
	14,
	2,
	196,
	60,
	67,
	8,
	0,
	1205,
	3,
	2,
	26,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	9,
	2,
	3,
	2,
	0,
	2,
	0,
	7,
	0,
	5,
	0,
	2,
	0,
	2,
	0,
	2,
	2,
	2,
	1,
	2,
	0,
	3,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	0,
	2,
	1,
	2,
	0,
	3,
	3,
	2,
	6,
	2,
	3,
	2,
	3,
	2,
	0,
	2,
	9,
	2,
	16,
	6,
	2,
	2,
	4,
	2,
	16,
	4421,
	42719,
	33,
	4153,
	7,
	221,
	3,
	5761,
	15,
	7472,
	16,
	621,
	2467,
	541,
	1507,
	4938,
	6,
	4191
];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
	3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	5: "class enum extends super const export import",
	6: "enum",
	strict: "implements interface let package private protected public static yield",
	strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
	5: ecma5AndLessKeywords,
	"5module": ecma5AndLessKeywords + " export import",
	6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set) {
	var pos = 65536;
	for (var i$1 = 0; i$1 < set.length; i$1 += 2) {
		pos += set[i$1];
		if (pos > code) return false;
		pos += set[i$1 + 1];
		if (pos >= code) return true;
	}
	return false;
}
function isIdentifierStart(code, astral) {
	if (code < 65) return code === 36;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
	if (code < 48) return code === 36;
	if (code < 58) return true;
	if (code < 65) return false;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123) return true;
	if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
	if (astral === false) return false;
	return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType$1(label, conf) {
	if (conf === void 0) conf = {};
	this.label = label;
	this.keyword = conf.keyword;
	this.beforeExpr = !!conf.beforeExpr;
	this.startsExpr = !!conf.startsExpr;
	this.isLoop = !!conf.isLoop;
	this.isAssign = !!conf.isAssign;
	this.prefix = !!conf.prefix;
	this.postfix = !!conf.postfix;
	this.binop = conf.binop || null;
	this.updateContext = null;
};
function binop(name, prec) {
	return new TokenType(name, {
		beforeExpr: true,
		binop: prec
	});
}
var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options) {
	if (options === void 0) options = {};
	options.keyword = name;
	return keywords[name] = new TokenType(name, options);
}
var types$1$1 = {
	num: new TokenType("num", startsExpr),
	regexp: new TokenType("regexp", startsExpr),
	string: new TokenType("string", startsExpr),
	name: new TokenType("name", startsExpr),
	privateId: new TokenType("privateId", startsExpr),
	eof: new TokenType("eof"),
	bracketL: new TokenType("[", {
		beforeExpr: true,
		startsExpr: true
	}),
	bracketR: new TokenType("]"),
	braceL: new TokenType("{", {
		beforeExpr: true,
		startsExpr: true
	}),
	braceR: new TokenType("}"),
	parenL: new TokenType("(", {
		beforeExpr: true,
		startsExpr: true
	}),
	parenR: new TokenType(")"),
	comma: new TokenType(",", beforeExpr),
	semi: new TokenType(";", beforeExpr),
	colon: new TokenType(":", beforeExpr),
	dot: new TokenType("."),
	question: new TokenType("?", beforeExpr),
	questionDot: new TokenType("?."),
	arrow: new TokenType("=>", beforeExpr),
	template: new TokenType("template"),
	invalidTemplate: new TokenType("invalidTemplate"),
	ellipsis: new TokenType("...", beforeExpr),
	backQuote: new TokenType("`", startsExpr),
	dollarBraceL: new TokenType("${", {
		beforeExpr: true,
		startsExpr: true
	}),
	eq: new TokenType("=", {
		beforeExpr: true,
		isAssign: true
	}),
	assign: new TokenType("_=", {
		beforeExpr: true,
		isAssign: true
	}),
	incDec: new TokenType("++/--", {
		prefix: true,
		postfix: true,
		startsExpr: true
	}),
	prefix: new TokenType("!/~", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	logicalOR: binop("||", 1),
	logicalAND: binop("&&", 2),
	bitwiseOR: binop("|", 3),
	bitwiseXOR: binop("^", 4),
	bitwiseAND: binop("&", 5),
	equality: binop("==/!=/===/!==", 6),
	relational: binop("</>/<=/>=", 7),
	bitShift: binop("<</>>/>>>", 8),
	plusMin: new TokenType("+/-", {
		beforeExpr: true,
		binop: 9,
		prefix: true,
		startsExpr: true
	}),
	modulo: binop("%", 10),
	star: binop("*", 10),
	slash: binop("/", 10),
	starstar: new TokenType("**", { beforeExpr: true }),
	coalesce: binop("??", 1),
	_break: kw("break"),
	_case: kw("case", beforeExpr),
	_catch: kw("catch"),
	_continue: kw("continue"),
	_debugger: kw("debugger"),
	_default: kw("default", beforeExpr),
	_do: kw("do", {
		isLoop: true,
		beforeExpr: true
	}),
	_else: kw("else", beforeExpr),
	_finally: kw("finally"),
	_for: kw("for", { isLoop: true }),
	_function: kw("function", startsExpr),
	_if: kw("if"),
	_return: kw("return", beforeExpr),
	_switch: kw("switch"),
	_throw: kw("throw", beforeExpr),
	_try: kw("try"),
	_var: kw("var"),
	_const: kw("const"),
	_while: kw("while", { isLoop: true }),
	_with: kw("with"),
	_new: kw("new", {
		beforeExpr: true,
		startsExpr: true
	}),
	_this: kw("this", startsExpr),
	_super: kw("super", startsExpr),
	_class: kw("class", startsExpr),
	_extends: kw("extends", beforeExpr),
	_export: kw("export"),
	_import: kw("import", startsExpr),
	_null: kw("null", startsExpr),
	_true: kw("true", startsExpr),
	_false: kw("false", startsExpr),
	_in: kw("in", {
		beforeExpr: true,
		binop: 7
	}),
	_instanceof: kw("instanceof", {
		beforeExpr: true,
		binop: 7
	}),
	_typeof: kw("typeof", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_void: kw("void", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	}),
	_delete: kw("delete", {
		beforeExpr: true,
		prefix: true,
		startsExpr: true
	})
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
	return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
	if (end === void 0) end = code.length;
	for (var i$1 = from; i$1 < end; i$1++) {
		var next = code.charCodeAt(i$1);
		if (isNewLine(next)) return i$1 < end - 1 && next === 13 && code.charCodeAt(i$1 + 1) === 10 ? i$1 + 2 : i$1 + 1;
	}
	return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty$2 = ref.hasOwnProperty;
var toString$1 = ref.toString;
var hasOwn = Object.hasOwn || (function(obj, propName) {
	return hasOwnProperty$2.call(obj, propName);
});
var isArray = Array.isArray || (function(obj) {
	return toString$1.call(obj) === "[object Array]";
});
var regexpCache = Object.create(null);
function wordsRegexp(words) {
	return regexpCache[words] || (regexpCache[words] = /* @__PURE__ */ new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
	if (code <= 65535) return String.fromCharCode(code);
	code -= 65536;
	return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position$1(line, col) {
	this.line = line;
	this.column = col;
};
Position.prototype.offset = function offset(n$1) {
	return new Position(this.line, this.column + n$1);
};
var SourceLocation = function SourceLocation$1(p, start, end) {
	this.start = start;
	this.end = end;
	if (p.sourceFile !== null) this.source = p.sourceFile;
};
function getLineInfo(input, offset) {
	for (var line = 1, cur = 0;;) {
		var nextBreak = nextLineBreak(input, cur, offset);
		if (nextBreak < 0) return new Position(line, offset - cur);
		++line;
		cur = nextBreak;
	}
}
var defaultOptions = {
	ecmaVersion: null,
	sourceType: "script",
	onInsertedSemicolon: null,
	onTrailingComma: null,
	allowReserved: null,
	allowReturnOutsideFunction: false,
	allowImportExportEverywhere: false,
	allowAwaitOutsideFunction: null,
	allowSuperOutsideMethod: null,
	allowHashBang: false,
	checkPrivateFields: true,
	locations: false,
	onToken: null,
	onComment: null,
	ranges: false,
	program: null,
	sourceFile: null,
	directSourceFile: null,
	preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
	var options = {};
	for (var opt in defaultOptions) options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
	if (options.ecmaVersion === "latest") options.ecmaVersion = 1e8;
	else if (options.ecmaVersion == null) {
		if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
			warnedAboutEcmaVersion = true;
			console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
		}
		options.ecmaVersion = 11;
	} else if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;
	if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;
	if (!opts || opts.allowHashBang == null) options.allowHashBang = options.ecmaVersion >= 14;
	if (isArray(options.onToken)) {
		var tokens = options.onToken;
		options.onToken = function(token) {
			return tokens.push(token);
		};
	}
	if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);
	return options;
}
function pushComment(options, array) {
	return function(block, text, start, end, startLoc, endLoc) {
		var comment = {
			type: block ? "Block" : "Line",
			value: text,
			start,
			end
		};
		if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
		if (options.ranges) comment.range = [start, end];
		array.push(comment);
	};
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
	return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
var Parser = function Parser$1(options, input, startPos) {
	this.options = options = getOptions(options);
	this.sourceFile = options.sourceFile;
	this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
	var reserved = "";
	if (options.allowReserved !== true) {
		reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
		if (options.sourceType === "module") reserved += " await";
	}
	this.reservedWords = wordsRegexp(reserved);
	var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
	this.reservedWordsStrict = wordsRegexp(reservedStrict);
	this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
	this.input = String(input);
	this.containsEsc = false;
	if (startPos) {
		this.pos = startPos;
		this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
		this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
	} else {
		this.pos = this.lineStart = 0;
		this.curLine = 1;
	}
	this.type = types$1$1.eof;
	this.value = null;
	this.start = this.end = this.pos;
	this.startLoc = this.endLoc = this.curPosition();
	this.lastTokEndLoc = this.lastTokStartLoc = null;
	this.lastTokStart = this.lastTokEnd = this.pos;
	this.context = this.initialContext();
	this.exprAllowed = true;
	this.inModule = options.sourceType === "module";
	this.strict = this.inModule || this.strictDirective(this.pos);
	this.potentialArrowAt = -1;
	this.potentialArrowInForAwait = false;
	this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
	this.labels = [];
	this.undefinedExports = Object.create(null);
	if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
	this.scopeStack = [];
	this.enterScope(SCOPE_TOP);
	this.regexpState = null;
	this.privateNameStack = [];
};
var prototypeAccessors = {
	inFunction: { configurable: true },
	inGenerator: { configurable: true },
	inAsync: { configurable: true },
	canAwait: { configurable: true },
	allowSuper: { configurable: true },
	allowDirectSuper: { configurable: true },
	treatFunctionsAsVar: { configurable: true },
	allowNewDotTarget: { configurable: true },
	inClassStaticBlock: { configurable: true }
};
Parser.prototype.parse = function parse() {
	var node = this.options.program || this.startNode();
	this.nextToken();
	return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
	return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
	return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
	return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
	for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) return false;
		if (scope.flags & SCOPE_FUNCTION) return (scope.flags & SCOPE_ASYNC) > 0;
	}
	return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
	var ref$1 = this.currentThisScope();
	var flags = ref$1.flags;
	var inClassFieldInit = ref$1.inClassFieldInit;
	return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
	return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
	return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
	var ref$1 = this.currentThisScope();
	var flags = ref$1.flags;
	var inClassFieldInit = ref$1.inClassFieldInit;
	return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
	return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
	var plugins = [], len = arguments.length;
	while (len--) plugins[len] = arguments[len];
	var cls = this;
	for (var i$1 = 0; i$1 < plugins.length; i$1++) cls = plugins[i$1](cls);
	return cls;
};
Parser.parse = function parse(input, options) {
	return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
	var parser = new this(options, input, pos);
	parser.nextToken();
	return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
	return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
	if (this.options.ecmaVersion < 5) return false;
	for (;;) {
		skipWhiteSpace.lastIndex = start;
		start += skipWhiteSpace.exec(this.input)[0].length;
		var match = literal.exec(this.input.slice(start));
		if (!match) return false;
		if ((match[1] || match[2]) === "use strict") {
			skipWhiteSpace.lastIndex = start + match[0].length;
			var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
			var next = this.input.charAt(end);
			return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
		}
		start += match[0].length;
		skipWhiteSpace.lastIndex = start;
		start += skipWhiteSpace.exec(this.input)[0].length;
		if (this.input[start] === ";") start++;
	}
};
pp$9.eat = function(type) {
	if (this.type === type) {
		this.next();
		return true;
	} else return false;
};
pp$9.isContextual = function(name) {
	return this.type === types$1$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
	if (!this.isContextual(name)) return false;
	this.next();
	return true;
};
pp$9.expectContextual = function(name) {
	if (!this.eatContextual(name)) this.unexpected();
};
pp$9.canInsertSemicolon = function() {
	return this.type === types$1$1.eof || this.type === types$1$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
	if (this.canInsertSemicolon()) {
		if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
		return true;
	}
};
pp$9.semicolon = function() {
	if (!this.eat(types$1$1.semi) && !this.insertSemicolon()) this.unexpected();
};
pp$9.afterTrailingComma = function(tokType, notNext) {
	if (this.type === tokType) {
		if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
		if (!notNext) this.next();
		return true;
	}
};
pp$9.expect = function(type) {
	this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
	this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors$1() {
	this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
	if (!refDestructuringErrors) return;
	if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
	var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
	if (parens > -1) this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	if (!refDestructuringErrors) return false;
	var shorthandAssign = refDestructuringErrors.shorthandAssign;
	var doubleProto = refDestructuringErrors.doubleProto;
	if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
	if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
	if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
};
pp$9.checkYieldAwaitInDefaultParams = function() {
	if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
	if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
};
pp$9.isSimpleAssignTarget = function(expr) {
	if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
	return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
	var exports = Object.create(null);
	if (!node.body) node.body = [];
	while (this.type !== types$1$1.eof) {
		var stmt = this.parseStatement(null, true, exports);
		node.body.push(stmt);
	}
	if (this.inModule) for (var i$1 = 0, list$1 = Object.keys(this.undefinedExports); i$1 < list$1.length; i$1 += 1) {
		var name = list$1[i$1];
		this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
	}
	this.adaptDirectivePrologue(node.body);
	this.next();
	node.sourceType = this.options.sourceType;
	return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
	if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
	skipWhiteSpace.lastIndex = this.pos;
	var skip = skipWhiteSpace.exec(this.input);
	var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
	if (nextCh === 91 || nextCh === 92) return true;
	if (context) return false;
	if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) return true;
	if (isIdentifierStart(nextCh, true)) {
		var pos = next + 1;
		while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) ++pos;
		if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) return true;
		var ident = this.input.slice(next, pos);
		if (!keywordRelationalOperator.test(ident)) return true;
	}
	return false;
};
pp$8.isAsyncFunction = function() {
	if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
	skipWhiteSpace.lastIndex = this.pos;
	var skip = skipWhiteSpace.exec(this.input);
	var next = this.pos + skip[0].length, after;
	return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
	var starttype = this.type, node = this.startNode(), kind;
	if (this.isLet(context)) {
		starttype = types$1$1._var;
		kind = "let";
	}
	switch (starttype) {
		case types$1$1._break:
		case types$1$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword);
		case types$1$1._debugger: return this.parseDebuggerStatement(node);
		case types$1$1._do: return this.parseDoStatement(node);
		case types$1$1._for: return this.parseForStatement(node);
		case types$1$1._function:
			if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
			return this.parseFunctionStatement(node, false, !context);
		case types$1$1._class:
			if (context) this.unexpected();
			return this.parseClass(node, true);
		case types$1$1._if: return this.parseIfStatement(node);
		case types$1$1._return: return this.parseReturnStatement(node);
		case types$1$1._switch: return this.parseSwitchStatement(node);
		case types$1$1._throw: return this.parseThrowStatement(node);
		case types$1$1._try: return this.parseTryStatement(node);
		case types$1$1._const:
		case types$1$1._var:
			kind = kind || this.value;
			if (context && kind !== "var") this.unexpected();
			return this.parseVarStatement(node, kind);
		case types$1$1._while: return this.parseWhileStatement(node);
		case types$1$1._with: return this.parseWithStatement(node);
		case types$1$1.braceL: return this.parseBlock(true, node);
		case types$1$1.semi: return this.parseEmptyStatement(node);
		case types$1$1._export:
		case types$1$1._import:
			if (this.options.ecmaVersion > 10 && starttype === types$1$1._import) {
				skipWhiteSpace.lastIndex = this.pos;
				var skip = skipWhiteSpace.exec(this.input);
				var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
				if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
			}
			if (!this.options.allowImportExportEverywhere) {
				if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
				if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
			}
			return starttype === types$1$1._import ? this.parseImport(node) : this.parseExport(node, exports);
		default:
			if (this.isAsyncFunction()) {
				if (context) this.unexpected();
				this.next();
				return this.parseFunctionStatement(node, true, !context);
			}
			var maybeName = this.value, expr = this.parseExpression();
			if (starttype === types$1$1.name && expr.type === "Identifier" && this.eat(types$1$1.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
			else return this.parseExpressionStatement(node, expr);
	}
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
	var isBreak = keyword === "break";
	this.next();
	if (this.eat(types$1$1.semi) || this.insertSemicolon()) node.label = null;
	else if (this.type !== types$1$1.name) this.unexpected();
	else {
		node.label = this.parseIdent();
		this.semicolon();
	}
	var i$1 = 0;
	for (; i$1 < this.labels.length; ++i$1) {
		var lab = this.labels[i$1];
		if (node.label == null || lab.name === node.label.name) {
			if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
			if (node.label && isBreak) break;
		}
	}
	if (i$1 === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
	this.next();
	this.semicolon();
	return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
	this.next();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("do");
	this.labels.pop();
	this.expect(types$1$1._while);
	node.test = this.parseParenExpression();
	if (this.options.ecmaVersion >= 6) this.eat(types$1$1.semi);
	else this.semicolon();
	return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
	this.next();
	var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
	this.labels.push(loopLabel);
	this.enterScope(0);
	this.expect(types$1$1.parenL);
	if (this.type === types$1$1.semi) {
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, null);
	}
	var isLet = this.isLet();
	if (this.type === types$1$1._var || this.type === types$1$1._const || isLet) {
		var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
		this.next();
		this.parseVar(init$1, true, kind);
		this.finishNode(init$1, "VariableDeclaration");
		if ((this.type === types$1$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
			if (this.options.ecmaVersion >= 9) if (this.type === types$1$1._in) {
				if (awaitAt > -1) this.unexpected(awaitAt);
			} else node.await = awaitAt > -1;
			return this.parseForIn(node, init$1);
		}
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, init$1);
	}
	var startsWithLet = this.isContextual("let"), isForOf = false;
	var containsEsc = this.containsEsc;
	var refDestructuringErrors = new DestructuringErrors();
	var initPos = this.start;
	var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
	if (this.type === types$1$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
		if (awaitAt > -1) {
			if (this.type === types$1$1._in) this.unexpected(awaitAt);
			node.await = true;
		} else if (isForOf && this.options.ecmaVersion >= 8) {
			if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") this.unexpected();
			else if (this.options.ecmaVersion >= 9) node.await = false;
		}
		if (startsWithLet && isForOf) this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
		this.toAssignable(init, false, refDestructuringErrors);
		this.checkLValPattern(init);
		return this.parseForIn(node, init);
	} else this.checkExpressionErrors(refDestructuringErrors, true);
	if (awaitAt > -1) this.unexpected(awaitAt);
	return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync$1, declarationPosition) {
	this.next();
	return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync$1);
};
pp$8.parseIfStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	node.consequent = this.parseStatement("if");
	node.alternate = this.eat(types$1$1._else) ? this.parseStatement("if") : null;
	return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
	if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	this.next();
	if (this.eat(types$1$1.semi) || this.insertSemicolon()) node.argument = null;
	else {
		node.argument = this.parseExpression();
		this.semicolon();
	}
	return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
	this.next();
	node.discriminant = this.parseParenExpression();
	node.cases = [];
	this.expect(types$1$1.braceL);
	this.labels.push(switchLabel);
	this.enterScope(0);
	var cur;
	for (var sawDefault = false; this.type !== types$1$1.braceR;) if (this.type === types$1$1._case || this.type === types$1$1._default) {
		var isCase = this.type === types$1$1._case;
		if (cur) this.finishNode(cur, "SwitchCase");
		node.cases.push(cur = this.startNode());
		cur.consequent = [];
		this.next();
		if (isCase) cur.test = this.parseExpression();
		else {
			if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
			sawDefault = true;
			cur.test = null;
		}
		this.expect(types$1$1.colon);
	} else {
		if (!cur) this.unexpected();
		cur.consequent.push(this.parseStatement(null));
	}
	this.exitScope();
	if (cur) this.finishNode(cur, "SwitchCase");
	this.next();
	this.labels.pop();
	return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
	this.next();
	if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	node.argument = this.parseExpression();
	this.semicolon();
	return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
	var param = this.parseBindingAtom();
	var simple = param.type === "Identifier";
	this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
	this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
	this.expect(types$1$1.parenR);
	return param;
};
pp$8.parseTryStatement = function(node) {
	this.next();
	node.block = this.parseBlock();
	node.handler = null;
	if (this.type === types$1$1._catch) {
		var clause = this.startNode();
		this.next();
		if (this.eat(types$1$1.parenL)) clause.param = this.parseCatchClauseParam();
		else {
			if (this.options.ecmaVersion < 10) this.unexpected();
			clause.param = null;
			this.enterScope(0);
		}
		clause.body = this.parseBlock(false);
		this.exitScope();
		node.handler = this.finishNode(clause, "CatchClause");
	}
	node.finalizer = this.eat(types$1$1._finally) ? this.parseBlock() : null;
	if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
	this.next();
	this.parseVar(node, false, kind, allowMissingInitializer);
	this.semicolon();
	return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
	this.next();
	node.test = this.parseParenExpression();
	this.labels.push(loopLabel);
	node.body = this.parseStatement("while");
	this.labels.pop();
	return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
	if (this.strict) this.raise(this.start, "'with' in strict mode");
	this.next();
	node.object = this.parseParenExpression();
	node.body = this.parseStatement("with");
	return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
	this.next();
	return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
	for (var i$1 = 0, list$1 = this.labels; i$1 < list$1.length; i$1 += 1) if (list$1[i$1].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	var kind = this.type.isLoop ? "loop" : this.type === types$1$1._switch ? "switch" : null;
	for (var i$2 = this.labels.length - 1; i$2 >= 0; i$2--) {
		var label$1 = this.labels[i$2];
		if (label$1.statementStart === node.start) {
			label$1.statementStart = this.start;
			label$1.kind = kind;
		} else break;
	}
	this.labels.push({
		name: maybeName,
		kind,
		statementStart: this.start
	});
	node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
	this.labels.pop();
	node.label = expr;
	return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
	node.expression = expr;
	this.semicolon();
	return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
	if (createNewLexicalScope === void 0) createNewLexicalScope = true;
	if (node === void 0) node = this.startNode();
	node.body = [];
	this.expect(types$1$1.braceL);
	if (createNewLexicalScope) this.enterScope(0);
	while (this.type !== types$1$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	if (exitStrict) this.strict = false;
	this.next();
	if (createNewLexicalScope) this.exitScope();
	return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
	node.init = init;
	this.expect(types$1$1.semi);
	node.test = this.type === types$1$1.semi ? null : this.parseExpression();
	this.expect(types$1$1.semi);
	node.update = this.type === types$1$1.parenR ? null : this.parseExpression();
	this.expect(types$1$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
	var isForIn = this.type === types$1$1._in;
	this.next();
	if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
	node.left = init;
	node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
	this.expect(types$1$1.parenR);
	node.body = this.parseStatement("for");
	this.exitScope();
	this.labels.pop();
	return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
	node.declarations = [];
	node.kind = kind;
	for (;;) {
		var decl = this.startNode();
		this.parseVarId(decl, kind);
		if (this.eat(types$1$1.eq)) decl.init = this.parseMaybeAssign(isFor);
		else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
		else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1$1._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
		else decl.init = null;
		node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
		if (!this.eat(types$1$1.comma)) break;
	}
	return node;
};
pp$8.parseVarId = function(decl, kind) {
	decl.id = this.parseBindingAtom();
	this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync$1, forInit) {
	this.initFunction(node);
	if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync$1) {
		if (this.type === types$1$1.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
		node.generator = this.eat(types$1$1.star);
	}
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync$1;
	if (statement & FUNC_STATEMENT) {
		node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1$1.name ? null : this.parseIdent();
		if (node.id && !(statement & FUNC_HANGING_STATEMENT)) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
	}
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags(node.async, node.generator));
	if (!(statement & FUNC_STATEMENT)) node.id = this.type === types$1$1.name ? this.parseIdent() : null;
	this.parseFunctionParams(node);
	this.parseFunctionBody(node, allowExpressionBody, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
	this.expect(types$1$1.parenL);
	node.params = this.parseBindingList(types$1$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
	this.next();
	var oldStrict = this.strict;
	this.strict = true;
	this.parseClassId(node, isStatement);
	this.parseClassSuper(node);
	var privateNameMap = this.enterClassBody();
	var classBody = this.startNode();
	var hadConstructor = false;
	classBody.body = [];
	this.expect(types$1$1.braceL);
	while (this.type !== types$1$1.braceR) {
		var element = this.parseClassElement(node.superClass !== null);
		if (element) {
			classBody.body.push(element);
			if (element.type === "MethodDefinition" && element.kind === "constructor") {
				if (hadConstructor) this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
				hadConstructor = true;
			} else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
		}
	}
	this.strict = oldStrict;
	this.next();
	node.body = this.finishNode(classBody, "ClassBody");
	this.exitClassBody();
	return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
	if (this.eat(types$1$1.semi)) return null;
	var ecmaVersion$1 = this.options.ecmaVersion;
	var node = this.startNode();
	var keyName = "";
	var isGenerator = false;
	var isAsync$1 = false;
	var kind = "method";
	var isStatic = false;
	if (this.eatContextual("static")) {
		if (ecmaVersion$1 >= 13 && this.eat(types$1$1.braceL)) {
			this.parseClassStaticBlock(node);
			return node;
		}
		if (this.isClassElementNameStart() || this.type === types$1$1.star) isStatic = true;
		else keyName = "static";
	}
	node.static = isStatic;
	if (!keyName && ecmaVersion$1 >= 8 && this.eatContextual("async")) if ((this.isClassElementNameStart() || this.type === types$1$1.star) && !this.canInsertSemicolon()) isAsync$1 = true;
	else keyName = "async";
	if (!keyName && (ecmaVersion$1 >= 9 || !isAsync$1) && this.eat(types$1$1.star)) isGenerator = true;
	if (!keyName && !isAsync$1 && !isGenerator) {
		var lastValue = this.value;
		if (this.eatContextual("get") || this.eatContextual("set")) if (this.isClassElementNameStart()) kind = lastValue;
		else keyName = lastValue;
	}
	if (keyName) {
		node.computed = false;
		node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
		node.key.name = keyName;
		this.finishNode(node.key, "Identifier");
	} else this.parseClassElementName(node);
	if (ecmaVersion$1 < 13 || this.type === types$1$1.parenL || kind !== "method" || isGenerator || isAsync$1) {
		var isConstructor = !node.static && checkKeyName(node, "constructor");
		var allowsDirectSuper = isConstructor && constructorAllowsSuper;
		if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
		node.kind = isConstructor ? "constructor" : kind;
		this.parseClassMethod(node, isGenerator, isAsync$1, allowsDirectSuper);
	} else this.parseClassField(node);
	return node;
};
pp$8.isClassElementNameStart = function() {
	return this.type === types$1$1.name || this.type === types$1$1.privateId || this.type === types$1$1.num || this.type === types$1$1.string || this.type === types$1$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
	if (this.type === types$1$1.privateId) {
		if (this.value === "constructor") this.raise(this.start, "Classes can't have an element named '#constructor'");
		element.computed = false;
		element.key = this.parsePrivateIdent();
	} else this.parsePropertyName(element);
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync$1, allowsDirectSuper) {
	var key = method.key;
	if (method.kind === "constructor") {
		if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
		if (isAsync$1) this.raise(key.start, "Constructor can't be an async method");
	} else if (method.static && checkKeyName(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
	var value = method.value = this.parseMethod(isGenerator, isAsync$1, allowsDirectSuper);
	if (method.kind === "get" && value.params.length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
	if (method.kind === "set" && value.params.length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
	if (method.kind === "set" && value.params[0].type === "RestElement") this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
	return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
	if (checkKeyName(field, "constructor")) this.raise(field.key.start, "Classes can't have a field named 'constructor'");
	else if (field.static && checkKeyName(field, "prototype")) this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
	if (this.eat(types$1$1.eq)) {
		var scope = this.currentThisScope();
		var inClassFieldInit = scope.inClassFieldInit;
		scope.inClassFieldInit = true;
		field.value = this.parseMaybeAssign();
		scope.inClassFieldInit = inClassFieldInit;
	} else field.value = null;
	this.semicolon();
	return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
	node.body = [];
	var oldLabels = this.labels;
	this.labels = [];
	this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
	while (this.type !== types$1$1.braceR) {
		var stmt = this.parseStatement(null);
		node.body.push(stmt);
	}
	this.next();
	this.exitScope();
	this.labels = oldLabels;
	return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
	if (this.type === types$1$1.name) {
		node.id = this.parseIdent();
		if (isStatement) this.checkLValSimple(node.id, BIND_LEXICAL, false);
	} else {
		if (isStatement === true) this.unexpected();
		node.id = null;
	}
};
pp$8.parseClassSuper = function(node) {
	node.superClass = this.eat(types$1$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
	var element = {
		declared: Object.create(null),
		used: []
	};
	this.privateNameStack.push(element);
	return element.declared;
};
pp$8.exitClassBody = function() {
	var ref$1 = this.privateNameStack.pop();
	var declared = ref$1.declared;
	var used = ref$1.used;
	if (!this.options.checkPrivateFields) return;
	var len = this.privateNameStack.length;
	var parent = len === 0 ? null : this.privateNameStack[len - 1];
	for (var i$1 = 0; i$1 < used.length; ++i$1) {
		var id = used[i$1];
		if (!hasOwn(declared, id.name)) if (parent) parent.used.push(id);
		else this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
	}
};
function isPrivateNameConflicted(privateNameMap, element) {
	var name = element.key.name;
	var curr = privateNameMap[name];
	var next = "true";
	if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) next = (element.static ? "s" : "i") + element.kind;
	if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
		privateNameMap[name] = "true";
		return false;
	} else if (!curr) {
		privateNameMap[name] = next;
		return false;
	} else return true;
}
function checkKeyName(node, name) {
	var computed = node.computed;
	var key = node.key;
	return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
	if (this.options.ecmaVersion >= 11) if (this.eatContextual("as")) {
		node.exported = this.parseModuleExportName();
		this.checkExport(exports, node.exported, this.lastTokStart);
	} else node.exported = null;
	this.expectContextual("from");
	if (this.type !== types$1$1.string) this.unexpected();
	node.source = this.parseExprAtom();
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
	this.next();
	if (this.eat(types$1$1.star)) return this.parseExportAllDeclaration(node, exports);
	if (this.eat(types$1$1._default)) {
		this.checkExport(exports, "default", this.lastTokStart);
		node.declaration = this.parseExportDefaultDeclaration();
		return this.finishNode(node, "ExportDefaultDeclaration");
	}
	if (this.shouldParseExportStatement()) {
		node.declaration = this.parseExportDeclaration(node);
		if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports, node.declaration.declarations);
		else this.checkExport(exports, node.declaration.id, node.declaration.id.start);
		node.specifiers = [];
		node.source = null;
	} else {
		node.declaration = null;
		node.specifiers = this.parseExportSpecifiers(exports);
		if (this.eatContextual("from")) {
			if (this.type !== types$1$1.string) this.unexpected();
			node.source = this.parseExprAtom();
			if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
		} else {
			for (var i$1 = 0, list$1 = node.specifiers; i$1 < list$1.length; i$1 += 1) {
				var spec = list$1[i$1];
				this.checkUnreserved(spec.local);
				this.checkLocalExport(spec.local);
				if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
			}
			node.source = null;
		}
		this.semicolon();
	}
	return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
	return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
	var isAsync$1;
	if (this.type === types$1$1._function || (isAsync$1 = this.isAsyncFunction())) {
		var fNode = this.startNode();
		this.next();
		if (isAsync$1) this.next();
		return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync$1);
	} else if (this.type === types$1$1._class) {
		var cNode = this.startNode();
		return this.parseClass(cNode, "nullableID");
	} else {
		var declaration = this.parseMaybeAssign();
		this.semicolon();
		return declaration;
	}
};
pp$8.checkExport = function(exports, name, pos) {
	if (!exports) return;
	if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
	if (hasOwn(exports, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
	exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
	var type = pat.type;
	if (type === "Identifier") this.checkExport(exports, pat, pat.start);
	else if (type === "ObjectPattern") for (var i$1 = 0, list$1 = pat.properties; i$1 < list$1.length; i$1 += 1) {
		var prop = list$1[i$1];
		this.checkPatternExport(exports, prop);
	}
	else if (type === "ArrayPattern") for (var i$1$1 = 0, list$1$1 = pat.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
		var elt = list$1$1[i$1$1];
		if (elt) this.checkPatternExport(exports, elt);
	}
	else if (type === "Property") this.checkPatternExport(exports, pat.value);
	else if (type === "AssignmentPattern") this.checkPatternExport(exports, pat.left);
	else if (type === "RestElement") this.checkPatternExport(exports, pat.argument);
};
pp$8.checkVariableExport = function(exports, decls) {
	if (!exports) return;
	for (var i$1 = 0, list$1 = decls; i$1 < list$1.length; i$1 += 1) {
		var decl = list$1[i$1];
		this.checkPatternExport(exports, decl.id);
	}
};
pp$8.shouldParseExportStatement = function() {
	return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
	var node = this.startNode();
	node.local = this.parseModuleExportName();
	node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
	this.checkExport(exports, node.exported, node.exported.start);
	return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
	var nodes = [], first = true;
	this.expect(types$1$1.braceL);
	while (!this.eat(types$1$1.braceR)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (this.afterTrailingComma(types$1$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseExportSpecifier(exports));
	}
	return nodes;
};
pp$8.parseImport = function(node) {
	this.next();
	if (this.type === types$1$1.string) {
		node.specifiers = empty$1;
		node.source = this.parseExprAtom();
	} else {
		node.specifiers = this.parseImportSpecifiers();
		this.expectContextual("from");
		node.source = this.type === types$1$1.string ? this.parseExprAtom() : this.unexpected();
	}
	if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
	this.semicolon();
	return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
	var node = this.startNode();
	node.imported = this.parseModuleExportName();
	if (this.eatContextual("as")) node.local = this.parseIdent();
	else {
		this.checkUnreserved(node.imported);
		node.local = node.imported;
	}
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
	var node = this.startNode();
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
	var node = this.startNode();
	this.next();
	this.expectContextual("as");
	node.local = this.parseIdent();
	this.checkLValSimple(node.local, BIND_LEXICAL);
	return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
	var nodes = [], first = true;
	if (this.type === types$1$1.name) {
		nodes.push(this.parseImportDefaultSpecifier());
		if (!this.eat(types$1$1.comma)) return nodes;
	}
	if (this.type === types$1$1.star) {
		nodes.push(this.parseImportNamespaceSpecifier());
		return nodes;
	}
	this.expect(types$1$1.braceL);
	while (!this.eat(types$1$1.braceR)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (this.afterTrailingComma(types$1$1.braceR)) break;
		} else first = false;
		nodes.push(this.parseImportSpecifier());
	}
	return nodes;
};
pp$8.parseWithClause = function() {
	var nodes = [];
	if (!this.eat(types$1$1._with)) return nodes;
	this.expect(types$1$1.braceL);
	var attributeKeys = {};
	var first = true;
	while (!this.eat(types$1$1.braceR)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (this.afterTrailingComma(types$1$1.braceR)) break;
		} else first = false;
		var attr = this.parseImportAttribute();
		var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
		if (hasOwn(attributeKeys, keyName)) this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
		attributeKeys[keyName] = true;
		nodes.push(attr);
	}
	return nodes;
};
pp$8.parseImportAttribute = function() {
	var node = this.startNode();
	node.key = this.type === types$1$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
	this.expect(types$1$1.colon);
	if (this.type !== types$1$1.string) this.unexpected();
	node.value = this.parseExprAtom();
	return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
	if (this.options.ecmaVersion >= 13 && this.type === types$1$1.string) {
		var stringLiteral = this.parseLiteral(this.value);
		if (loneSurrogate.test(stringLiteral.value)) this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
		return stringLiteral;
	}
	return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
	for (var i$1 = 0; i$1 < statements.length && this.isDirectiveCandidate(statements[i$1]); ++i$1) statements[i$1].directive = statements[i$1].expression.raw.slice(1, -1);
};
pp$8.isDirectiveCandidate = function(statement) {
	return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 6 && node) switch (node.type) {
		case "Identifier":
			if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
			break;
		case "ObjectPattern":
		case "ArrayPattern":
		case "AssignmentPattern":
		case "RestElement": break;
		case "ObjectExpression":
			node.type = "ObjectPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			for (var i$1 = 0, list$1 = node.properties; i$1 < list$1.length; i$1 += 1) {
				var prop = list$1[i$1];
				this.toAssignable(prop, isBinding);
				if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
			}
			break;
		case "Property":
			if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
			this.toAssignable(node.value, isBinding);
			break;
		case "ArrayExpression":
			node.type = "ArrayPattern";
			if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
			this.toAssignableList(node.elements, isBinding);
			break;
		case "SpreadElement":
			node.type = "RestElement";
			this.toAssignable(node.argument, isBinding);
			if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
			break;
		case "AssignmentExpression":
			if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
			node.type = "AssignmentPattern";
			delete node.operator;
			this.toAssignable(node.left, isBinding);
			break;
		case "ParenthesizedExpression":
			this.toAssignable(node.expression, isBinding, refDestructuringErrors);
			break;
		case "ChainExpression":
			this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression": if (!isBinding) break;
		default: this.raise(node.start, "Assigning to rvalue");
	}
	else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
	return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
	var end = exprList.length;
	for (var i$1 = 0; i$1 < end; i$1++) {
		var elt = exprList[i$1];
		if (elt) this.toAssignable(elt, isBinding);
	}
	if (end) {
		var last = exprList[end - 1];
		if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
	}
	return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
	return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion === 6 && this.type !== types$1$1.name) this.unexpected();
	node.argument = this.parseBindingAtom();
	return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
	if (this.options.ecmaVersion >= 6) switch (this.type) {
		case types$1$1.bracketL:
			var node = this.startNode();
			this.next();
			node.elements = this.parseBindingList(types$1$1.bracketR, true, true);
			return this.finishNode(node, "ArrayPattern");
		case types$1$1.braceL: return this.parseObj(true);
	}
	return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (first) first = false;
		else this.expect(types$1$1.comma);
		if (allowEmpty && this.type === types$1$1.comma) elts.push(null);
		else if (allowTrailingComma && this.afterTrailingComma(close)) break;
		else if (this.type === types$1$1.ellipsis) {
			var rest = this.parseRestBinding();
			this.parseBindingListItem(rest);
			elts.push(rest);
			if (this.type === types$1$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			this.expect(close);
			break;
		} else elts.push(this.parseAssignableListItem(allowModifiers));
	}
	return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
	var elem = this.parseMaybeDefault(this.start, this.startLoc);
	this.parseBindingListItem(elem);
	return elem;
};
pp$7.parseBindingListItem = function(param) {
	return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
	left = left || this.parseBindingAtom();
	if (this.options.ecmaVersion < 6 || !this.eat(types$1$1.eq)) return left;
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.right = this.parseMaybeAssign();
	return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	var isBind = bindingType !== BIND_NONE;
	switch (expr.type) {
		case "Identifier":
			if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
			if (isBind) {
				if (bindingType === BIND_LEXICAL && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
				if (checkClashes) {
					if (hasOwn(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
					checkClashes[expr.name] = true;
				}
				if (bindingType !== BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);
			}
			break;
		case "ChainExpression":
			this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
			break;
		case "MemberExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding member expression");
			break;
		case "ParenthesizedExpression":
			if (isBind) this.raiseRecoverable(expr.start, "Binding parenthesized expression");
			return this.checkLValSimple(expr.expression, bindingType, checkClashes);
		default: this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
	}
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	switch (expr.type) {
		case "ObjectPattern":
			for (var i$1 = 0, list$1 = expr.properties; i$1 < list$1.length; i$1 += 1) {
				var prop = list$1[i$1];
				this.checkLValInnerPattern(prop, bindingType, checkClashes);
			}
			break;
		case "ArrayPattern":
			for (var i$1$1 = 0, list$1$1 = expr.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
				var elem = list$1$1[i$1$1];
				if (elem) this.checkLValInnerPattern(elem, bindingType, checkClashes);
			}
			break;
		default: this.checkLValSimple(expr, bindingType, checkClashes);
	}
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
	if (bindingType === void 0) bindingType = BIND_NONE;
	switch (expr.type) {
		case "Property":
			this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
			break;
		case "AssignmentPattern":
			this.checkLValPattern(expr.left, bindingType, checkClashes);
			break;
		case "RestElement":
			this.checkLValPattern(expr.argument, bindingType, checkClashes);
			break;
		default: this.checkLValPattern(expr, bindingType, checkClashes);
	}
};
var TokContext = function TokContext$1(token, isExpr, preserveSpace, override, generator) {
	this.token = token;
	this.isExpr = !!isExpr;
	this.preserveSpace = !!preserveSpace;
	this.override = override;
	this.generator = !!generator;
};
var types$2 = {
	b_stat: new TokContext("{", false),
	b_expr: new TokContext("{", true),
	b_tmpl: new TokContext("${", false),
	p_stat: new TokContext("(", false),
	p_expr: new TokContext("(", true),
	q_tmpl: new TokContext("`", true, true, function(p) {
		return p.tryReadTemplateToken();
	}),
	f_stat: new TokContext("function", false),
	f_expr: new TokContext("function", true),
	f_expr_gen: new TokContext("function", true, false, null, true),
	f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
	return [types$2.b_stat];
};
pp$6.curContext = function() {
	return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
	var parent = this.curContext();
	if (parent === types$2.f_expr || parent === types$2.f_stat) return true;
	if (prevType === types$1$1.colon && (parent === types$2.b_stat || parent === types$2.b_expr)) return !parent.isExpr;
	if (prevType === types$1$1._return || prevType === types$1$1.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	if (prevType === types$1$1._else || prevType === types$1$1.semi || prevType === types$1$1.eof || prevType === types$1$1.parenR || prevType === types$1$1.arrow) return true;
	if (prevType === types$1$1.braceL) return parent === types$2.b_stat;
	if (prevType === types$1$1._var || prevType === types$1$1._const || prevType === types$1$1.name) return false;
	return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
	for (var i$1 = this.context.length - 1; i$1 >= 1; i$1--) {
		var context = this.context[i$1];
		if (context.token === "function") return context.generator;
	}
	return false;
};
pp$6.updateContext = function(prevType) {
	var update, type = this.type;
	if (type.keyword && prevType === types$1$1.dot) this.exprAllowed = false;
	else if (update = type.updateContext) update.call(this, prevType);
	else this.exprAllowed = type.beforeExpr;
};
pp$6.overrideContext = function(tokenCtx) {
	if (this.curContext() !== tokenCtx) this.context[this.context.length - 1] = tokenCtx;
};
types$1$1.parenR.updateContext = types$1$1.braceR.updateContext = function() {
	if (this.context.length === 1) {
		this.exprAllowed = true;
		return;
	}
	var out = this.context.pop();
	if (out === types$2.b_stat && this.curContext().token === "function") out = this.context.pop();
	this.exprAllowed = !out.isExpr;
};
types$1$1.braceL.updateContext = function(prevType) {
	this.context.push(this.braceIsBlock(prevType) ? types$2.b_stat : types$2.b_expr);
	this.exprAllowed = true;
};
types$1$1.dollarBraceL.updateContext = function() {
	this.context.push(types$2.b_tmpl);
	this.exprAllowed = true;
};
types$1$1.parenL.updateContext = function(prevType) {
	var statementParens = prevType === types$1$1._if || prevType === types$1$1._for || prevType === types$1$1._with || prevType === types$1$1._while;
	this.context.push(statementParens ? types$2.p_stat : types$2.p_expr);
	this.exprAllowed = true;
};
types$1$1.incDec.updateContext = function() {};
types$1$1._function.updateContext = types$1$1._class.updateContext = function(prevType) {
	if (prevType.beforeExpr && prevType !== types$1$1._else && !(prevType === types$1$1.semi && this.curContext() !== types$2.p_stat) && !(prevType === types$1$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1$1.colon || prevType === types$1$1.braceL) && this.curContext() === types$2.b_stat)) this.context.push(types$2.f_expr);
	else this.context.push(types$2.f_stat);
	this.exprAllowed = false;
};
types$1$1.colon.updateContext = function() {
	if (this.curContext().token === "function") this.context.pop();
	this.exprAllowed = true;
};
types$1$1.backQuote.updateContext = function() {
	if (this.curContext() === types$2.q_tmpl) this.context.pop();
	else this.context.push(types$2.q_tmpl);
	this.exprAllowed = false;
};
types$1$1.star.updateContext = function(prevType) {
	if (prevType === types$1$1._function) {
		var index = this.context.length - 1;
		if (this.context[index] === types$2.f_expr) this.context[index] = types$2.f_expr_gen;
		else this.context[index] = types$2.f_gen;
	}
	this.exprAllowed = true;
};
types$1$1.name.updateContext = function(prevType) {
	var allowed = false;
	if (this.options.ecmaVersion >= 6 && prevType !== types$1$1.dot) {
		if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
	}
	this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
	if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
	if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
	var key = prop.key;
	var name;
	switch (key.type) {
		case "Identifier":
			name = key.name;
			break;
		case "Literal":
			name = String(key.value);
			break;
		default: return;
	}
	var kind = prop.kind;
	if (this.options.ecmaVersion >= 6) {
		if (name === "__proto__" && kind === "init") {
			if (propHash.proto) if (refDestructuringErrors) {
				if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
			} else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
			propHash.proto = true;
		}
		return;
	}
	name = "$" + name;
	var other = propHash[name];
	if (other) {
		var redefinition;
		if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
		else redefinition = other.init || other[kind];
		if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
	} else other = propHash[name] = {
		init: false,
		get: false,
		set: false
	};
	other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
	if (this.type === types$1$1.comma) {
		var node = this.startNodeAt(startPos, startLoc);
		node.expressions = [expr];
		while (this.eat(types$1$1.comma)) node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
		return this.finishNode(node, "SequenceExpression");
	}
	return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
	if (this.isContextual("yield")) if (this.inGenerator) return this.parseYield(forInit);
	else this.exprAllowed = false;
	var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
	if (refDestructuringErrors) {
		oldParenAssign = refDestructuringErrors.parenthesizedAssign;
		oldTrailingComma = refDestructuringErrors.trailingComma;
		oldDoubleProto = refDestructuringErrors.doubleProto;
		refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
	} else {
		refDestructuringErrors = new DestructuringErrors();
		ownDestructuringErrors = true;
	}
	var startPos = this.start, startLoc = this.startLoc;
	if (this.type === types$1$1.parenL || this.type === types$1$1.name) {
		this.potentialArrowAt = this.start;
		this.potentialArrowInForAwait = forInit === "await";
	}
	var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
	if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
	if (this.type.isAssign) {
		var node = this.startNodeAt(startPos, startLoc);
		node.operator = this.value;
		if (this.type === types$1$1.eq) left = this.toAssignable(left, false, refDestructuringErrors);
		if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
		if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
		if (this.type === types$1$1.eq) this.checkLValPattern(left);
		else this.checkLValSimple(left);
		node.left = left;
		this.next();
		node.right = this.parseMaybeAssign(forInit);
		if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
		return this.finishNode(node, "AssignmentExpression");
	} else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
	if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
	if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
	return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprOps(forInit, refDestructuringErrors);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	if (this.eat(types$1$1.question)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.test = expr;
		node.consequent = this.parseMaybeAssign();
		this.expect(types$1$1.colon);
		node.alternate = this.parseMaybeAssign(forInit);
		return this.finishNode(node, "ConditionalExpression");
	}
	return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
	if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
	var prec = this.type.binop;
	if (prec != null && (!forInit || this.type !== types$1$1._in)) {
		if (prec > minPrec) {
			var logical = this.type === types$1$1.logicalOR || this.type === types$1$1.logicalAND;
			var coalesce = this.type === types$1$1.coalesce;
			if (coalesce) prec = types$1$1.logicalAND.binop;
			var op = this.value;
			this.next();
			var startPos = this.start, startLoc = this.startLoc;
			var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
			var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
			if (logical && this.type === types$1$1.coalesce || coalesce && (this.type === types$1$1.logicalOR || this.type === types$1$1.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
			return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
		}
	}
	return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	if (right.type === "PrivateIdentifier") this.raise(right.start, "Private identifier can only be left side of binary expression");
	var node = this.startNodeAt(startPos, startLoc);
	node.left = left;
	node.operator = op;
	node.right = right;
	return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
	var startPos = this.start, startLoc = this.startLoc, expr;
	if (this.isContextual("await") && this.canAwait) {
		expr = this.parseAwait(forInit);
		sawUnary = true;
	} else if (this.type.prefix) {
		var node = this.startNode(), update = this.type === types$1$1.incDec;
		node.operator = this.value;
		node.prefix = true;
		this.next();
		node.argument = this.parseMaybeUnary(null, true, update, forInit);
		this.checkExpressionErrors(refDestructuringErrors, true);
		if (update) this.checkLValSimple(node.argument);
		else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
		else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) this.raiseRecoverable(node.start, "Private fields can not be deleted");
		else sawUnary = true;
		expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	} else if (!sawUnary && this.type === types$1$1.privateId) {
		if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) this.unexpected();
		expr = this.parsePrivateIdent();
		if (this.type !== types$1$1._in) this.unexpected();
	} else {
		expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
		if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
		while (this.type.postfix && !this.canInsertSemicolon()) {
			var node$1 = this.startNodeAt(startPos, startLoc);
			node$1.operator = this.value;
			node$1.prefix = false;
			node$1.argument = expr;
			this.checkLValSimple(expr);
			this.next();
			expr = this.finishNode(node$1, "UpdateExpression");
		}
	}
	if (!incDec && this.eat(types$1$1.starstar)) if (sawUnary) this.unexpected(this.lastTokStart);
	else return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
	else return expr;
};
function isLocalVariableAccess(node) {
	return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
	return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
	var startPos = this.start, startLoc = this.startLoc;
	var expr = this.parseExprAtom(refDestructuringErrors, forInit);
	if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
	var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
	if (refDestructuringErrors && result.type === "MemberExpression") {
		if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
		if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
		if (refDestructuringErrors.trailingComma >= result.start) refDestructuringErrors.trailingComma = -1;
	}
	return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
	var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
	var optionalChained = false;
	while (true) {
		var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
		if (element.optional) optionalChained = true;
		if (element === base || element.type === "ArrowFunctionExpression") {
			if (optionalChained) {
				var chainNode = this.startNodeAt(startPos, startLoc);
				chainNode.expression = element;
				element = this.finishNode(chainNode, "ChainExpression");
			}
			return element;
		}
		base = element;
	}
};
pp$5.shouldParseAsyncArrow = function() {
	return !this.canInsertSemicolon() && this.eat(types$1$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
	var optionalSupported = this.options.ecmaVersion >= 11;
	var optional = optionalSupported && this.eat(types$1$1.questionDot);
	if (noCalls && optional) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
	var computed = this.eat(types$1$1.bracketL);
	if (computed || optional && this.type !== types$1$1.parenL && this.type !== types$1$1.backQuote || this.eat(types$1$1.dot)) {
		var node = this.startNodeAt(startPos, startLoc);
		node.object = base;
		if (computed) {
			node.property = this.parseExpression();
			this.expect(types$1$1.bracketR);
		} else if (this.type === types$1$1.privateId && base.type !== "Super") node.property = this.parsePrivateIdent();
		else node.property = this.parseIdent(this.options.allowReserved !== "never");
		node.computed = !!computed;
		if (optionalSupported) node.optional = optional;
		base = this.finishNode(node, "MemberExpression");
	} else if (!noCalls && this.eat(types$1$1.parenL)) {
		var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		this.yieldPos = 0;
		this.awaitPos = 0;
		this.awaitIdentPos = 0;
		var exprList = this.parseExprList(types$1$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
		if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			this.awaitIdentPos = oldAwaitIdentPos;
			return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
		}
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
		var node$1 = this.startNodeAt(startPos, startLoc);
		node$1.callee = base;
		node$1.arguments = exprList;
		if (optionalSupported) node$1.optional = optional;
		base = this.finishNode(node$1, "CallExpression");
	} else if (this.type === types$1$1.backQuote) {
		if (optional || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
		var node$2 = this.startNodeAt(startPos, startLoc);
		node$2.tag = base;
		node$2.quasi = this.parseTemplate({ isTagged: true });
		base = this.finishNode(node$2, "TaggedTemplateExpression");
	}
	return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
	if (this.type === types$1$1.slash) this.readRegexp();
	var node, canBeArrow = this.potentialArrowAt === this.start;
	switch (this.type) {
		case types$1$1._super:
			if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
			node = this.startNode();
			this.next();
			if (this.type === types$1$1.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
			if (this.type !== types$1$1.dot && this.type !== types$1$1.bracketL && this.type !== types$1$1.parenL) this.unexpected();
			return this.finishNode(node, "Super");
		case types$1$1._this:
			node = this.startNode();
			this.next();
			return this.finishNode(node, "ThisExpression");
		case types$1$1.name:
			var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
			var id = this.parseIdent(false);
			if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1$1._function)) {
				this.overrideContext(types$2.f_expr);
				return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
			}
			if (canBeArrow && !this.canInsertSemicolon()) {
				if (this.eat(types$1$1.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
				if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
					id = this.parseIdent(false);
					if (this.canInsertSemicolon() || !this.eat(types$1$1.arrow)) this.unexpected();
					return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
				}
			}
			return id;
		case types$1$1.regexp:
			var value = this.value;
			node = this.parseLiteral(value.value);
			node.regex = {
				pattern: value.pattern,
				flags: value.flags
			};
			return node;
		case types$1$1.num:
		case types$1$1.string: return this.parseLiteral(this.value);
		case types$1$1._null:
		case types$1$1._true:
		case types$1$1._false:
			node = this.startNode();
			node.value = this.type === types$1$1._null ? null : this.type === types$1$1._true;
			node.raw = this.type.keyword;
			this.next();
			return this.finishNode(node, "Literal");
		case types$1$1.parenL:
			var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
			if (refDestructuringErrors) {
				if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
				if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
			}
			return expr;
		case types$1$1.bracketL:
			node = this.startNode();
			this.next();
			node.elements = this.parseExprList(types$1$1.bracketR, true, true, refDestructuringErrors);
			return this.finishNode(node, "ArrayExpression");
		case types$1$1.braceL:
			this.overrideContext(types$2.b_expr);
			return this.parseObj(false, refDestructuringErrors);
		case types$1$1._function:
			node = this.startNode();
			this.next();
			return this.parseFunction(node, 0);
		case types$1$1._class: return this.parseClass(this.startNode(), false);
		case types$1$1._new: return this.parseNew();
		case types$1$1.backQuote: return this.parseTemplate();
		case types$1$1._import: if (this.options.ecmaVersion >= 11) return this.parseExprImport(forNew);
		else return this.unexpected();
		default: return this.parseExprAtomDefault();
	}
};
pp$5.parseExprAtomDefault = function() {
	this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
	var node = this.startNode();
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
	this.next();
	if (this.type === types$1$1.parenL && !forNew) return this.parseDynamicImport(node);
	else if (this.type === types$1$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "import";
		node.meta = this.finishNode(meta, "Identifier");
		return this.parseImportMeta(node);
	} else this.unexpected();
};
pp$5.parseDynamicImport = function(node) {
	this.next();
	node.source = this.parseMaybeAssign();
	if (this.options.ecmaVersion >= 16) if (!this.eat(types$1$1.parenR)) {
		this.expect(types$1$1.comma);
		if (!this.afterTrailingComma(types$1$1.parenR)) {
			node.options = this.parseMaybeAssign();
			if (!this.eat(types$1$1.parenR)) {
				this.expect(types$1$1.comma);
				if (!this.afterTrailingComma(types$1$1.parenR)) this.unexpected();
			}
		} else node.options = null;
	} else node.options = null;
	else if (!this.eat(types$1$1.parenR)) {
		var errorPos = this.start;
		if (this.eat(types$1$1.comma) && this.eat(types$1$1.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
		else this.unexpected(errorPos);
	}
	return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
	this.next();
	var containsEsc = this.containsEsc;
	node.property = this.parseIdent(true);
	if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
	if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
	if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
	return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
	var node = this.startNode();
	node.value = value;
	node.raw = this.input.slice(this.start, this.end);
	if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
	this.next();
	return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
	this.expect(types$1$1.parenL);
	var val = this.parseExpression();
	this.expect(types$1$1.parenR);
	return val;
};
pp$5.shouldParseArrow = function(exprList) {
	return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
	var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
	if (this.options.ecmaVersion >= 6) {
		this.next();
		var innerStartPos = this.start, innerStartLoc = this.startLoc;
		var exprList = [], first = true, lastIsComma = false;
		var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
		this.yieldPos = 0;
		this.awaitPos = 0;
		while (this.type !== types$1$1.parenR) {
			first ? first = false : this.expect(types$1$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(types$1$1.parenR, true)) {
				lastIsComma = true;
				break;
			} else if (this.type === types$1$1.ellipsis) {
				spreadStart = this.start;
				exprList.push(this.parseParenItem(this.parseRestBinding()));
				if (this.type === types$1$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
				break;
			} else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
		}
		var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
		this.expect(types$1$1.parenR);
		if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1$1.arrow)) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
		}
		if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
		if (spreadStart) this.unexpected(spreadStart);
		this.checkExpressionErrors(refDestructuringErrors, true);
		this.yieldPos = oldYieldPos || this.yieldPos;
		this.awaitPos = oldAwaitPos || this.awaitPos;
		if (exprList.length > 1) {
			val = this.startNodeAt(innerStartPos, innerStartLoc);
			val.expressions = exprList;
			this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
		} else val = exprList[0];
	} else val = this.parseParenExpression();
	if (this.options.preserveParens) {
		var par = this.startNodeAt(startPos, startLoc);
		par.expression = val;
		return this.finishNode(par, "ParenthesizedExpression");
	} else return val;
};
pp$5.parseParenItem = function(item) {
	return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
	return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
	if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
	var node = this.startNode();
	this.next();
	if (this.options.ecmaVersion >= 6 && this.type === types$1$1.dot) {
		var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
		meta.name = "new";
		node.meta = this.finishNode(meta, "Identifier");
		this.next();
		var containsEsc = this.containsEsc;
		node.property = this.parseIdent(true);
		if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
		if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
		if (!this.allowNewDotTarget) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
		return this.finishNode(node, "MetaProperty");
	}
	var startPos = this.start, startLoc = this.startLoc;
	node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
	if (this.eat(types$1$1.parenL)) node.arguments = this.parseExprList(types$1$1.parenR, this.options.ecmaVersion >= 8, false);
	else node.arguments = empty;
	return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref$1) {
	var isTagged = ref$1.isTagged;
	var elem = this.startNode();
	if (this.type === types$1$1.invalidTemplate) {
		if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
		elem.value = {
			raw: this.value.replace(/\r\n?/g, "\n"),
			cooked: null
		};
	} else elem.value = {
		raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
		cooked: this.value
	};
	this.next();
	elem.tail = this.type === types$1$1.backQuote;
	return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref$1) {
	if (ref$1 === void 0) ref$1 = {};
	var isTagged = ref$1.isTagged;
	if (isTagged === void 0) isTagged = false;
	var node = this.startNode();
	this.next();
	node.expressions = [];
	var curElt = this.parseTemplateElement({ isTagged });
	node.quasis = [curElt];
	while (!curElt.tail) {
		if (this.type === types$1$1.eof) this.raise(this.pos, "Unterminated template literal");
		this.expect(types$1$1.dollarBraceL);
		node.expressions.push(this.parseExpression());
		this.expect(types$1$1.braceR);
		node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
	}
	this.next();
	return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
	return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1$1.name || this.type === types$1$1.num || this.type === types$1$1.string || this.type === types$1$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
	var node = this.startNode(), first = true, propHash = {};
	node.properties = [];
	this.next();
	while (!this.eat(types$1$1.braceR)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1$1.braceR)) break;
		} else first = false;
		var prop = this.parseProperty(isPattern, refDestructuringErrors);
		if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
		node.properties.push(prop);
	}
	return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
	var prop = this.startNode(), isGenerator, isAsync$1, startPos, startLoc;
	if (this.options.ecmaVersion >= 9 && this.eat(types$1$1.ellipsis)) {
		if (isPattern) {
			prop.argument = this.parseIdent(false);
			if (this.type === types$1$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
			return this.finishNode(prop, "RestElement");
		}
		prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		if (this.type === types$1$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		return this.finishNode(prop, "SpreadElement");
	}
	if (this.options.ecmaVersion >= 6) {
		prop.method = false;
		prop.shorthand = false;
		if (isPattern || refDestructuringErrors) {
			startPos = this.start;
			startLoc = this.startLoc;
		}
		if (!isPattern) isGenerator = this.eat(types$1$1.star);
	}
	var containsEsc = this.containsEsc;
	this.parsePropertyName(prop);
	if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
		isAsync$1 = true;
		isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1$1.star);
		this.parsePropertyName(prop);
	} else isAsync$1 = false;
	this.parsePropertyValue(prop, isPattern, isGenerator, isAsync$1, startPos, startLoc, refDestructuringErrors, containsEsc);
	return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
	prop.kind = prop.key.name;
	this.parsePropertyName(prop);
	prop.value = this.parseMethod(false);
	var paramCount = prop.kind === "get" ? 0 : 1;
	if (prop.value.params.length !== paramCount) {
		var start = prop.value.start;
		if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
		else this.raiseRecoverable(start, "setter should have exactly one param");
	} else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync$1, startPos, startLoc, refDestructuringErrors, containsEsc) {
	if ((isGenerator || isAsync$1) && this.type === types$1$1.colon) this.unexpected();
	if (this.eat(types$1$1.colon)) {
		prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
		prop.kind = "init";
	} else if (this.options.ecmaVersion >= 6 && this.type === types$1$1.parenL) {
		if (isPattern) this.unexpected();
		prop.kind = "init";
		prop.method = true;
		prop.value = this.parseMethod(isGenerator, isAsync$1);
	} else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1$1.comma && this.type !== types$1$1.braceR && this.type !== types$1$1.eq) {
		if (isGenerator || isAsync$1) this.unexpected();
		this.parseGetterSetter(prop);
	} else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
		if (isGenerator || isAsync$1) this.unexpected();
		this.checkUnreserved(prop.key);
		if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
		prop.kind = "init";
		if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		else if (this.type === types$1$1.eq && refDestructuringErrors) {
			if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
			prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
		} else prop.value = this.copyNode(prop.key);
		prop.shorthand = true;
	} else this.unexpected();
};
pp$5.parsePropertyName = function(prop) {
	if (this.options.ecmaVersion >= 6) if (this.eat(types$1$1.bracketL)) {
		prop.computed = true;
		prop.key = this.parseMaybeAssign();
		this.expect(types$1$1.bracketR);
		return prop.key;
	} else prop.computed = false;
	return prop.key = this.type === types$1$1.num || this.type === types$1$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
	node.id = null;
	if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
	if (this.options.ecmaVersion >= 8) node.async = false;
};
pp$5.parseMethod = function(isGenerator, isAsync$1, allowDirectSuper) {
	var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.initFunction(node);
	if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync$1;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	this.enterScope(functionFlags(isAsync$1, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
	this.expect(types$1$1.parenL);
	node.params = this.parseBindingList(types$1$1.parenR, false, this.options.ecmaVersion >= 8);
	this.checkYieldAwaitInDefaultParams();
	this.parseFunctionBody(node, false, true, false);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync$1, forInit) {
	var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
	this.enterScope(functionFlags(isAsync$1, false) | SCOPE_ARROW);
	this.initFunction(node);
	if (this.options.ecmaVersion >= 8) node.async = !!isAsync$1;
	this.yieldPos = 0;
	this.awaitPos = 0;
	this.awaitIdentPos = 0;
	node.params = this.toAssignableList(params, true);
	this.parseFunctionBody(node, true, false, forInit);
	this.yieldPos = oldYieldPos;
	this.awaitPos = oldAwaitPos;
	this.awaitIdentPos = oldAwaitIdentPos;
	return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
	var isExpression = isArrowFunction && this.type !== types$1$1.braceL;
	var oldStrict = this.strict, useStrict = false;
	if (isExpression) {
		node.body = this.parseMaybeAssign(forInit);
		node.expression = true;
		this.checkParams(node, false);
	} else {
		var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
		if (!oldStrict || nonSimple) {
			useStrict = this.strictDirective(this.end);
			if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
		}
		var oldLabels = this.labels;
		this.labels = [];
		if (useStrict) this.strict = true;
		this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
		if (this.strict && node.id) this.checkLValSimple(node.id, BIND_OUTSIDE);
		node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
		node.expression = false;
		this.adaptDirectivePrologue(node.body.body);
		this.labels = oldLabels;
	}
	this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
	for (var i$1 = 0, list$1 = params; i$1 < list$1.length; i$1 += 1) if (list$1[i$1].type !== "Identifier") return false;
	return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
	var nameHash = Object.create(null);
	for (var i$1 = 0, list$1 = node.params; i$1 < list$1.length; i$1 += 1) {
		var param = list$1[i$1];
		this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
	}
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	var elts = [], first = true;
	while (!this.eat(close)) {
		if (!first) {
			this.expect(types$1$1.comma);
			if (allowTrailingComma && this.afterTrailingComma(close)) break;
		} else first = false;
		var elt = void 0;
		if (allowEmpty && this.type === types$1$1.comma) elt = null;
		else if (this.type === types$1$1.ellipsis) {
			elt = this.parseSpread(refDestructuringErrors);
			if (refDestructuringErrors && this.type === types$1$1.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
		} else elt = this.parseMaybeAssign(false, refDestructuringErrors);
		elts.push(elt);
	}
	return elts;
};
pp$5.checkUnreserved = function(ref$1) {
	var start = ref$1.start;
	var end = ref$1.end;
	var name = ref$1.name;
	if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
	if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
	if (this.currentThisScope().inClassFieldInit && name === "arguments") this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
	if (this.inClassStaticBlock && (name === "arguments" || name === "await")) this.raise(start, "Cannot use " + name + " in class static initialization block");
	if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
	if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
	if ((this.strict ? this.reservedWordsStrict : this.reservedWords).test(name)) {
		if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
		this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
	}
};
pp$5.parseIdent = function(liberal) {
	var node = this.parseIdentNode();
	this.next(!!liberal);
	this.finishNode(node, "Identifier");
	if (!liberal) {
		this.checkUnreserved(node);
		if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
	}
	return node;
};
pp$5.parseIdentNode = function() {
	var node = this.startNode();
	if (this.type === types$1$1.name) node.name = this.value;
	else if (this.type.keyword) {
		node.name = this.type.keyword;
		if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
		this.type = types$1$1.name;
	} else this.unexpected();
	return node;
};
pp$5.parsePrivateIdent = function() {
	var node = this.startNode();
	if (this.type === types$1$1.privateId) node.name = this.value;
	else this.unexpected();
	this.next();
	this.finishNode(node, "PrivateIdentifier");
	if (this.options.checkPrivateFields) if (this.privateNameStack.length === 0) this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
	else this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
	return node;
};
pp$5.parseYield = function(forInit) {
	if (!this.yieldPos) this.yieldPos = this.start;
	var node = this.startNode();
	this.next();
	if (this.type === types$1$1.semi || this.canInsertSemicolon() || this.type !== types$1$1.star && !this.type.startsExpr) {
		node.delegate = false;
		node.argument = null;
	} else {
		node.delegate = this.eat(types$1$1.star);
		node.argument = this.parseMaybeAssign(forInit);
	}
	return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
	if (!this.awaitPos) this.awaitPos = this.start;
	var node = this.startNode();
	this.next();
	node.argument = this.parseMaybeUnary(null, true, false, forInit);
	return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
	var loc = getLineInfo(this.input, pos);
	message += " (" + loc.line + ":" + loc.column + ")";
	var err = new SyntaxError(message);
	err.pos = pos;
	err.loc = loc;
	err.raisedAt = this.pos;
	throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
	if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
};
var pp$3 = Parser.prototype;
var Scope = function Scope$1(flags) {
	this.flags = flags;
	this.var = [];
	this.lexical = [];
	this.functions = [];
	this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
	this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
	this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
	return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
	var redeclared = false;
	if (bindingType === BIND_LEXICAL) {
		var scope = this.currentScope();
		redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
		scope.lexical.push(name);
		if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
	} else if (bindingType === BIND_SIMPLE_CATCH) this.currentScope().lexical.push(name);
	else if (bindingType === BIND_FUNCTION) {
		var scope$2 = this.currentScope();
		if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
		else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
		scope$2.functions.push(name);
	} else for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; --i$1) {
		var scope$3 = this.scopeStack[i$1];
		if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
			redeclared = true;
			break;
		}
		scope$3.var.push(name);
		if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
		if (scope$3.flags & SCOPE_VAR) break;
	}
	if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
};
pp$3.checkLocalExport = function(id) {
	if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
};
pp$3.currentScope = function() {
	return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
	for (var i$1 = this.scopeStack.length - 1;; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.flags & SCOPE_VAR) return scope;
	}
};
pp$3.currentThisScope = function() {
	for (var i$1 = this.scopeStack.length - 1;; i$1--) {
		var scope = this.scopeStack[i$1];
		if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) return scope;
	}
};
var Node = function Node$1(parser, pos, loc) {
	this.type = "";
	this.start = pos;
	this.end = 0;
	if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
	if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
	if (parser.options.ranges) this.range = [pos, 0];
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
	return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
	return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
	node.type = type;
	node.end = pos;
	if (this.options.locations) node.loc.end = loc;
	if (this.options.ranges) node.range[1] = pos;
	return node;
}
pp$2.finishNode = function(node, type) {
	return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type, pos, loc) {
	return finishNodeAt.call(this, node, type, pos, loc);
};
pp$2.copyNode = function(node) {
	var newNode = new Node(this, node.start, this.startLoc);
	for (var prop in node) newNode[prop] = node[prop];
	return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
	9: ecma9BinaryProperties,
	10: ecma10BinaryProperties,
	11: ecma11BinaryProperties,
	12: ecma12BinaryProperties,
	13: ecma13BinaryProperties,
	14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
	9: "",
	10: "",
	11: "",
	12: "",
	13: "",
	14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
	9: ecma9ScriptValues,
	10: ecma10ScriptValues,
	11: ecma11ScriptValues,
	12: ecma12ScriptValues,
	13: ecma13ScriptValues,
	14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion$1) {
	var d = data[ecmaVersion$1] = {
		binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion$1] + " " + unicodeGeneralCategoryValues),
		binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion$1]),
		nonBinary: {
			General_Category: wordsRegexp(unicodeGeneralCategoryValues),
			Script: wordsRegexp(unicodeScriptValues[ecmaVersion$1])
		}
	};
	d.nonBinary.Script_Extensions = d.nonBinary.Script;
	d.nonBinary.gc = d.nonBinary.General_Category;
	d.nonBinary.sc = d.nonBinary.Script;
	d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (var i = 0, list = [
	9,
	10,
	11,
	12,
	13,
	14
]; i < list.length; i += 1) {
	var ecmaVersion = list[i];
	buildUnicodeData(ecmaVersion);
}
var pp$1 = Parser.prototype;
var BranchID = function BranchID$1(parent, base) {
	this.parent = parent;
	this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
	for (var self = this; self; self = self.parent) for (var other = alt; other; other = other.parent) if (self.base === other.base && self !== other) return true;
	return false;
};
BranchID.prototype.sibling = function sibling() {
	return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState$1(parser) {
	this.parser = parser;
	this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
	this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
	this.source = "";
	this.flags = "";
	this.start = 0;
	this.switchU = false;
	this.switchV = false;
	this.switchN = false;
	this.pos = 0;
	this.lastIntValue = 0;
	this.lastStringValue = "";
	this.lastAssertionIsQuantifiable = false;
	this.numCapturingParens = 0;
	this.maxBackReference = 0;
	this.groupNames = Object.create(null);
	this.backReferenceNames = [];
	this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
	var unicodeSets = flags.indexOf("v") !== -1;
	var unicode = flags.indexOf("u") !== -1;
	this.start = start | 0;
	this.source = pattern + "";
	this.flags = flags;
	if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
		this.switchU = true;
		this.switchV = true;
		this.switchN = true;
	} else {
		this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
		this.switchV = false;
		this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
	}
};
RegExpValidationState.prototype.raise = function raise(message) {
	this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i$1, forceU) {
	if (forceU === void 0) forceU = false;
	var s = this.source;
	var l = s.length;
	if (i$1 >= l) return -1;
	var c = s.charCodeAt(i$1);
	if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i$1 + 1 >= l) return c;
	var next = s.charCodeAt(i$1 + 1);
	return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i$1, forceU) {
	if (forceU === void 0) forceU = false;
	var s = this.source;
	var l = s.length;
	if (i$1 >= l) return l;
	var c = s.charCodeAt(i$1), next;
	if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i$1 + 1 >= l || (next = s.charCodeAt(i$1 + 1)) < 56320 || next > 57343) return i$1 + 1;
	return i$1 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
	if (forceU === void 0) forceU = false;
	return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
	if (forceU === void 0) forceU = false;
	this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
	if (forceU === void 0) forceU = false;
	if (this.current(forceU) === ch) {
		this.advance(forceU);
		return true;
	}
	return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
	if (forceU === void 0) forceU = false;
	var pos = this.pos;
	for (var i$1 = 0, list$1 = chs; i$1 < list$1.length; i$1 += 1) {
		var ch = list$1[i$1];
		var current = this.at(pos, forceU);
		if (current === -1 || current !== ch) return false;
		pos = this.nextIndex(pos, forceU);
	}
	this.pos = pos;
	return true;
};
/**
* Validate the flags part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpFlags = function(state) {
	var validFlags = state.validFlags;
	var flags = state.flags;
	var u = false;
	var v = false;
	for (var i$1 = 0; i$1 < flags.length; i$1++) {
		var flag = flags.charAt(i$1);
		if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
		if (flags.indexOf(flag, i$1 + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
		if (flag === "u") u = true;
		if (flag === "v") v = true;
	}
	if (this.options.ecmaVersion >= 15 && u && v) this.raise(state.start, "Invalid regular expression flag");
};
function hasProp(obj) {
	for (var _ in obj) return true;
	return false;
}
/**
* Validate the pattern part of a given RegExpLiteral.
*
* @param {RegExpValidationState} state The state to validate RegExp.
* @returns {void}
*/
pp$1.validateRegExpPattern = function(state) {
	this.regexp_pattern(state);
	if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
		state.switchN = true;
		this.regexp_pattern(state);
	}
};
pp$1.regexp_pattern = function(state) {
	state.pos = 0;
	state.lastIntValue = 0;
	state.lastStringValue = "";
	state.lastAssertionIsQuantifiable = false;
	state.numCapturingParens = 0;
	state.maxBackReference = 0;
	state.groupNames = Object.create(null);
	state.backReferenceNames.length = 0;
	state.branchID = null;
	this.regexp_disjunction(state);
	if (state.pos !== state.source.length) {
		if (state.eat(41)) state.raise("Unmatched ')'");
		if (state.eat(93) || state.eat(125)) state.raise("Lone quantifier brackets");
	}
	if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
	for (var i$1 = 0, list$1 = state.backReferenceNames; i$1 < list$1.length; i$1 += 1) {
		var name = list$1[i$1];
		if (!state.groupNames[name]) state.raise("Invalid named capture referenced");
	}
};
pp$1.regexp_disjunction = function(state) {
	var trackDisjunction = this.options.ecmaVersion >= 16;
	if (trackDisjunction) state.branchID = new BranchID(state.branchID, null);
	this.regexp_alternative(state);
	while (state.eat(124)) {
		if (trackDisjunction) state.branchID = state.branchID.sibling();
		this.regexp_alternative(state);
	}
	if (trackDisjunction) state.branchID = state.branchID.parent;
	if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
	if (state.eat(123)) state.raise("Lone quantifier brackets");
};
pp$1.regexp_alternative = function(state) {
	while (state.pos < state.source.length && this.regexp_eatTerm(state));
};
pp$1.regexp_eatTerm = function(state) {
	if (this.regexp_eatAssertion(state)) {
		if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
			if (state.switchU) state.raise("Invalid quantifier");
		}
		return true;
	}
	if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
		this.regexp_eatQuantifier(state);
		return true;
	}
	return false;
};
pp$1.regexp_eatAssertion = function(state) {
	var start = state.pos;
	state.lastAssertionIsQuantifiable = false;
	if (state.eat(94) || state.eat(36)) return true;
	if (state.eat(92)) {
		if (state.eat(66) || state.eat(98)) return true;
		state.pos = start;
	}
	if (state.eat(40) && state.eat(63)) {
		var lookbehind = false;
		if (this.options.ecmaVersion >= 9) lookbehind = state.eat(60);
		if (state.eat(61) || state.eat(33)) {
			this.regexp_disjunction(state);
			if (!state.eat(41)) state.raise("Unterminated group");
			state.lastAssertionIsQuantifiable = !lookbehind;
			return true;
		}
	}
	state.pos = start;
	return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
	if (noError === void 0) noError = false;
	if (this.regexp_eatQuantifierPrefix(state, noError)) {
		state.eat(63);
		return true;
	}
	return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
	return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
	var start = state.pos;
	if (state.eat(123)) {
		var min = 0, max = -1;
		if (this.regexp_eatDecimalDigits(state)) {
			min = state.lastIntValue;
			if (state.eat(44) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
			if (state.eat(125)) {
				if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
				return true;
			}
		}
		if (state.switchU && !noError) state.raise("Incomplete quantifier");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatAtom = function(state) {
	return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatAtomEscape(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
	var start = state.pos;
	if (state.eat(40)) {
		if (state.eat(63)) {
			if (this.options.ecmaVersion >= 16) {
				var addModifiers = this.regexp_eatModifiers(state);
				var hasHyphen = state.eat(45);
				if (addModifiers || hasHyphen) {
					for (var i$1 = 0; i$1 < addModifiers.length; i$1++) {
						var modifier = addModifiers.charAt(i$1);
						if (addModifiers.indexOf(modifier, i$1 + 1) > -1) state.raise("Duplicate regular expression modifiers");
					}
					if (hasHyphen) {
						var removeModifiers = this.regexp_eatModifiers(state);
						if (!addModifiers && !removeModifiers && state.current() === 58) state.raise("Invalid regular expression modifiers");
						for (var i$1$1 = 0; i$1$1 < removeModifiers.length; i$1$1++) {
							var modifier$1 = removeModifiers.charAt(i$1$1);
							if (removeModifiers.indexOf(modifier$1, i$1$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) state.raise("Duplicate regular expression modifiers");
						}
					}
				}
			}
			if (state.eat(58)) {
				this.regexp_disjunction(state);
				if (state.eat(41)) return true;
				state.raise("Unterminated group");
			}
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
	if (state.eat(40)) {
		if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
		else if (state.current() === 63) state.raise("Invalid group");
		this.regexp_disjunction(state);
		if (state.eat(41)) {
			state.numCapturingParens += 1;
			return true;
		}
		state.raise("Unterminated group");
	}
	return false;
};
pp$1.regexp_eatModifiers = function(state) {
	var modifiers = "";
	var ch = 0;
	while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
		modifiers += codePointToString(ch);
		state.advance();
	}
	return modifiers;
};
function isRegularExpressionModifier(ch) {
	return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
	return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
	if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
	return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
	var ch = state.current();
	if (isSyntaxCharacter(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isSyntaxCharacter(ch) {
	return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
	var start = state.pos;
	var ch = 0;
	while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) state.advance();
	return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
	var ch = state.current();
	if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_groupSpecifier = function(state) {
	if (state.eat(63)) {
		if (!this.regexp_eatGroupName(state)) state.raise("Invalid group");
		var trackDisjunction = this.options.ecmaVersion >= 16;
		var known = state.groupNames[state.lastStringValue];
		if (known) if (trackDisjunction) {
			for (var i$1 = 0, list$1 = known; i$1 < list$1.length; i$1 += 1) if (!list$1[i$1].separatedFrom(state.branchID)) state.raise("Duplicate capture group name");
		} else state.raise("Duplicate capture group name");
		if (trackDisjunction) (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
		else state.groupNames[state.lastStringValue] = true;
	}
};
pp$1.regexp_eatGroupName = function(state) {
	state.lastStringValue = "";
	if (state.eat(60)) {
		if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) return true;
		state.raise("Invalid capture group name");
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
	state.lastStringValue = "";
	if (this.regexp_eatRegExpIdentifierStart(state)) {
		state.lastStringValue += codePointToString(state.lastIntValue);
		while (this.regexp_eatRegExpIdentifierPart(state)) state.lastStringValue += codePointToString(state.lastIntValue);
		return true;
	}
	return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierStart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierStart(ch) {
	return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
	var start = state.pos;
	var forceU = this.options.ecmaVersion >= 11;
	var ch = state.current(forceU);
	state.advance(forceU);
	if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
	if (isRegExpIdentifierPart(ch)) {
		state.lastIntValue = ch;
		return true;
	}
	state.pos = start;
	return false;
};
function isRegExpIdentifierPart(ch) {
	return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
	if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
	if (state.switchU) {
		if (state.current() === 99) state.raise("Invalid unicode escape");
		state.raise("Invalid escape");
	}
	return false;
};
pp$1.regexp_eatBackReference = function(state) {
	var start = state.pos;
	if (this.regexp_eatDecimalEscape(state)) {
		var n$1 = state.lastIntValue;
		if (state.switchU) {
			if (n$1 > state.maxBackReference) state.maxBackReference = n$1;
			return true;
		}
		if (n$1 <= state.numCapturingParens) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatKGroupName = function(state) {
	if (state.eat(107)) {
		if (this.regexp_eatGroupName(state)) {
			state.backReferenceNames.push(state.lastStringValue);
			return true;
		}
		state.raise("Invalid named reference");
	}
	return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
	return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
	var start = state.pos;
	if (state.eat(99)) {
		if (this.regexp_eatControlLetter(state)) return true;
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatZero = function(state) {
	if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
		state.lastIntValue = 0;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlEscape = function(state) {
	var ch = state.current();
	if (ch === 116) {
		state.lastIntValue = 9;
		state.advance();
		return true;
	}
	if (ch === 110) {
		state.lastIntValue = 10;
		state.advance();
		return true;
	}
	if (ch === 118) {
		state.lastIntValue = 11;
		state.advance();
		return true;
	}
	if (ch === 102) {
		state.lastIntValue = 12;
		state.advance();
		return true;
	}
	if (ch === 114) {
		state.lastIntValue = 13;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatControlLetter = function(state) {
	var ch = state.current();
	if (isControlLetter(ch)) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
function isControlLetter(ch) {
	return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
	if (forceU === void 0) forceU = false;
	var start = state.pos;
	var switchU = forceU || state.switchU;
	if (state.eat(117)) {
		if (this.regexp_eatFixedHexDigits(state, 4)) {
			var lead = state.lastIntValue;
			if (switchU && lead >= 55296 && lead <= 56319) {
				var leadSurrogateEnd = state.pos;
				if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
					var trail = state.lastIntValue;
					if (trail >= 56320 && trail <= 57343) {
						state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
						return true;
					}
				}
				state.pos = leadSurrogateEnd;
				state.lastIntValue = lead;
			}
			return true;
		}
		if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) return true;
		if (switchU) state.raise("Invalid unicode escape");
		state.pos = start;
	}
	return false;
};
function isValidUnicode(ch) {
	return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
	if (state.switchU) {
		if (this.regexp_eatSyntaxCharacter(state)) return true;
		if (state.eat(47)) {
			state.lastIntValue = 47;
			return true;
		}
		return false;
	}
	var ch = state.current();
	if (ch !== 99 && (!state.switchN || ch !== 107)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
	state.lastIntValue = 0;
	var ch = state.current();
	if (ch >= 49 && ch <= 57) {
		do {
			state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
			state.advance();
		} while ((ch = state.current()) >= 48 && ch <= 57);
		return true;
	}
	return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
	var ch = state.current();
	if (isCharacterClassEscape(ch)) {
		state.lastIntValue = -1;
		state.advance();
		return CharSetOk;
	}
	var negate = false;
	if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
		state.lastIntValue = -1;
		state.advance();
		var result;
		if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
			if (negate && result === CharSetString) state.raise("Invalid property name");
			return result;
		}
		state.raise("Invalid property name");
	}
	return CharSetNone;
};
function isCharacterClassEscape(ch) {
	return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
	var start = state.pos;
	if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
		var name = state.lastStringValue;
		if (this.regexp_eatUnicodePropertyValue(state)) {
			var value = state.lastStringValue;
			this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
			return CharSetOk;
		}
	}
	state.pos = start;
	if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
		var nameOrValue = state.lastStringValue;
		return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
	}
	return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
	if (!hasOwn(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
	if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
	if (state.unicodeProperties.binary.test(nameOrValue)) return CharSetOk;
	if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) return CharSetString;
	state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyNameCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
	return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
	var ch = 0;
	state.lastStringValue = "";
	while (isUnicodePropertyValueCharacter(ch = state.current())) {
		state.lastStringValue += codePointToString(ch);
		state.advance();
	}
	return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
	return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
	return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
	if (state.eat(91)) {
		var negate = state.eat(94);
		var result = this.regexp_classContents(state);
		if (!state.eat(93)) state.raise("Unterminated character class");
		if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
		return true;
	}
	return false;
};
pp$1.regexp_classContents = function(state) {
	if (state.current() === 93) return CharSetOk;
	if (state.switchV) return this.regexp_classSetExpression(state);
	this.regexp_nonEmptyClassRanges(state);
	return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
	while (this.regexp_eatClassAtom(state)) {
		var left = state.lastIntValue;
		if (state.eat(45) && this.regexp_eatClassAtom(state)) {
			var right = state.lastIntValue;
			if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
		}
	}
};
pp$1.regexp_eatClassAtom = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatClassEscape(state)) return true;
		if (state.switchU) {
			var ch$1 = state.current();
			if (ch$1 === 99 || isOctalDigit(ch$1)) state.raise("Invalid class escape");
			state.raise("Invalid escape");
		}
		state.pos = start;
	}
	var ch = state.current();
	if (ch !== 93) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatClassEscape = function(state) {
	var start = state.pos;
	if (state.eat(98)) {
		state.lastIntValue = 8;
		return true;
	}
	if (state.switchU && state.eat(45)) {
		state.lastIntValue = 45;
		return true;
	}
	if (!state.switchU && state.eat(99)) {
		if (this.regexp_eatClassControlLetter(state)) return true;
		state.pos = start;
	}
	return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
	var result = CharSetOk, subResult;
	if (this.regexp_eatClassSetRange(state));
	else if (subResult = this.regexp_eatClassSetOperand(state)) {
		if (subResult === CharSetString) result = CharSetString;
		var start = state.pos;
		while (state.eatChars([38, 38])) {
			if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
				if (subResult !== CharSetString) result = CharSetOk;
				continue;
			}
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
		while (state.eatChars([45, 45])) {
			if (this.regexp_eatClassSetOperand(state)) continue;
			state.raise("Invalid character in character class");
		}
		if (start !== state.pos) return result;
	} else state.raise("Invalid character in character class");
	for (;;) {
		if (this.regexp_eatClassSetRange(state)) continue;
		subResult = this.regexp_eatClassSetOperand(state);
		if (!subResult) return result;
		if (subResult === CharSetString) result = CharSetString;
	}
};
pp$1.regexp_eatClassSetRange = function(state) {
	var start = state.pos;
	if (this.regexp_eatClassSetCharacter(state)) {
		var left = state.lastIntValue;
		if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
			var right = state.lastIntValue;
			if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
			return true;
		}
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
	if (this.regexp_eatClassSetCharacter(state)) return CharSetOk;
	return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
	var start = state.pos;
	if (state.eat(91)) {
		var negate = state.eat(94);
		var result = this.regexp_classContents(state);
		if (state.eat(93)) {
			if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
			return result;
		}
		state.pos = start;
	}
	if (state.eat(92)) {
		var result$1 = this.regexp_eatCharacterClassEscape(state);
		if (result$1) return result$1;
		state.pos = start;
	}
	return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
	var start = state.pos;
	if (state.eatChars([92, 113])) {
		if (state.eat(123)) {
			var result = this.regexp_classStringDisjunctionContents(state);
			if (state.eat(125)) return result;
		} else state.raise("Invalid escape");
		state.pos = start;
	}
	return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
	var result = this.regexp_classString(state);
	while (state.eat(124)) if (this.regexp_classString(state) === CharSetString) result = CharSetString;
	return result;
};
pp$1.regexp_classString = function(state) {
	var count = 0;
	while (this.regexp_eatClassSetCharacter(state)) count++;
	return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
	var start = state.pos;
	if (state.eat(92)) {
		if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) return true;
		if (state.eat(98)) {
			state.lastIntValue = 8;
			return true;
		}
		state.pos = start;
		return false;
	}
	var ch = state.current();
	if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) return false;
	if (isClassSetSyntaxCharacter(ch)) return false;
	state.advance();
	state.lastIntValue = ch;
	return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
	return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
	return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
	var ch = state.current();
	if (isClassSetReservedPunctuator(ch)) {
		state.lastIntValue = ch;
		state.advance();
		return true;
	}
	return false;
};
function isClassSetReservedPunctuator(ch) {
	return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
	var ch = state.current();
	if (isDecimalDigit(ch) || ch === 95) {
		state.lastIntValue = ch % 32;
		state.advance();
		return true;
	}
	return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
	var start = state.pos;
	if (state.eat(120)) {
		if (this.regexp_eatFixedHexDigits(state, 2)) return true;
		if (state.switchU) state.raise("Invalid escape");
		state.pos = start;
	}
	return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isDecimalDigit(ch = state.current())) {
		state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
		state.advance();
	}
	return state.pos !== start;
};
function isDecimalDigit(ch) {
	return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
	var start = state.pos;
	var ch = 0;
	state.lastIntValue = 0;
	while (isHexDigit(ch = state.current())) {
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return state.pos !== start;
};
function isHexDigit(ch) {
	return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
	if (ch >= 65 && ch <= 70) return 10 + (ch - 65);
	if (ch >= 97 && ch <= 102) return 10 + (ch - 97);
	return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
	if (this.regexp_eatOctalDigit(state)) {
		var n1 = state.lastIntValue;
		if (this.regexp_eatOctalDigit(state)) {
			var n2 = state.lastIntValue;
			if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
			else state.lastIntValue = n1 * 8 + n2;
		} else state.lastIntValue = n1;
		return true;
	}
	return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
	var ch = state.current();
	if (isOctalDigit(ch)) {
		state.lastIntValue = ch - 48;
		state.advance();
		return true;
	}
	state.lastIntValue = 0;
	return false;
};
function isOctalDigit(ch) {
	return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
	var start = state.pos;
	state.lastIntValue = 0;
	for (var i$1 = 0; i$1 < length; ++i$1) {
		var ch = state.current();
		if (!isHexDigit(ch)) {
			state.pos = start;
			return false;
		}
		state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
		state.advance();
	}
	return true;
};
var Token = function Token$1(p) {
	this.type = p.type;
	this.value = p.value;
	this.start = p.start;
	this.end = p.end;
	if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
	if (p.options.ranges) this.range = [p.start, p.end];
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
	if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
	if (this.options.onToken) this.options.onToken(new Token(this));
	this.lastTokEnd = this.end;
	this.lastTokStart = this.start;
	this.lastTokEndLoc = this.endLoc;
	this.lastTokStartLoc = this.startLoc;
	this.nextToken();
};
pp.getToken = function() {
	this.next();
	return new Token(this);
};
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function() {
	var this$1$1 = this;
	return { next: function() {
		var token = this$1$1.getToken();
		return {
			done: token.type === types$1$1.eof,
			value: token
		};
	} };
};
pp.nextToken = function() {
	var curContext = this.curContext();
	if (!curContext || !curContext.preserveSpace) this.skipSpace();
	this.start = this.pos;
	if (this.options.locations) this.startLoc = this.curPosition();
	if (this.pos >= this.input.length) return this.finishToken(types$1$1.eof);
	if (curContext.override) return curContext.override(this);
	else this.readToken(this.fullCharCodeAtPos());
};
pp.readToken = function(code) {
	if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) return this.readWord();
	return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
	var code = this.input.charCodeAt(this.pos);
	if (code <= 55295 || code >= 56320) return code;
	var next = this.input.charCodeAt(this.pos + 1);
	return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
	var startLoc = this.options.onComment && this.curPosition();
	var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
	if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	this.pos = end + 2;
	if (this.options.locations) for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
		++this.curLine;
		pos = this.lineStart = nextBreak;
	}
	if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};
pp.skipLineComment = function(startSkip) {
	var start = this.pos;
	var startLoc = this.options.onComment && this.curPosition();
	var ch = this.input.charCodeAt(this.pos += startSkip);
	while (this.pos < this.input.length && !isNewLine(ch)) ch = this.input.charCodeAt(++this.pos);
	if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
pp.skipSpace = function() {
	loop: while (this.pos < this.input.length) {
		var ch = this.input.charCodeAt(this.pos);
		switch (ch) {
			case 32:
			case 160:
				++this.pos;
				break;
			case 13: if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
			case 10:
			case 8232:
			case 8233:
				++this.pos;
				if (this.options.locations) {
					++this.curLine;
					this.lineStart = this.pos;
				}
				break;
			case 47:
				switch (this.input.charCodeAt(this.pos + 1)) {
					case 42:
						this.skipBlockComment();
						break;
					case 47:
						this.skipLineComment(2);
						break;
					default: break loop;
				}
				break;
			default: if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
			else break loop;
		}
	}
};
pp.finishToken = function(type, val) {
	this.end = this.pos;
	if (this.options.locations) this.endLoc = this.curPosition();
	var prevType = this.type;
	this.type = type;
	this.value = val;
	this.updateContext(prevType);
};
pp.readToken_dot = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next >= 48 && next <= 57) return this.readNumber(true);
	var next2 = this.input.charCodeAt(this.pos + 2);
	if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
		this.pos += 3;
		return this.finishToken(types$1$1.ellipsis);
	} else {
		++this.pos;
		return this.finishToken(types$1$1.dot);
	}
};
pp.readToken_slash = function() {
	var next = this.input.charCodeAt(this.pos + 1);
	if (this.exprAllowed) {
		++this.pos;
		return this.readRegexp();
	}
	if (next === 61) return this.finishOp(types$1$1.assign, 2);
	return this.finishOp(types$1$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	var tokentype = code === 42 ? types$1$1.star : types$1$1.modulo;
	if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
		++size;
		tokentype = types$1$1.starstar;
		next = this.input.charCodeAt(this.pos + 2);
	}
	if (next === 61) return this.finishOp(types$1$1.assign, size + 1);
	return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (this.options.ecmaVersion >= 12) {
			if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1$1.assign, 3);
		}
		return this.finishOp(code === 124 ? types$1$1.logicalOR : types$1$1.logicalAND, 2);
	}
	if (next === 61) return this.finishOp(types$1$1.assign, 2);
	return this.finishOp(code === 124 ? types$1$1.bitwiseOR : types$1$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
	if (this.input.charCodeAt(this.pos + 1) === 61) return this.finishOp(types$1$1.assign, 2);
	return this.finishOp(types$1$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === code) {
		if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
			this.skipLineComment(3);
			this.skipSpace();
			return this.nextToken();
		}
		return this.finishOp(types$1$1.incDec, 2);
	}
	if (next === 61) return this.finishOp(types$1$1.assign, 2);
	return this.finishOp(types$1$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	var size = 1;
	if (next === code) {
		size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
		if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types$1$1.assign, size + 1);
		return this.finishOp(types$1$1.bitShift, size);
	}
	if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
		this.skipLineComment(4);
		this.skipSpace();
		return this.nextToken();
	}
	if (next === 61) size = 2;
	return this.finishOp(types$1$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
	var next = this.input.charCodeAt(this.pos + 1);
	if (next === 61) return this.finishOp(types$1$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
		this.pos += 2;
		return this.finishToken(types$1$1.arrow);
	}
	return this.finishOp(code === 61 ? types$1$1.eq : types$1$1.prefix, 1);
};
pp.readToken_question = function() {
	var ecmaVersion$1 = this.options.ecmaVersion;
	if (ecmaVersion$1 >= 11) {
		var next = this.input.charCodeAt(this.pos + 1);
		if (next === 46) {
			var next2 = this.input.charCodeAt(this.pos + 2);
			if (next2 < 48 || next2 > 57) return this.finishOp(types$1$1.questionDot, 2);
		}
		if (next === 63) {
			if (ecmaVersion$1 >= 12) {
				if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1$1.assign, 3);
			}
			return this.finishOp(types$1$1.coalesce, 2);
		}
	}
	return this.finishOp(types$1$1.question, 1);
};
pp.readToken_numberSign = function() {
	var ecmaVersion$1 = this.options.ecmaVersion;
	var code = 35;
	if (ecmaVersion$1 >= 13) {
		++this.pos;
		code = this.fullCharCodeAtPos();
		if (isIdentifierStart(code, true) || code === 92) return this.finishToken(types$1$1.privateId, this.readWord1());
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
	switch (code) {
		case 46: return this.readToken_dot();
		case 40:
			++this.pos;
			return this.finishToken(types$1$1.parenL);
		case 41:
			++this.pos;
			return this.finishToken(types$1$1.parenR);
		case 59:
			++this.pos;
			return this.finishToken(types$1$1.semi);
		case 44:
			++this.pos;
			return this.finishToken(types$1$1.comma);
		case 91:
			++this.pos;
			return this.finishToken(types$1$1.bracketL);
		case 93:
			++this.pos;
			return this.finishToken(types$1$1.bracketR);
		case 123:
			++this.pos;
			return this.finishToken(types$1$1.braceL);
		case 125:
			++this.pos;
			return this.finishToken(types$1$1.braceR);
		case 58:
			++this.pos;
			return this.finishToken(types$1$1.colon);
		case 96:
			if (this.options.ecmaVersion < 6) break;
			++this.pos;
			return this.finishToken(types$1$1.backQuote);
		case 48:
			var next = this.input.charCodeAt(this.pos + 1);
			if (next === 120 || next === 88) return this.readRadixNumber(16);
			if (this.options.ecmaVersion >= 6) {
				if (next === 111 || next === 79) return this.readRadixNumber(8);
				if (next === 98 || next === 66) return this.readRadixNumber(2);
			}
		case 49:
		case 50:
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57: return this.readNumber(false);
		case 34:
		case 39: return this.readString(code);
		case 47: return this.readToken_slash();
		case 37:
		case 42: return this.readToken_mult_modulo_exp(code);
		case 124:
		case 38: return this.readToken_pipe_amp(code);
		case 94: return this.readToken_caret();
		case 43:
		case 45: return this.readToken_plus_min(code);
		case 60:
		case 62: return this.readToken_lt_gt(code);
		case 61:
		case 33: return this.readToken_eq_excl(code);
		case 63: return this.readToken_question();
		case 126: return this.finishOp(types$1$1.prefix, 1);
		case 35: return this.readToken_numberSign();
	}
	this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
	var str = this.input.slice(this.pos, this.pos + size);
	this.pos += size;
	return this.finishToken(type, str);
};
pp.readRegexp = function() {
	var escaped, inClass, start = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
		var ch = this.input.charAt(this.pos);
		if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
		if (!escaped) {
			if (ch === "[") inClass = true;
			else if (ch === "]" && inClass) inClass = false;
			else if (ch === "/" && !inClass) break;
			escaped = ch === "\\";
		} else escaped = false;
		++this.pos;
	}
	var pattern = this.input.slice(start, this.pos);
	++this.pos;
	var flagsStart = this.pos;
	var flags = this.readWord1();
	if (this.containsEsc) this.unexpected(flagsStart);
	var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
	state.reset(start, pattern, flags);
	this.validateRegExpFlags(state);
	this.validateRegExpPattern(state);
	var value = null;
	try {
		value = new RegExp(pattern, flags);
	} catch (e) {}
	return this.finishToken(types$1$1.regexp, {
		pattern,
		flags,
		value
	});
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
	var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
	var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
	var start = this.pos, total = 0, lastCode = 0;
	for (var i$1 = 0, e = len == null ? Infinity : len; i$1 < e; ++i$1, ++this.pos) {
		var code = this.input.charCodeAt(this.pos), val = void 0;
		if (allowSeparators && code === 95) {
			if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
			if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
			if (i$1 === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
			lastCode = code;
			continue;
		}
		if (code >= 97) val = code - 97 + 10;
		else if (code >= 65) val = code - 65 + 10;
		else if (code >= 48 && code <= 57) val = code - 48;
		else val = Infinity;
		if (val >= radix) break;
		lastCode = code;
		total = total * radix + val;
	}
	if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
	if (this.pos === start || len != null && this.pos - start !== len) return null;
	return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
	if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
	return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
	if (typeof BigInt !== "function") return null;
	return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
	var start = this.pos;
	this.pos += 2;
	var val = this.readInt(radix);
	if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
		val = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
	} else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	return this.finishToken(types$1$1.num, val);
};
pp.readNumber = function(startsWithDot) {
	var start = this.pos;
	if (!startsWithDot && this.readInt(10, void 0, true) === null) this.raise(start, "Invalid number");
	var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
	if (octal && this.strict) this.raise(start, "Invalid number");
	var next = this.input.charCodeAt(this.pos);
	if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
		var val$1 = stringToBigInt(this.input.slice(start, this.pos));
		++this.pos;
		if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
		return this.finishToken(types$1$1.num, val$1);
	}
	if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
	if (next === 46 && !octal) {
		++this.pos;
		this.readInt(10);
		next = this.input.charCodeAt(this.pos);
	}
	if ((next === 69 || next === 101) && !octal) {
		next = this.input.charCodeAt(++this.pos);
		if (next === 43 || next === 45) ++this.pos;
		if (this.readInt(10) === null) this.raise(start, "Invalid number");
	}
	if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	var val = stringToNumber(this.input.slice(start, this.pos), octal);
	return this.finishToken(types$1$1.num, val);
};
pp.readCodePoint = function() {
	var ch = this.input.charCodeAt(this.pos), code;
	if (ch === 123) {
		if (this.options.ecmaVersion < 6) this.unexpected();
		var codePos = ++this.pos;
		code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
		++this.pos;
		if (code > 1114111) this.invalidStringToken(codePos, "Code point out of bounds");
	} else code = this.readHexChar(4);
	return code;
};
pp.readString = function(quote) {
	var out = "", chunkStart = ++this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === quote) break;
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(false);
			chunkStart = this.pos;
		} else if (ch === 8232 || ch === 8233) {
			if (this.options.ecmaVersion < 10) this.raise(this.start, "Unterminated string constant");
			++this.pos;
			if (this.options.locations) {
				this.curLine++;
				this.lineStart = this.pos;
			}
		} else {
			if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
			++this.pos;
		}
	}
	out += this.input.slice(chunkStart, this.pos++);
	return this.finishToken(types$1$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
	this.inTemplateElement = true;
	try {
		this.readTmplToken();
	} catch (err) {
		if (err === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
		else throw err;
	}
	this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
	if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
	else this.raise(position, message);
};
pp.readTmplToken = function() {
	var out = "", chunkStart = this.pos;
	for (;;) {
		if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
		var ch = this.input.charCodeAt(this.pos);
		if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
			if (this.pos === this.start && (this.type === types$1$1.template || this.type === types$1$1.invalidTemplate)) if (ch === 36) {
				this.pos += 2;
				return this.finishToken(types$1$1.dollarBraceL);
			} else {
				++this.pos;
				return this.finishToken(types$1$1.backQuote);
			}
			out += this.input.slice(chunkStart, this.pos);
			return this.finishToken(types$1$1.template, out);
		}
		if (ch === 92) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.readEscapedChar(true);
			chunkStart = this.pos;
		} else if (isNewLine(ch)) {
			out += this.input.slice(chunkStart, this.pos);
			++this.pos;
			switch (ch) {
				case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
				case 10:
					out += "\n";
					break;
				default:
					out += String.fromCharCode(ch);
					break;
			}
			if (this.options.locations) {
				++this.curLine;
				this.lineStart = this.pos;
			}
			chunkStart = this.pos;
		} else ++this.pos;
	}
};
pp.readInvalidTemplateToken = function() {
	for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
		case "\\":
			++this.pos;
			break;
		case "$": if (this.input[this.pos + 1] !== "{") break;
		case "`": return this.finishToken(types$1$1.invalidTemplate, this.input.slice(this.start, this.pos));
		case "\r": if (this.input[this.pos + 1] === "\n") ++this.pos;
		case "\n":
		case "\u2028":
		case "\u2029":
			++this.curLine;
			this.lineStart = this.pos + 1;
			break;
	}
	this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
	var ch = this.input.charCodeAt(++this.pos);
	++this.pos;
	switch (ch) {
		case 110: return "\n";
		case 114: return "\r";
		case 120: return String.fromCharCode(this.readHexChar(2));
		case 117: return codePointToString(this.readCodePoint());
		case 116: return "	";
		case 98: return "\b";
		case 118: return "\v";
		case 102: return "\f";
		case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
		case 10:
			if (this.options.locations) {
				this.lineStart = this.pos;
				++this.curLine;
			}
			return "";
		case 56:
		case 57:
			if (this.strict) this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
			if (inTemplate) {
				var codePos = this.pos - 1;
				this.invalidStringToken(codePos, "Invalid escape sequence in template string");
			}
		default:
			if (ch >= 48 && ch <= 55) {
				var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
				var octal = parseInt(octalStr, 8);
				if (octal > 255) {
					octalStr = octalStr.slice(0, -1);
					octal = parseInt(octalStr, 8);
				}
				this.pos += octalStr.length - 1;
				ch = this.input.charCodeAt(this.pos);
				if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
				return String.fromCharCode(octal);
			}
			if (isNewLine(ch)) {
				if (this.options.locations) {
					this.lineStart = this.pos;
					++this.curLine;
				}
				return "";
			}
			return String.fromCharCode(ch);
	}
};
pp.readHexChar = function(len) {
	var codePos = this.pos;
	var n$1 = this.readInt(16, len);
	if (n$1 === null) this.invalidStringToken(codePos, "Bad character escape sequence");
	return n$1;
};
pp.readWord1 = function() {
	this.containsEsc = false;
	var word = "", first = true, chunkStart = this.pos;
	var astral = this.options.ecmaVersion >= 6;
	while (this.pos < this.input.length) {
		var ch = this.fullCharCodeAtPos();
		if (isIdentifierChar(ch, astral)) this.pos += ch <= 65535 ? 1 : 2;
		else if (ch === 92) {
			this.containsEsc = true;
			word += this.input.slice(chunkStart, this.pos);
			var escStart = this.pos;
			if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
			++this.pos;
			var esc = this.readCodePoint();
			if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
			word += codePointToString(esc);
			chunkStart = this.pos;
		} else break;
		first = false;
	}
	return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
	var word = this.readWord1();
	var type = types$1$1.name;
	if (this.keywords.test(word)) type = keywords[word];
	return this.finishToken(type, word);
};
var version = "8.14.0";
Parser.acorn = {
	Parser,
	version,
	defaultOptions,
	Position,
	SourceLocation,
	getLineInfo,
	Node,
	TokenType,
	tokTypes: types$1$1,
	keywordTypes: keywords,
	TokContext,
	tokContexts: types$2,
	isIdentifierChar,
	isIdentifierStart,
	Token,
	isNewLine,
	lineBreak,
	lineBreakG,
	nonASCIIwhitespace
};

//#endregion
//#region ../../node_modules/.pnpm/ufo@1.5.4/node_modules/ufo/dist/index.mjs
const r = String.fromCharCode;
const TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
const JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasTrailingSlash(input = "", respectQueryAndFragment) {
	if (!respectQueryAndFragment) return input.endsWith("/");
	return TRAILING_SLASH_RE.test(input);
}
function withTrailingSlash$1(input = "", respectQueryAndFragment) {
	if (!respectQueryAndFragment) return input.endsWith("/") ? input : input + "/";
	if (hasTrailingSlash(input, true)) return input || "/";
	let path$3 = input;
	let fragment = "";
	const fragmentIndex = input.indexOf("#");
	if (fragmentIndex >= 0) {
		path$3 = input.slice(0, fragmentIndex);
		fragment = input.slice(fragmentIndex);
		if (!path$3) return fragment;
	}
	const [s0, ...s] = path$3.split("?");
	return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function isNonEmptyURL(url) {
	return url && url !== "/";
}
function joinURL(base, ...input) {
	let url = base || "";
	for (const segment of input.filter((url2) => isNonEmptyURL(url2))) if (url) {
		const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
		url = withTrailingSlash$1(url) + _segment;
	} else url = segment;
	return url;
}
const protocolRelative = Symbol.for("ufo:protocolRelative");

//#endregion
//#region ../../node_modules/.pnpm/pathe@2.0.1/node_modules/pathe/dist/shared/pathe.BLwDEnA5.mjs
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const isAbsolute = function(p) {
	return _IS_ABSOLUTE_RE.test(p);
};

//#endregion
//#region ../../node_modules/.pnpm/mlly@1.7.4/node_modules/mlly/dist/index.mjs
const BUILTIN_MODULES = new Set(builtinModules);
function normalizeSlash(path$3) {
	return path$3.replace(/\\/g, "/");
}
/**
* @typedef ErrnoExceptionFields
* @property {number | undefined} [errnode]
* @property {string | undefined} [code]
* @property {string | undefined} [path]
* @property {string | undefined} [syscall]
* @property {string | undefined} [url]
*
* @typedef {Error & ErrnoExceptionFields} ErrnoException
*/
const own$1 = {}.hasOwnProperty;
const classRegExp = /^([A-Z][a-z\d]*)+$/;
const kTypes = new Set([
	"string",
	"function",
	"number",
	"object",
	"Function",
	"Object",
	"boolean",
	"bigint",
	"symbol"
]);
const codes = {};
/**
* Create a list string in the form like 'A and B' or 'A, B, ..., and Z'.
* We cannot use Intl.ListFormat because it's not available in
* --without-intl builds.
*
* @param {Array<string>} array
*   An array of strings.
* @param {string} [type]
*   The list type to be inserted before the last element.
* @returns {string}
*/
function formatList(array, type = "and") {
	return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
/** @type {Map<string, MessageFunction | string>} */
const messages = /* @__PURE__ */ new Map();
const nodeInternalPrefix = "__node_internal_";
/** @type {number} */
let userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError(
	"ERR_INVALID_ARG_TYPE",
	/**
	* @param {string} name
	* @param {Array<string> | string} expected
	* @param {unknown} actual
	*/
	(name, expected, actual) => {
		assert(typeof name === "string", "'name' must be a string");
		if (!Array.isArray(expected)) expected = [expected];
		let message = "The ";
		if (name.endsWith(" argument")) message += `${name} `;
		else {
			const type = name.includes(".") ? "property" : "argument";
			message += `"${name}" ${type} `;
		}
		message += "must be ";
		/** @type {Array<string>} */
		const types$3 = [];
		/** @type {Array<string>} */
		const instances = [];
		/** @type {Array<string>} */
		const other = [];
		for (const value of expected) {
			assert(typeof value === "string", "All expected entries have to be of type string");
			if (kTypes.has(value)) types$3.push(value.toLowerCase());
			else if (classRegExp.exec(value) === null) {
				assert(value !== "object", "The value \"object\" should be written as \"Object\"");
				other.push(value);
			} else instances.push(value);
		}
		if (instances.length > 0) {
			const pos = types$3.indexOf("object");
			if (pos !== -1) {
				types$3.slice(pos, 1);
				instances.push("Object");
			}
		}
		if (types$3.length > 0) {
			message += `${types$3.length > 1 ? "one of type" : "of type"} ${formatList(types$3, "or")}`;
			if (instances.length > 0 || other.length > 0) message += " or ";
		}
		if (instances.length > 0) {
			message += `an instance of ${formatList(instances, "or")}`;
			if (other.length > 0) message += " or ";
		}
		if (other.length > 0) if (other.length > 1) message += `one of ${formatList(other, "or")}`;
		else {
			if (other[0].toLowerCase() !== other[0]) message += "an ";
			message += `${other[0]}`;
		}
		message += `. Received ${determineSpecificType(actual)}`;
		return message;
	},
	TypeError
);
codes.ERR_INVALID_MODULE_SPECIFIER = createError(
	"ERR_INVALID_MODULE_SPECIFIER",
	/**
	* @param {string} request
	* @param {string} reason
	* @param {string} [base]
	*/
	(request$1, reason, base = void 0) => {
		return `Invalid module "${request$1}" ${reason}${base ? ` imported from ${base}` : ""}`;
	},
	TypeError
);
codes.ERR_INVALID_PACKAGE_CONFIG = createError(
	"ERR_INVALID_PACKAGE_CONFIG",
	/**
	* @param {string} path
	* @param {string} [base]
	* @param {string} [message]
	*/
	(path$3, base, message) => {
		return `Invalid package config ${path$3}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
	},
	Error
);
codes.ERR_INVALID_PACKAGE_TARGET = createError(
	"ERR_INVALID_PACKAGE_TARGET",
	/**
	* @param {string} packagePath
	* @param {string} key
	* @param {unknown} target
	* @param {boolean} [isImport=false]
	* @param {string} [base]
	*/
	(packagePath, key, target$1, isImport = false, base = void 0) => {
		const relatedError = typeof target$1 === "string" && !isImport && target$1.length > 0 && !target$1.startsWith("./");
		if (key === ".") {
			assert(isImport === false);
			return `Invalid "exports" main target ${JSON.stringify(target$1)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? "; targets must start with \"./\"" : ""}`;
		}
		return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target$1)} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? "; targets must start with \"./\"" : ""}`;
	},
	Error
);
codes.ERR_MODULE_NOT_FOUND = createError(
	"ERR_MODULE_NOT_FOUND",
	/**
	* @param {string} path
	* @param {string} base
	* @param {boolean} [exactUrl]
	*/
	(path$3, base, exactUrl = false) => {
		return `Cannot find ${exactUrl ? "module" : "package"} '${path$3}' imported from ${base}`;
	},
	Error
);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
	"ERR_PACKAGE_IMPORT_NOT_DEFINED",
	/**
	* @param {string} specifier
	* @param {string} packagePath
	* @param {string} base
	*/
	(specifier, packagePath, base) => {
		return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
	},
	TypeError
);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
	"ERR_PACKAGE_PATH_NOT_EXPORTED",
	/**
	* @param {string} packagePath
	* @param {string} subpath
	* @param {string} [base]
	*/
	(packagePath, subpath, base = void 0) => {
		if (subpath === ".") return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
		return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
	},
	Error
);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error);
codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", "Failed to resolve module specifier \"%s\" from \"%s\": Invalid relative URL or base scheme is not hierarchical.", TypeError);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
	"ERR_UNKNOWN_FILE_EXTENSION",
	/**
	* @param {string} extension
	* @param {string} path
	*/
	(extension, path$3) => {
		return `Unknown file extension "${extension}" for ${path$3}`;
	},
	TypeError
);
codes.ERR_INVALID_ARG_VALUE = createError(
	"ERR_INVALID_ARG_VALUE",
	/**
	* @param {string} name
	* @param {unknown} value
	* @param {string} [reason='is invalid']
	*/
	(name, value, reason = "is invalid") => {
		let inspected = inspect(value);
		if (inspected.length > 128) inspected = `${inspected.slice(0, 128)}...`;
		return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
	},
	TypeError
);
/**
* Utility function for registering the error codes. Only used here. Exported
* *only* to allow for testing.
* @param {string} sym
* @param {MessageFunction | string} value
* @param {ErrorConstructor} constructor
* @returns {new (...parameters: Array<any>) => Error}
*/
function createError(sym, value, constructor) {
	messages.set(sym, value);
	return makeNodeErrorWithCode(constructor, sym);
}
/**
* @param {ErrorConstructor} Base
* @param {string} key
* @returns {ErrorConstructor}
*/
function makeNodeErrorWithCode(Base, key) {
	return NodeError;
	/**
	* @param {Array<unknown>} parameters
	*/
	function NodeError(...parameters) {
		const limit = Error.stackTraceLimit;
		if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
		const error = new Base();
		if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
		const message = getMessage(key, parameters, error);
		Object.defineProperties(error, {
			message: {
				value: message,
				enumerable: false,
				writable: true,
				configurable: true
			},
			toString: {
				value() {
					return `${this.name} [${key}]: ${this.message}`;
				},
				enumerable: false,
				writable: true,
				configurable: true
			}
		});
		captureLargerStackTrace(error);
		error.code = key;
		return error;
	}
}
/**
* @returns {boolean}
*/
function isErrorStackTraceLimitWritable() {
	try {
		if (v8.startupSnapshot.isBuildingSnapshot()) return false;
	} catch {}
	const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
	if (desc === void 0) return Object.isExtensible(Error);
	return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
/**
* This function removes unnecessary frames from Node.js core errors.
* @template {(...parameters: unknown[]) => unknown} T
* @param {T} wrappedFunction
* @returns {T}
*/
function hideStackFrames(wrappedFunction) {
	const hidden = nodeInternalPrefix + wrappedFunction.name;
	Object.defineProperty(wrappedFunction, "name", { value: hidden });
	return wrappedFunction;
}
const captureLargerStackTrace = hideStackFrames(
	/**
	* @param {Error} error
	* @returns {Error}
	*/
	function(error) {
		const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
		if (stackTraceLimitIsWritable) {
			userStackTraceLimit = Error.stackTraceLimit;
			Error.stackTraceLimit = Number.POSITIVE_INFINITY;
		}
		Error.captureStackTrace(error);
		if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
		return error;
	}
);
/**
* @param {string} key
* @param {Array<unknown>} parameters
* @param {Error} self
* @returns {string}
*/
function getMessage(key, parameters, self) {
	const message = messages.get(key);
	assert(message !== void 0, "expected `message` to be found");
	if (typeof message === "function") {
		assert(message.length <= parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`);
		return Reflect.apply(message, self, parameters);
	}
	const regex = /%[dfijoOs]/g;
	let expectedLength = 0;
	while (regex.exec(message) !== null) expectedLength++;
	assert(expectedLength === parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`);
	if (parameters.length === 0) return message;
	parameters.unshift(message);
	return Reflect.apply(format, null, parameters);
}
/**
* Determine the specific type of a value for type-mismatch errors.
* @param {unknown} value
* @returns {string}
*/
function determineSpecificType(value) {
	if (value === null || value === void 0) return String(value);
	if (typeof value === "function" && value.name) return `function ${value.name}`;
	if (typeof value === "object") {
		if (value.constructor && value.constructor.name) return `an instance of ${value.constructor.name}`;
		return `${inspect(value, { depth: -1 })}`;
	}
	let inspected = inspect(value, { colors: false });
	if (inspected.length > 28) inspected = `${inspected.slice(0, 25)}...`;
	return `type ${typeof value} (${inspected})`;
}
const hasOwnProperty$1 = {}.hasOwnProperty;
const { ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1 } = codes;
/** @type {Map<string, PackageConfig>} */
const cache = /* @__PURE__ */ new Map();
/**
* @param {string} jsonPath
* @param {{specifier: URL | string, base?: URL}} options
* @returns {PackageConfig}
*/
function read(jsonPath, { base, specifier }) {
	const existing = cache.get(jsonPath);
	if (existing) return existing;
	/** @type {string | undefined} */
	let string;
	try {
		string = fs.readFileSync(path.toNamespacedPath(jsonPath), "utf8");
	} catch (error) {
		const exception = error;
		if (exception.code !== "ENOENT") throw exception;
	}
	/** @type {PackageConfig} */
	const result = {
		exists: false,
		pjsonPath: jsonPath,
		main: void 0,
		name: void 0,
		type: "none",
		exports: void 0,
		imports: void 0
	};
	if (string !== void 0) {
		/** @type {Record<string, unknown>} */
		let parsed;
		try {
			parsed = JSON.parse(string);
		} catch (error_) {
			const cause = error_;
			const error = new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath, (base ? `"${specifier}" from ` : "") + fileURLToPath(base || specifier), cause.message);
			error.cause = cause;
			throw error;
		}
		result.exists = true;
		if (hasOwnProperty$1.call(parsed, "name") && typeof parsed.name === "string") result.name = parsed.name;
		if (hasOwnProperty$1.call(parsed, "main") && typeof parsed.main === "string") result.main = parsed.main;
		if (hasOwnProperty$1.call(parsed, "exports")) result.exports = parsed.exports;
		if (hasOwnProperty$1.call(parsed, "imports")) result.imports = parsed.imports;
		if (hasOwnProperty$1.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) result.type = parsed.type;
	}
	cache.set(jsonPath, result);
	return result;
}
/**
* @param {URL | string} resolved
* @returns {PackageConfig}
*/
function getPackageScopeConfig(resolved) {
	let packageJSONUrl = new URL("package.json", resolved);
	while (true) {
		if (packageJSONUrl.pathname.endsWith("node_modules/package.json")) break;
		const packageConfig = read(fileURLToPath(packageJSONUrl), { specifier: resolved });
		if (packageConfig.exists) return packageConfig;
		const lastPackageJSONUrl = packageJSONUrl;
		packageJSONUrl = new URL("../package.json", packageJSONUrl);
		if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;
	}
	return {
		pjsonPath: fileURLToPath(packageJSONUrl),
		exists: false,
		type: "none"
	};
}
/**
* Returns the package type for a given URL.
* @param {URL} url - The URL to get the package type for.
* @returns {PackageType}
*/
function getPackageType(url) {
	return getPackageScopeConfig(url).type;
}
const { ERR_UNKNOWN_FILE_EXTENSION } = codes;
const hasOwnProperty = {}.hasOwnProperty;
/** @type {Record<string, string>} */
const extensionFormatMap = {
	__proto__: null,
	".cjs": "commonjs",
	".js": "module",
	".json": "json",
	".mjs": "module"
};
/**
* @param {string | null} mime
* @returns {string | null}
*/
function mimeToFormat(mime) {
	if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)) return "module";
	if (mime === "application/json") return "json";
	return null;
}
/**
* @callback ProtocolHandler
* @param {URL} parsed
* @param {{parentURL: string, source?: Buffer}} context
* @param {boolean} ignoreErrors
* @returns {string | null | void}
*/
/**
* @type {Record<string, ProtocolHandler>}
*/
const protocolHandlers = {
	__proto__: null,
	"data:": getDataProtocolModuleFormat,
	"file:": getFileProtocolModuleFormat,
	"http:": getHttpProtocolModuleFormat,
	"https:": getHttpProtocolModuleFormat,
	"node:"() {
		return "builtin";
	}
};
/**
* @param {URL} parsed
*/
function getDataProtocolModuleFormat(parsed) {
	const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [
		null,
		null,
		null
	];
	return mimeToFormat(mime);
}
/**
* Returns the file extension from a URL.
*
* Should give similar result to
* `require('node:path').extname(require('node:url').fileURLToPath(url))`
* when used with a `file:` URL.
*
* @param {URL} url
* @returns {string}
*/
function extname$1(url) {
	const pathname = url.pathname;
	let index = pathname.length;
	while (index--) {
		const code = pathname.codePointAt(index);
		if (code === 47) return "";
		if (code === 46) return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
	}
	return "";
}
/**
* @type {ProtocolHandler}
*/
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
	const value = extname$1(url);
	if (value === ".js") {
		const packageType = getPackageType(url);
		if (packageType !== "none") return packageType;
		return "commonjs";
	}
	if (value === "") {
		const packageType = getPackageType(url);
		if (packageType === "none" || packageType === "commonjs") return "commonjs";
		return "module";
	}
	const format$1 = extensionFormatMap[value];
	if (format$1) return format$1;
	if (ignoreErrors) return;
	throw new ERR_UNKNOWN_FILE_EXTENSION(value, fileURLToPath(url));
}
function getHttpProtocolModuleFormat() {}
/**
* @param {URL} url
* @param {{parentURL: string}} context
* @returns {string | null}
*/
function defaultGetFormatWithoutErrors(url, context) {
	const protocol = url.protocol;
	if (!hasOwnProperty.call(protocolHandlers, protocol)) return null;
	return protocolHandlers[protocol](url, context, true) || null;
}
const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
const { ERR_NETWORK_IMPORT_DISALLOWED, ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_RESOLVE_REQUEST } = codes;
const own = {}.hasOwnProperty;
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
const deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const invalidPackageNameRegEx = /^\.|%|\\/;
const patternRegEx = /\*/g;
const encodedSeparatorRegEx = /%2f|%5c/i;
/** @type {Set<string>} */
const emittedPackageWarnings = /* @__PURE__ */ new Set();
const doubleSlashRegEx = /[/\\]{2}/;
/**
*
* @param {string} target
* @param {string} request
* @param {string} match
* @param {URL} packageJsonUrl
* @param {boolean} internal
* @param {URL} base
* @param {boolean} isTarget
*/
function emitInvalidSegmentDeprecation(target$1, request$1, match, packageJsonUrl, internal, base, isTarget) {
	if (process$1.noDeprecation) return;
	const pjsonPath = fileURLToPath(packageJsonUrl);
	const double = doubleSlashRegEx.exec(isTarget ? target$1 : request$1) !== null;
	process$1.emitWarning(`Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target$1}" for module request "${request$1}" ${request$1 === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}.`, "DeprecationWarning", "DEP0166");
}
/**
* @param {URL} url
* @param {URL} packageJsonUrl
* @param {URL} base
* @param {string} [main]
* @returns {void}
*/
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
	if (process$1.noDeprecation) return;
	if (defaultGetFormatWithoutErrors(url, { parentURL: base.href }) !== "module") return;
	const urlPath = fileURLToPath(url.href);
	const packagePath = fileURLToPath(new URL$1(".", packageJsonUrl));
	const basePath = fileURLToPath(base);
	if (!main) process$1.emitWarning(`No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\nDefault "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
	else if (path.resolve(packagePath, main) !== urlPath) process$1.emitWarning(`Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(packagePath.length)}", imported from ${basePath}.\n Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
}
/**
* @param {string} path
* @returns {Stats | undefined}
*/
function tryStatSync(path$3) {
	try {
		return statSync(path$3);
	} catch {}
}
/**
* Legacy CommonJS main resolution:
* 1. let M = pkg_url + (json main field)
* 2. TRY(M, M.js, M.json, M.node)
* 3. TRY(M/index.js, M/index.json, M/index.node)
* 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)
* 5. NOT_FOUND
*
* @param {URL} url
* @returns {boolean}
*/
function fileExists(url) {
	const stats = statSync(url, { throwIfNoEntry: false });
	const isFile = stats ? stats.isFile() : void 0;
	return isFile === null || isFile === void 0 ? false : isFile;
}
/**
* @param {URL} packageJsonUrl
* @param {PackageConfig} packageConfig
* @param {URL} base
* @returns {URL}
*/
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
	/** @type {URL | undefined} */
	let guess;
	if (packageConfig.main !== void 0) {
		guess = new URL$1(packageConfig.main, packageJsonUrl);
		if (fileExists(guess)) return guess;
		const tries$1 = [
			`./${packageConfig.main}.js`,
			`./${packageConfig.main}.json`,
			`./${packageConfig.main}.node`,
			`./${packageConfig.main}/index.js`,
			`./${packageConfig.main}/index.json`,
			`./${packageConfig.main}/index.node`
		];
		let i$2 = -1;
		while (++i$2 < tries$1.length) {
			guess = new URL$1(tries$1[i$2], packageJsonUrl);
			if (fileExists(guess)) break;
			guess = void 0;
		}
		if (guess) {
			emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
			return guess;
		}
	}
	const tries = [
		"./index.js",
		"./index.json",
		"./index.node"
	];
	let i$1 = -1;
	while (++i$1 < tries.length) {
		guess = new URL$1(tries[i$1], packageJsonUrl);
		if (fileExists(guess)) break;
		guess = void 0;
	}
	if (guess) {
		emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
		return guess;
	}
	throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL$1(".", packageJsonUrl)), fileURLToPath(base));
}
/**
* @param {URL} resolved
* @param {URL} base
* @param {boolean} [preserveSymlinks]
* @returns {URL}
*/
function finalizeResolution(resolved, base, preserveSymlinks) {
	if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, "must not include encoded \"/\" or \"\\\" characters", fileURLToPath(base));
	/** @type {string} */
	let filePath;
	try {
		filePath = fileURLToPath(resolved);
	} catch (error) {
		const cause = error;
		Object.defineProperty(cause, "input", { value: String(resolved) });
		Object.defineProperty(cause, "module", { value: String(base) });
		throw cause;
	}
	const stats = tryStatSync(filePath.endsWith("/") ? filePath.slice(-1) : filePath);
	if (stats && stats.isDirectory()) {
		const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath(base));
		error.url = String(resolved);
		throw error;
	}
	if (!stats || !stats.isFile()) {
		const error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && fileURLToPath(base), true);
		error.url = String(resolved);
		throw error;
	}
	{
		const real = realpathSync(filePath);
		const { search, hash } = resolved;
		resolved = pathToFileURL(real + (filePath.endsWith(path.sep) ? "/" : ""));
		resolved.search = search;
		resolved.hash = hash;
	}
	return resolved;
}
/**
* @param {string} specifier
* @param {URL | undefined} packageJsonUrl
* @param {URL} base
* @returns {Error}
*/
function importNotDefined(specifier, packageJsonUrl, base) {
	return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && fileURLToPath(new URL$1(".", packageJsonUrl)), fileURLToPath(base));
}
/**
* @param {string} subpath
* @param {URL} packageJsonUrl
* @param {URL} base
* @returns {Error}
*/
function exportsNotFound(subpath, packageJsonUrl, base) {
	return new ERR_PACKAGE_PATH_NOT_EXPORTED(fileURLToPath(new URL$1(".", packageJsonUrl)), subpath, base && fileURLToPath(base));
}
/**
* @param {string} request
* @param {string} match
* @param {URL} packageJsonUrl
* @param {boolean} internal
* @param {URL} [base]
* @returns {never}
*/
function throwInvalidSubpath(request$1, match, packageJsonUrl, internal, base) {
	throw new ERR_INVALID_MODULE_SPECIFIER(request$1, `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath(packageJsonUrl)}`, base && fileURLToPath(base));
}
/**
* @param {string} subpath
* @param {unknown} target
* @param {URL} packageJsonUrl
* @param {boolean} internal
* @param {URL} [base]
* @returns {Error}
*/
function invalidPackageTarget(subpath, target$1, packageJsonUrl, internal, base) {
	target$1 = typeof target$1 === "object" && target$1 !== null ? JSON.stringify(target$1, null, "") : `${target$1}`;
	return new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL$1(".", packageJsonUrl)), subpath, target$1, internal, base && fileURLToPath(base));
}
/**
* @param {string} target
* @param {string} subpath
* @param {string} match
* @param {URL} packageJsonUrl
* @param {URL} base
* @param {boolean} pattern
* @param {boolean} internal
* @param {boolean} isPathMap
* @param {Set<string> | undefined} conditions
* @returns {URL}
*/
function resolvePackageTargetString(target$1, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
	if (subpath !== "" && !pattern && target$1[target$1.length - 1] !== "/") throw invalidPackageTarget(match, target$1, packageJsonUrl, internal, base);
	if (!target$1.startsWith("./")) {
		if (internal && !target$1.startsWith("../") && !target$1.startsWith("/")) {
			let isURL = false;
			try {
				new URL$1(target$1);
				isURL = true;
			} catch {}
			if (!isURL) return packageResolve(pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target$1, () => subpath) : target$1 + subpath, packageJsonUrl, conditions);
		}
		throw invalidPackageTarget(match, target$1, packageJsonUrl, internal, base);
	}
	if (invalidSegmentRegEx.exec(target$1.slice(2)) !== null) if (deprecatedInvalidSegmentRegEx.exec(target$1.slice(2)) === null) {
		if (!isPathMap) {
			const request$1 = pattern ? match.replace("*", () => subpath) : match + subpath;
			emitInvalidSegmentDeprecation(pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target$1, () => subpath) : target$1, request$1, match, packageJsonUrl, internal, base, true);
		}
	} else throw invalidPackageTarget(match, target$1, packageJsonUrl, internal, base);
	const resolved = new URL$1(target$1, packageJsonUrl);
	const resolvedPath = resolved.pathname;
	const packagePath = new URL$1(".", packageJsonUrl).pathname;
	if (!resolvedPath.startsWith(packagePath)) throw invalidPackageTarget(match, target$1, packageJsonUrl, internal, base);
	if (subpath === "") return resolved;
	if (invalidSegmentRegEx.exec(subpath) !== null) {
		const request$1 = pattern ? match.replace("*", () => subpath) : match + subpath;
		if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
			if (!isPathMap) emitInvalidSegmentDeprecation(pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target$1, () => subpath) : target$1, request$1, match, packageJsonUrl, internal, base, false);
		} else throwInvalidSubpath(request$1, match, packageJsonUrl, internal, base);
	}
	if (pattern) return new URL$1(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () => subpath));
	return new URL$1(subpath, resolved);
}
/**
* @param {string} key
* @returns {boolean}
*/
function isArrayIndex(key) {
	const keyNumber = Number(key);
	if (`${keyNumber}` !== key) return false;
	return keyNumber >= 0 && keyNumber < 4294967295;
}
/**
* @param {URL} packageJsonUrl
* @param {unknown} target
* @param {string} subpath
* @param {string} packageSubpath
* @param {URL} base
* @param {boolean} pattern
* @param {boolean} internal
* @param {boolean} isPathMap
* @param {Set<string> | undefined} conditions
* @returns {URL | null}
*/
function resolvePackageTarget(packageJsonUrl, target$1, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
	if (typeof target$1 === "string") return resolvePackageTargetString(target$1, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);
	if (Array.isArray(target$1)) {
		/** @type {Array<unknown>} */
		const targetList = target$1;
		if (targetList.length === 0) return null;
		/** @type {ErrnoException | null | undefined} */
		let lastException;
		let i$1 = -1;
		while (++i$1 < targetList.length) {
			const targetItem = targetList[i$1];
			/** @type {URL | null} */
			let resolveResult;
			try {
				resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
			} catch (error) {
				const exception = error;
				lastException = exception;
				if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
				throw error;
			}
			if (resolveResult === void 0) continue;
			if (resolveResult === null) {
				lastException = null;
				continue;
			}
			return resolveResult;
		}
		if (lastException === void 0 || lastException === null) return null;
		throw lastException;
	}
	if (typeof target$1 === "object" && target$1 !== null) {
		const keys = Object.getOwnPropertyNames(target$1);
		let i$1 = -1;
		while (++i$1 < keys.length) {
			const key = keys[i$1];
			if (isArrayIndex(key)) throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJsonUrl), base, "\"exports\" cannot contain numeric property keys.");
		}
		i$1 = -1;
		while (++i$1 < keys.length) {
			const key = keys[i$1];
			if (key === "default" || conditions && conditions.has(key)) {
				const conditionalTarget = target$1[key];
				const resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
				if (resolveResult === void 0) continue;
				return resolveResult;
			}
		}
		return null;
	}
	if (target$1 === null) return null;
	throw invalidPackageTarget(packageSubpath, target$1, packageJsonUrl, internal, base);
}
/**
* @param {unknown} exports
* @param {URL} packageJsonUrl
* @param {URL} base
* @returns {boolean}
*/
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
	if (typeof exports === "string" || Array.isArray(exports)) return true;
	if (typeof exports !== "object" || exports === null) return false;
	const keys = Object.getOwnPropertyNames(exports);
	let isConditionalSugar = false;
	let i$1 = 0;
	let keyIndex = -1;
	while (++keyIndex < keys.length) {
		const key = keys[keyIndex];
		const currentIsConditionalSugar = key === "" || key[0] !== ".";
		if (i$1++ === 0) isConditionalSugar = currentIsConditionalSugar;
		else if (isConditionalSugar !== currentIsConditionalSugar) throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJsonUrl), base, "\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.");
	}
	return isConditionalSugar;
}
/**
* @param {string} match
* @param {URL} pjsonUrl
* @param {URL} base
*/
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
	if (process$1.noDeprecation) return;
	const pjsonPath = fileURLToPath(pjsonUrl);
	if (emittedPackageWarnings.has(pjsonPath + "|" + match)) return;
	emittedPackageWarnings.add(pjsonPath + "|" + match);
	process$1.emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155");
}
/**
* @param {URL} packageJsonUrl
* @param {string} packageSubpath
* @param {Record<string, unknown>} packageConfig
* @param {URL} base
* @param {Set<string> | undefined} conditions
* @returns {URL}
*/
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
	let exports = packageConfig.exports;
	if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) exports = { ".": exports };
	if (own.call(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
		const target$1 = exports[packageSubpath];
		const resolveResult = resolvePackageTarget(packageJsonUrl, target$1, "", packageSubpath, base, false, false, false, conditions);
		if (resolveResult === null || resolveResult === void 0) throw exportsNotFound(packageSubpath, packageJsonUrl, base);
		return resolveResult;
	}
	let bestMatch = "";
	let bestMatchSubpath = "";
	const keys = Object.getOwnPropertyNames(exports);
	let i$1 = -1;
	while (++i$1 < keys.length) {
		const key = keys[i$1];
		const patternIndex = key.indexOf("*");
		if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
			if (packageSubpath.endsWith("/")) emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
			const patternTrailer = key.slice(patternIndex + 1);
			if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
				bestMatch = key;
				bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
			}
		}
	}
	if (bestMatch) {
		const target$1 = exports[bestMatch];
		const resolveResult = resolvePackageTarget(packageJsonUrl, target$1, bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith("/"), conditions);
		if (resolveResult === null || resolveResult === void 0) throw exportsNotFound(packageSubpath, packageJsonUrl, base);
		return resolveResult;
	}
	throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
/**
* @param {string} a
* @param {string} b
*/
function patternKeyCompare(a, b) {
	const aPatternIndex = a.indexOf("*");
	const bPatternIndex = b.indexOf("*");
	const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
	const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
	if (baseLengthA > baseLengthB) return -1;
	if (baseLengthB > baseLengthA) return 1;
	if (aPatternIndex === -1) return 1;
	if (bPatternIndex === -1) return -1;
	if (a.length > b.length) return -1;
	if (b.length > a.length) return 1;
	return 0;
}
/**
* @param {string} name
* @param {URL} base
* @param {Set<string>} [conditions]
* @returns {URL}
*/
function packageImportsResolve(name, base, conditions) {
	if (name === "#" || name.startsWith("#/") || name.endsWith("/")) throw new ERR_INVALID_MODULE_SPECIFIER(name, "is not a valid internal imports specifier name", fileURLToPath(base));
	/** @type {URL | undefined} */
	let packageJsonUrl;
	const packageConfig = getPackageScopeConfig(base);
	if (packageConfig.exists) {
		packageJsonUrl = pathToFileURL(packageConfig.pjsonPath);
		const imports = packageConfig.imports;
		if (imports) if (own.call(imports, name) && !name.includes("*")) {
			const resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], "", name, base, false, true, false, conditions);
			if (resolveResult !== null && resolveResult !== void 0) return resolveResult;
		} else {
			let bestMatch = "";
			let bestMatchSubpath = "";
			const keys = Object.getOwnPropertyNames(imports);
			let i$1 = -1;
			while (++i$1 < keys.length) {
				const key = keys[i$1];
				const patternIndex = key.indexOf("*");
				if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
					const patternTrailer = key.slice(patternIndex + 1);
					if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
						bestMatch = key;
						bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
					}
				}
			}
			if (bestMatch) {
				const target$1 = imports[bestMatch];
				const resolveResult = resolvePackageTarget(packageJsonUrl, target$1, bestMatchSubpath, bestMatch, base, true, true, false, conditions);
				if (resolveResult !== null && resolveResult !== void 0) return resolveResult;
			}
		}
	}
	throw importNotDefined(name, packageJsonUrl, base);
}
/**
* @param {string} specifier
* @param {URL} base
*/
function parsePackageName(specifier, base) {
	let separatorIndex = specifier.indexOf("/");
	let validPackageName = true;
	let isScoped = false;
	if (specifier[0] === "@") {
		isScoped = true;
		if (separatorIndex === -1 || specifier.length === 0) validPackageName = false;
		else separatorIndex = specifier.indexOf("/", separatorIndex + 1);
	}
	const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
	if (invalidPackageNameRegEx.exec(packageName) !== null) validPackageName = false;
	if (!validPackageName) throw new ERR_INVALID_MODULE_SPECIFIER(specifier, "is not a valid package name", fileURLToPath(base));
	return {
		packageName,
		packageSubpath: "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex)),
		isScoped
	};
}
/**
* @param {string} specifier
* @param {URL} base
* @param {Set<string> | undefined} conditions
* @returns {URL}
*/
function packageResolve(specifier, base, conditions) {
	if (builtinModules.includes(specifier)) return new URL$1("node:" + specifier);
	const { packageName, packageSubpath, isScoped } = parsePackageName(specifier, base);
	const packageConfig = getPackageScopeConfig(base);
	/* c8 ignore next 16 */
	if (packageConfig.exists) {
		const packageJsonUrl$1 = pathToFileURL(packageConfig.pjsonPath);
		if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) return packageExportsResolve(packageJsonUrl$1, packageSubpath, packageConfig, base, conditions);
	}
	let packageJsonUrl = new URL$1("./node_modules/" + packageName + "/package.json", base);
	let packageJsonPath = fileURLToPath(packageJsonUrl);
	/** @type {string} */
	let lastPath;
	do {
		const stat = tryStatSync(packageJsonPath.slice(0, -13));
		if (!stat || !stat.isDirectory()) {
			lastPath = packageJsonPath;
			packageJsonUrl = new URL$1((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl);
			packageJsonPath = fileURLToPath(packageJsonUrl);
			continue;
		}
		const packageConfig$1 = read(packageJsonPath, {
			base,
			specifier
		});
		if (packageConfig$1.exports !== void 0 && packageConfig$1.exports !== null) return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig$1, base, conditions);
		if (packageSubpath === ".") return legacyMainResolve(packageJsonUrl, packageConfig$1, base);
		return new URL$1(packageSubpath, packageJsonUrl);
	} while (packageJsonPath.length !== lastPath.length);
	throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base), false);
}
/**
* @param {string} specifier
* @returns {boolean}
*/
function isRelativeSpecifier(specifier) {
	if (specifier[0] === ".") {
		if (specifier.length === 1 || specifier[1] === "/") return true;
		if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) return true;
	}
	return false;
}
/**
* @param {string} specifier
* @returns {boolean}
*/
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
	if (specifier === "") return false;
	if (specifier[0] === "/") return true;
	return isRelativeSpecifier(specifier);
}
/**
* The “Resolver Algorithm Specification” as detailed in the Node docs (which is
* sync and slightly lower-level than `resolve`).
*
* @param {string} specifier
*   `/example.js`, `./example.js`, `../example.js`, `some-package`, `fs`, etc.
* @param {URL} base
*   Full URL (to a file) that `specifier` is resolved relative from.
* @param {Set<string>} [conditions]
*   Conditions.
* @param {boolean} [preserveSymlinks]
*   Keep symlinks instead of resolving them.
* @returns {URL}
*   A URL object to the found thing.
*/
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
	const protocol = base.protocol;
	const isRemote = protocol === "data:" || protocol === "http:" || protocol === "https:";
	/** @type {URL | undefined} */
	let resolved;
	if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) try {
		resolved = new URL$1(specifier, base);
	} catch (error_) {
		const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
		error.cause = error_;
		throw error;
	}
	else if (protocol === "file:" && specifier[0] === "#") resolved = packageImportsResolve(specifier, base, conditions);
	else try {
		resolved = new URL$1(specifier);
	} catch (error_) {
		if (isRemote && !builtinModules.includes(specifier)) {
			const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
			error.cause = error_;
			throw error;
		}
		resolved = packageResolve(specifier, base, conditions);
	}
	assert(resolved !== void 0, "expected to be defined");
	if (resolved.protocol !== "file:") return resolved;
	return finalizeResolution(resolved, base);
}
function fileURLToPath$1(id) {
	if (typeof id === "string" && !id.startsWith("file://")) return normalizeSlash(id);
	return normalizeSlash(fileURLToPath(id));
}
function pathToFileURL$1(id) {
	return pathToFileURL(fileURLToPath$1(id)).toString();
}
function normalizeid(id) {
	if (typeof id !== "string") id = id.toString();
	if (/(node|data|http|https|file):/.test(id)) return id;
	if (BUILTIN_MODULES.has(id)) return "node:" + id;
	return "file://" + encodeURI(normalizeSlash(id));
}
const DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
const DEFAULT_EXTENSIONS = [
	".mjs",
	".cjs",
	".js",
	".json"
];
const NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
	"ERR_MODULE_NOT_FOUND",
	"ERR_UNSUPPORTED_DIR_IMPORT",
	"MODULE_NOT_FOUND",
	"ERR_PACKAGE_PATH_NOT_EXPORTED"
]);
function _tryModuleResolve(id, url, conditions) {
	try {
		return moduleResolve(id, url, conditions);
	} catch (error) {
		if (!NOT_FOUND_ERRORS.has(error?.code)) throw error;
	}
}
function _resolve(id, options = {}) {
	if (typeof id !== "string") if (id instanceof URL) id = fileURLToPath$1(id);
	else throw new TypeError("input must be a `string` or `URL`");
	if (/(node|data|http|https):/.test(id)) return id;
	if (BUILTIN_MODULES.has(id)) return "node:" + id;
	if (id.startsWith("file://")) id = fileURLToPath$1(id);
	if (isAbsolute(id)) try {
		if (statSync(id).isFile()) return pathToFileURL$1(id);
	} catch (error) {
		if (error?.code !== "ENOENT") throw error;
	}
	const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
	const _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((url) => new URL(normalizeid(url.toString())));
	if (_urls.length === 0) _urls.push(new URL(pathToFileURL$1(process.cwd())));
	const urls = [..._urls];
	for (const url of _urls) if (url.protocol === "file:") urls.push(new URL("./", url), new URL(joinURL(url.pathname, "_index.js"), url), new URL("node_modules", url));
	let resolved;
	for (const url of urls) {
		resolved = _tryModuleResolve(id, url, conditionsSet);
		if (resolved) break;
		for (const prefix of ["", "/index"]) {
			for (const extension of options.extensions || DEFAULT_EXTENSIONS) {
				resolved = _tryModuleResolve(joinURL(id, prefix) + extension, url, conditionsSet);
				if (resolved) break;
			}
			if (resolved) break;
		}
		if (resolved) break;
	}
	if (!resolved) {
		const error = /* @__PURE__ */ new Error(`Cannot find module ${id} imported from ${urls.join(", ")}`);
		error.code = "ERR_MODULE_NOT_FOUND";
		throw error;
	}
	return pathToFileURL$1(resolved);
}
function resolveSync(id, options) {
	return _resolve(id, options);
}
function resolvePathSync(id, options) {
	return fileURLToPath$1(resolveSync(id, options));
}

//#endregion
//#region src/nodejs-compat.ts
var NodeJsCompat = class {
	externals;
	entries;
	#env;
	/**
	* Map of module identifiers to an array of:
	* - `injectedName`: the name injected on `globalThis`
	* - `exportName`: the export name from the module
	* - `importName`: the imported name
	*/
	#injectsByModule;
	/**
	* Map of virtual module to injectable module ID,
	* which then maps via `injectsByModule` to the global code to be injected.
	*/
	#virtualModulePathToSpecifier;
	constructor(workerConfig) {
		const { env } = defineEnv({ presets: [getCloudflarePreset({
			compatibilityDate: workerConfig.compatibility_date,
			compatibilityFlags: workerConfig.compatibility_flags
		})] });
		this.#env = env;
		this.externals = new Set(env.external);
		this.entries = this.#getEntries();
		const { injectsByModule, virtualModulePathToSpecifier } = this.#getInjects();
		this.#injectsByModule = injectsByModule;
		this.#virtualModulePathToSpecifier = virtualModulePathToSpecifier;
	}
	/**
	* Gets a set of module specifiers for all possible Node.js compat polyfill entry-points
	*/
	#getEntries() {
		const entries = new Set(Object.values(this.#env.alias));
		for (const globalInject of Object.values(this.#env.inject)) if (typeof globalInject === "string") entries.add(globalInject);
		else {
			assert(globalInject[0] !== void 0, "Expected first element of globalInject to be defined");
			entries.add(globalInject[0]);
		}
		this.#env.polyfill.forEach((polyfill) => entries.add(polyfill));
		this.externals.forEach((external) => entries.delete(external));
		return entries;
	}
	#getInjects() {
		const injectsByModule = /* @__PURE__ */ new Map();
		const virtualModulePathToSpecifier = /* @__PURE__ */ new Map();
		const virtualModulePrefix = `\0_nodejs_global_inject-`;
		for (const [injectedName, moduleSpecifier] of Object.entries(this.#env.inject)) {
			const [module$1, exportName, importName] = Array.isArray(moduleSpecifier) ? [
				moduleSpecifier[0],
				moduleSpecifier[1],
				moduleSpecifier[1]
			] : [
				moduleSpecifier,
				"default",
				"defaultExport"
			];
			if (!injectsByModule.has(module$1)) {
				injectsByModule.set(module$1, []);
				virtualModulePathToSpecifier.set(`${virtualModulePrefix}${module$1.replaceAll("/", "-")}`, module$1);
			}
			const injects = injectsByModule.get(module$1);
			assert(injects, `expected injects for "${module$1}" to be defined`);
			injects.push({
				injectedName,
				exportName,
				importName
			});
		}
		return {
			injectsByModule,
			virtualModulePathToSpecifier
		};
	}
	/**
	* Does the given module ID resolve to a virtual module corresponding to a global injection module?
	*/
	isGlobalVirtualModule(source) {
		return this.#virtualModulePathToSpecifier.has(source);
	}
	/**
	* Get the contents of the virtual module corresponding to a global injection module.
	*/
	getGlobalVirtualModule(source) {
		const module$1 = this.#virtualModulePathToSpecifier.get(source);
		if (!module$1) return;
		const injects = this.#injectsByModule.get(module$1);
		assert(injects, `expected injects for "${module$1}" to be defined`);
		return [`import { ${injects.map(({ exportName, importName }) => importName === exportName ? exportName : `${exportName} as ${importName}`).join(", ")} } from "${module$1}";`, ...injects.map(({ injectedName, importName }) => `globalThis.${injectedName} = ${importName};`)].join("\n");
	}
	/**
	* Gets the necessary global polyfills to inject into the entry-point of the user's code.
	*/
	injectGlobalCode() {
		return `${Array.from(this.#virtualModulePathToSpecifier.keys()).map((moduleId) => `import "${moduleId}";`).join("\n")}${this.#env.polyfill.map((polyfillPath) => `import "${polyfillPath}";`).join("\n")}`;
	}
	/**
	* Resolves the `source` to a Node.js compat alias if possible.
	*
	* If there is an alias, the return value is an object with:
	* - `unresolved`: a bare import path to the polyfill (e.g. `unenv/runtime/node/crypto`)
	* - `resolved`: an absolute path to the polyfill (e.g. `/path/to/project/node_modules/unenv/runtime/node/child_process/index.mjs`)
	*/
	resolveNodeJsImport(source) {
		const alias = this.#env.alias[source];
		if (alias && !this.externals.has(alias)) return {
			unresolved: alias,
			resolved: resolvePathSync(alias, { url: import.meta.url })
		};
		if (this.entries.has(source)) return {
			unresolved: source,
			resolved: resolvePathSync(source, { url: import.meta.url })
		};
	}
};
/**
* Returns `true` if the given combination of compat dates and flags enables Node.js compatibility.
*/
function hasNodeJsCompat(workerConfig) {
	const nodeCompatMode = getNodeCompat(workerConfig.compatibility_date, workerConfig.compatibility_flags ?? []).mode;
	if (nodeCompatMode === "v2") return true;
	if (nodeCompatMode === "v1") throw new Error(`Unsupported Node.js compat mode (v1). Only the v2 mode is supported, either change your compat date to "2024-09-23" or later, or set the "nodejs_compat_v2" compatibility flag`);
	return false;
}
/**
* Returns true if Node.js async local storage (ALS) is enabled (and not full Node.js compatibility mode).
*/
function hasNodeJsAls(workerConfig) {
	return workerConfig !== void 0 && getNodeCompat(workerConfig.compatibility_date, workerConfig.compatibility_flags ?? []).mode === "als";
}
/**
* All the Node.js modules including their `node:...` aliases.
*/
const nodeJsBuiltins = new Set([...builtinModules, ...builtinModules.map((m) => `node:${m}`)]);
const NODEJS_MODULES_RE = /* @__PURE__ */ new RegExp(`^(node:)?(${builtinModules.join("|")})$`);
function isNodeAlsModule(path$3) {
	return /^(node:)?async_hooks$/.test(path$3);
}
function assertHasNodeJsCompat(nodeJsCompat) {
	assert(nodeJsCompat, `expected nodeJsCompat to be defined`);
}
var NodeJsCompatWarnings = class {
	sources = /* @__PURE__ */ new Map();
	timer;
	constructor(environmentName, resolvedViteConfig) {
		this.environmentName = environmentName;
		this.resolvedViteConfig = resolvedViteConfig;
	}
	registerImport(source, importer = "<unknown>") {
		const importers = this.sources.get(source) ?? /* @__PURE__ */ new Set();
		this.sources.set(source, importers);
		importers.add(importer);
		this.renderWarningsOnIdle();
	}
	renderWarningsOnIdle() {
		if (this.timer) clearTimeout(this.timer);
		this.timer = setTimeout(() => {
			this.renderWarnings();
			this.timer = void 0;
		}, 500);
	}
	renderWarnings() {
		if (this.sources.size > 0) {
			let message = `Unexpected Node.js imports for environment "${this.environmentName}". Do you need to enable the "nodejs_compat" compatibility flag? Refer to https://developers.cloudflare.com/workers/runtime-apis/nodejs/ for more details.
`;
			this.sources.forEach((importers, source) => {
				importers.forEach((importer) => {
					message += ` - "${source}" imported from "${path$2.relative(this.resolvedViteConfig.root, importer)}"\n`;
				});
			});
			this.resolvedViteConfig.logger.warn(message, { timestamp: true });
			this.sources.clear();
		}
	}
};

//#endregion
//#region src/workers-configs.ts
/**
* Set of worker config options that are not applicable when using Vite
*/
const nonApplicableWorkerConfigs = {
	replacedByVite: {
		alias: {
			viteReplacement: "resolve.alias",
			viteDocs: "https://vite.dev/config/shared-options.html#resolve-alias"
		},
		define: {
			viteReplacement: "define",
			viteDocs: "https://vite.dev/config/shared-options.html#define"
		},
		minify: {
			viteReplacement: "build.minify",
			viteDocs: "https://vite.dev/config/build-options.html#build-minify"
		}
	},
	notRelevant: [
		"base_dir",
		"build",
		"find_additional_modules",
		"no_bundle",
		"preserve_file_names",
		"rules",
		"site",
		"tsconfig"
	]
};
/**
* The non applicable configs that can be and default to `undefined`
*/
const nullableNonApplicable = [
	"alias",
	"base_dir",
	"find_additional_modules",
	"minify",
	"no_bundle",
	"preserve_file_names",
	"site",
	"tsconfig"
];
function readWorkerConfig(configPath, env) {
	const nonApplicable = {
		replacedByVite: /* @__PURE__ */ new Set(),
		notRelevant: /* @__PURE__ */ new Set()
	};
	const config = unstable_readConfig({
		config: configPath,
		env
	}, { preserveOriginalMain: true });
	const raw = structuredClone(config);
	nullableNonApplicable.forEach((prop) => {
		if (config[prop] !== void 0) {
			if (isReplacedByVite(prop)) nonApplicable.replacedByVite.add(prop);
			if (isNotRelevant(prop)) nonApplicable.notRelevant.add(prop);
		}
		delete config[prop];
	});
	if (config.build && (config.build.command || config.build.cwd)) nonApplicable.notRelevant.add("build");
	delete config["build"];
	if (config.define && Object.keys(config.define).length > 0) nonApplicable.replacedByVite.add("define");
	delete config["define"];
	if (config.rules.length > 0) nonApplicable.notRelevant.add("rules");
	return {
		raw,
		nonApplicable,
		config
	};
}
function getWarningForWorkersConfigs(configs) {
	if (!("auxiliaryWorkers" in configs) || configs.auxiliaryWorkers.length === 0) {
		const nonApplicableLines = getWorkerNonApplicableWarnLines(configs.entryWorker, `  - `);
		if (nonApplicableLines.length === 0) return;
		const lines$1 = [`\n\n\x1b[43mWARNING\x1b[0m: your worker config${configs.entryWorker.config.configPath ? ` (at \`${path$2.relative("", configs.entryWorker.config.configPath)}\`)` : ""} contains the following configuration options which are ignored since they are not applicable when using Vite:`];
		nonApplicableLines.forEach((line) => lines$1.push(line));
		lines$1.push("");
		return lines$1.join("\n");
	}
	const lines = [];
	const processWorkerConfig = (workerConfig, isEntryWorker = false) => {
		const nonApplicableLines = getWorkerNonApplicableWarnLines(workerConfig, `    - `);
		if (nonApplicableLines.length > 0) {
			lines.push(`  - (${isEntryWorker ? "entry" : "auxiliary"}) worker${workerConfig.config.name ? ` "${workerConfig.config.name}"` : ""}${workerConfig.config.configPath ? ` (config at \`${path$2.relative("", workerConfig.config.configPath)}\`)` : ""}`);
			nonApplicableLines.forEach((line) => lines.push(line));
		}
	};
	processWorkerConfig(configs.entryWorker, true);
	configs.auxiliaryWorkers.forEach((config) => processWorkerConfig(config));
	if (lines.length === 0) return;
	return [
		"\n\x1B[43mWARNING\x1B[0m: your workers configs contain configuration options which are ignored since they are not applicable when using Vite:",
		...lines,
		""
	].join("\n");
}
function getWorkerNonApplicableWarnLines(workerConfig, linePrefix) {
	const lines = [];
	const { replacedByVite, notRelevant } = workerConfig.nonApplicable;
	for (const config of replacedByVite) lines.push(`${linePrefix}\`${config}\` which is replaced by Vite's \`${nonApplicableWorkerConfigs.replacedByVite[config].viteReplacement}\` (docs: ${nonApplicableWorkerConfigs.replacedByVite[config].viteDocs})`);
	if (notRelevant.size > 0) lines.push(`${linePrefix}${[...notRelevant].map((config) => `\`${config}\``).join(", ")} which ${notRelevant.size > 1 ? "are" : "is"} not relevant in the context of a Vite project`);
	return lines;
}
function isReplacedByVite(configName) {
	return configName in nonApplicableWorkerConfigs["replacedByVite"];
}
function isNotRelevant(configName) {
	return nonApplicableWorkerConfigs.notRelevant.includes(configName);
}
function missingFieldErrorMessage(field, configPath, env) {
	return `No ${field} field provided in '${configPath}'${env ? ` for '${env}' environment` : ""}`;
}
function getWorkerConfig(configPath, env, opts) {
	if (opts?.visitedConfigPaths?.has(configPath)) throw new Error(`Duplicate Wrangler config path found: ${configPath}`);
	const { raw, config, nonApplicable } = readWorkerConfig(configPath, env);
	opts?.visitedConfigPaths?.add(configPath);
	if (!config.name) throw new Error(missingFieldErrorMessage(`'name'`, configPath, env));
	if (!config.topLevelName) throw new Error(missingFieldErrorMessage(`top-level 'name'`, configPath, env));
	if (!config.compatibility_date) throw new Error(missingFieldErrorMessage(`'compatibility_date`, configPath, env));
	const requiredFields = {
		topLevelName: config.topLevelName,
		name: config.name,
		compatibility_date: config.compatibility_date
	};
	if (opts?.isEntryWorker && !config.main) return {
		type: "assets-only",
		raw,
		config: {
			...config,
			...requiredFields
		},
		nonApplicable
	};
	if (!config.main) throw new Error(missingFieldErrorMessage(`'main'`, configPath, env));
	return {
		type: "worker",
		raw,
		config: {
			...config,
			...requiredFields,
			main: maybeResolveMain(config.main, configPath)
		},
		nonApplicable
	};
}
const ENTRY_MODULE_EXTENSIONS = [
	".js",
	".mjs",
	".ts",
	".mts",
	".jsx",
	".tsx"
];
/**
* If `main` ends with a valid file extension it is resolved to an absolute path.
* Else `main` is returned as is so that it can be resolved by Vite.
* This enables resolving entry modules relative to the Worker config while also supporting virtual modules and package exports.
*/
function maybeResolveMain(main, configPath) {
	if (!ENTRY_MODULE_EXTENSIONS.some((extension) => main.endsWith(extension))) return main;
	const resolvedMain = path$2.resolve(path$2.dirname(configPath), main);
	if (!fs$1.existsSync(resolvedMain)) throw new Error(`The provided Wrangler config main field (${resolvedMain}) doesn't point to an existing file`);
	return resolvedMain;
}
/**
* Returns the path to a wrangler config for a worker after having it validated
* (throws appropriate errors in case the validation fails)
*
* @param root the root of the vite project
* @param requestedConfigPath the requested config path, if any
* @param isForAuxiliaryWorker whether the config path is being requested for an auxiliary worker
* @returns a valid path to a config file
*/
function getValidatedWranglerConfigPath(root, requestedConfigPath, isForAuxiliaryWorker = false) {
	if (requestedConfigPath) {
		const configPath$1 = path$2.resolve(root, requestedConfigPath);
		const errorMessagePrefix = `The provided configPath (${configPath$1})${isForAuxiliaryWorker ? " requested for one of your auxiliary workers" : ""}`;
		const fileExtension = path$2.extname(configPath$1).slice(1);
		if (!allowedWranglerConfigExtensions.includes(fileExtension)) {
			const foundExtensionMessage = !fileExtension ? "no extension found" : `"${fileExtension}" found`;
			throw new Error(`${errorMessagePrefix} doesn't point to a file with the correct file extension. It should point to a jsonc, json or toml file (${foundExtensionMessage} instead)`);
		}
		const mainStat = fs$1.statSync(configPath$1, { throwIfNoEntry: false });
		if (!mainStat) throw new Error(`${errorMessagePrefix} doesn't point to an existing file`);
		if (mainStat.isDirectory()) throw new Error(`${errorMessagePrefix} points to a directory. It should point to a file.`);
		return configPath$1;
	}
	assert(isForAuxiliaryWorker === false, "Unexpected Error: trying to find the wrangler config for an auxiliary worker");
	const configPath = findWranglerConfig(root);
	if (!configPath) throw new Error(`No config file found in the ${root} directory. Please add a wrangler.(jsonc|json|toml) file.`);
	return configPath;
}
function findWranglerConfig(root) {
	for (const extension of allowedWranglerConfigExtensions) {
		const configPath = path$2.join(root, `wrangler.${extension}`);
		if (fs$1.existsSync(configPath)) return configPath;
	}
}
const allowedWranglerConfigExtensions = [
	"jsonc",
	"json",
	"toml"
];

//#endregion
//#region src/plugin-config.ts
function resolvePluginConfig(pluginConfig, userConfig, viteEnv) {
	const shared = {
		persistState: pluginConfig.persistState ?? true,
		inspectorPort: pluginConfig.inspectorPort,
		experimental: pluginConfig.experimental ?? {}
	};
	const root = userConfig.root ? path$2.resolve(userConfig.root) : process.cwd();
	const prefixedEnv = vite.loadEnv(viteEnv.mode, root, ["CLOUDFLARE_", "WRANGLER_HYPERDRIVE_LOCAL_CONNECTION_STRING_"]);
	Object.assign(process.env, prefixedEnv);
	if (viteEnv.isPreview) return {
		...shared,
		remoteBindings: pluginConfig.remoteBindings ?? true,
		type: "preview",
		workers: getWorkerConfigs(root)
	};
	const configPaths = /* @__PURE__ */ new Set();
	const cloudflareEnv = prefixedEnv.CLOUDFLARE_ENV;
	const entryWorkerResolvedConfig = getWorkerConfig(getValidatedWranglerConfigPath(root, pluginConfig.configPath), cloudflareEnv, {
		visitedConfigPaths: configPaths,
		isEntryWorker: true
	});
	if (entryWorkerResolvedConfig.type === "assets-only") return {
		...shared,
		type: "assets-only",
		cloudflareEnv,
		config: entryWorkerResolvedConfig.config,
		configPaths,
		remoteBindings: pluginConfig.remoteBindings ?? true,
		rawConfigs: { entryWorker: entryWorkerResolvedConfig }
	};
	const entryWorkerConfig = entryWorkerResolvedConfig.config;
	const entryWorkerEnvironmentName = pluginConfig.viteEnvironment?.name ?? workerNameToEnvironmentName(entryWorkerConfig.topLevelName);
	let staticRouting;
	if (Array.isArray(entryWorkerConfig.assets?.run_worker_first)) staticRouting = parseStaticRouting(entryWorkerConfig.assets.run_worker_first);
	const environmentNameToWorkerMap = new Map([[entryWorkerEnvironmentName, resolveWorker(entryWorkerConfig)]]);
	const auxiliaryWorkersResolvedConfigs = [];
	for (const auxiliaryWorker of pluginConfig.auxiliaryWorkers ?? []) {
		const workerResolvedConfig = getWorkerConfig(getValidatedWranglerConfigPath(root, auxiliaryWorker.configPath, true), cloudflareEnv, { visitedConfigPaths: configPaths });
		auxiliaryWorkersResolvedConfigs.push(workerResolvedConfig);
		assert(workerResolvedConfig.type === "worker", "Unexpected error: received AssetsOnlyResult with auxiliary workers.");
		const workerConfig = workerResolvedConfig.config;
		const workerEnvironmentName = auxiliaryWorker.viteEnvironment?.name ?? workerNameToEnvironmentName(workerConfig.topLevelName);
		if (environmentNameToWorkerMap.has(workerEnvironmentName)) throw new Error(`Duplicate Vite environment name found: ${workerEnvironmentName}`);
		environmentNameToWorkerMap.set(workerEnvironmentName, resolveWorker(workerConfig));
	}
	return {
		...shared,
		type: "workers",
		cloudflareEnv,
		configPaths,
		environmentNameToWorkerMap,
		entryWorkerEnvironmentName,
		staticRouting,
		remoteBindings: pluginConfig.remoteBindings ?? true,
		rawConfigs: {
			entryWorker: entryWorkerResolvedConfig,
			auxiliaryWorkers: auxiliaryWorkersResolvedConfigs
		}
	};
}
function workerNameToEnvironmentName(workerName) {
	return workerName.replaceAll("-", "_");
}
function resolveWorker(workerConfig) {
	return {
		config: workerConfig,
		nodeJsCompat: hasNodeJsCompat(workerConfig) ? new NodeJsCompat(workerConfig) : void 0
	};
}

//#endregion
//#region ../../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
const comma = ",".charCodeAt(0);
const semicolon = ";".charCodeAt(0);
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const intToChar = new Uint8Array(64);
const charToInt = new Uint8Array(128);
for (let i$1 = 0; i$1 < 64; i$1++) {
	const c = chars.charCodeAt(i$1);
	intToChar[i$1] = c;
	charToInt[c] = i$1;
}
function encodeInteger(builder, num, relative$1) {
	let delta = num - relative$1;
	delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
	do {
		let clamped = delta & 31;
		delta >>>= 5;
		if (delta > 0) clamped |= 32;
		builder.write(intToChar[clamped]);
	} while (delta > 0);
	return num;
}
const bufLength = 1024 * 16;
const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? { decode(buf) {
	return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString();
} } : { decode(buf) {
	let out = "";
	for (let i$1 = 0; i$1 < buf.length; i$1++) out += String.fromCharCode(buf[i$1]);
	return out;
} };
var StringWriter = class {
	constructor() {
		this.pos = 0;
		this.out = "";
		this.buffer = new Uint8Array(bufLength);
	}
	write(v) {
		const { buffer } = this;
		buffer[this.pos++] = v;
		if (this.pos === bufLength) {
			this.out += td.decode(buffer);
			this.pos = 0;
		}
	}
	flush() {
		const { buffer, out, pos } = this;
		return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
	}
};
function encode(decoded) {
	const writer = new StringWriter();
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	for (let i$1 = 0; i$1 < decoded.length; i$1++) {
		const line = decoded[i$1];
		if (i$1 > 0) writer.write(semicolon);
		if (line.length === 0) continue;
		let genColumn = 0;
		for (let j = 0; j < line.length; j++) {
			const segment = line[j];
			if (j > 0) writer.write(comma);
			genColumn = encodeInteger(writer, segment[0], genColumn);
			if (segment.length === 1) continue;
			sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
			sourceLine = encodeInteger(writer, segment[2], sourceLine);
			sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
			if (segment.length === 4) continue;
			namesIndex = encodeInteger(writer, segment[4], namesIndex);
		}
	}
	return writer.flush();
}

//#endregion
//#region ../../node_modules/.pnpm/magic-string@0.30.17/node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}
	add(n$1) {
		this.bits[n$1 >> 5] |= 1 << (n$1 & 31);
	}
	has(n$1) {
		return !!(this.bits[n$1 >> 5] & 1 << (n$1 & 31));
	}
};
var Chunk = class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;
		this.intro = "";
		this.outro = "";
		this.content = content;
		this.storeName = false;
		this.edited = false;
		this.previous = null;
		this.next = null;
	}
	appendLeft(content) {
		this.outro += content;
	}
	appendRight(content) {
		this.intro = this.intro + content;
	}
	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);
		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;
		return chunk;
	}
	contains(index) {
		return this.start < index && index < this.end;
	}
	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}
	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}
	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = "";
			this.outro = "";
		}
		this.storeName = storeName;
		this.edited = true;
		return this;
	}
	prependLeft(content) {
		this.outro = content + this.outro;
	}
	prependRight(content) {
		this.intro = content + this.intro;
	}
	reset() {
		this.intro = "";
		this.outro = "";
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}
	split(index) {
		const sliceIndex = index - this.start;
		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);
		this.original = originalBefore;
		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = "";
		this.end = index;
		if (this.edited) {
			newChunk.edit("", false);
			this.content = "";
		} else this.content = originalBefore;
		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;
		return newChunk;
	}
	toString() {
		return this.intro + this.content + this.outro;
	}
	trimEnd(rx) {
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit("", void 0, true);
				if (this.edited) this.edit(trimmed, this.storeName, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.intro = this.intro.replace(rx, "");
			if (this.intro.length) return true;
		}
	}
	trimStart(rx) {
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		const trimmed = this.content.replace(rx, "");
		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) newChunk.edit(trimmed, this.storeName, true);
				this.edit("", void 0, true);
			}
			return true;
		} else {
			this.edit("", void 0, true);
			this.outro = this.outro.replace(rx, "");
			if (this.outro.length) return true;
		}
	}
};
function getBtoa() {
	if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	else if (typeof Buffer === "function") return (str) => Buffer.from(str, "utf-8").toString("base64");
	else return () => {
		throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
	};
}
const btoa$1 = /* @__PURE__ */ getBtoa();
var SourceMap = class {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== "undefined") this.x_google_ignoreList = properties.x_google_ignoreList;
		if (typeof properties.debugId !== "undefined") this.debugId = properties.debugId;
	}
	toString() {
		return JSON.stringify(this);
	}
	toUrl() {
		return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
	}
};
function guessIndent(code) {
	const lines = code.split("\n");
	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));
	if (tabbed.length === 0 && spaced.length === 0) return null;
	if (tabbed.length >= spaced.length) return "	";
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);
	return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);
	fromParts.pop();
	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}
	if (fromParts.length) {
		let i$1 = fromParts.length;
		while (i$1--) fromParts[i$1] = "..";
	}
	return fromParts.concat(toParts).join("/");
}
const toString = Object.prototype.toString;
function isObject(thing) {
	return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
	const originalLines = source.split("\n");
	const lineOffsets = [];
	for (let i$1 = 0, pos = 0; i$1 < originalLines.length; i$1++) {
		lineOffsets.push(pos);
		pos += originalLines[i$1].length + 1;
	}
	return function locate(index) {
		let i$1 = 0;
		let j = lineOffsets.length;
		while (i$1 < j) {
			const m = i$1 + j >> 1;
			if (index < lineOffsets[m]) j = m;
			else i$1 = m + 1;
		}
		const line = i$1 - 1;
		return {
			line,
			column: index - lineOffsets[line]
		};
	};
}
const wordRegex = /\w/;
var Mappings = class {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}
	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf("\n", 0);
			let previousContentLineEnd = -1;
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment$1 = [
					this.generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column
				];
				if (nameIndex >= 0) segment$1.push(nameIndex);
				this.rawSegments.push(segment$1);
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
			}
			const segment = [
				this.generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column
			];
			if (nameIndex >= 0) segment.push(nameIndex);
			this.rawSegments.push(segment);
			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}
		this.pending = null;
	}
	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		let charInHiresBoundary = false;
		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === "\n") {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
				charInHiresBoundary = false;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [
						this.generatedCodeColumn,
						sourceIndex,
						loc.line,
						loc.column
					];
					if (this.hires === "boundary") if (wordRegex.test(original[originalCharIndex])) {
						if (!charInHiresBoundary) {
							this.rawSegments.push(segment);
							charInHiresBoundary = true;
						}
					} else {
						this.rawSegments.push(segment);
						charInHiresBoundary = false;
					}
					else this.rawSegments.push(segment);
				}
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}
			originalCharIndex += 1;
		}
		this.pending = null;
	}
	advance(str) {
		if (!str) return;
		const lines = str.split("\n");
		if (lines.length > 1) {
			for (let i$1 = 0; i$1 < lines.length - 1; i$1++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}
		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
};
const n = "\n";
const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};
var MagicString = class MagicString {
	constructor(string, options = {}) {
		const chunk = new Chunk(0, string.length, string);
		Object.defineProperties(this, {
			original: {
				writable: true,
				value: string
			},
			outro: {
				writable: true,
				value: ""
			},
			intro: {
				writable: true,
				value: ""
			},
			firstChunk: {
				writable: true,
				value: chunk
			},
			lastChunk: {
				writable: true,
				value: chunk
			},
			lastSearchedChunk: {
				writable: true,
				value: chunk
			},
			byStart: {
				writable: true,
				value: {}
			},
			byEnd: {
				writable: true,
				value: {}
			},
			filename: {
				writable: true,
				value: options.filename
			},
			indentExclusionRanges: {
				writable: true,
				value: options.indentExclusionRanges
			},
			sourcemapLocations: {
				writable: true,
				value: new BitSet()
			},
			storedNames: {
				writable: true,
				value: {}
			},
			indentStr: {
				writable: true,
				value: void 0
			},
			ignoreList: {
				writable: true,
				value: options.ignoreList
			},
			offset: {
				writable: true,
				value: options.offset || 0
			}
		});
		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}
	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}
	append(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.outro += content;
		return this;
	}
	appendLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.appendLeft(content);
		else this.intro += content;
		return this;
	}
	appendRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.appendRight(content);
		else this.outro += content;
		return this;
	}
	clone() {
		const cloned = new MagicString(this.original, {
			filename: this.filename,
			offset: this.offset
		});
		let originalChunk = this.firstChunk;
		let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;
			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;
				clonedChunk = nextClonedChunk;
			}
			originalChunk = nextOriginalChunk;
		}
		cloned.lastChunk = clonedChunk;
		if (this.indentExclusionRanges) cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
		cloned.intro = this.intro;
		cloned.outro = this.outro;
		return cloned;
	}
	generateDecodedMap(options) {
		options = options || {};
		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);
		const locate = getLocator(this.original);
		if (this.intro) mappings.advance(this.intro);
		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);
			if (chunk.intro.length) mappings.advance(chunk.intro);
			if (chunk.edited) mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
			else mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			if (chunk.outro.length) mappings.advance(chunk.outro);
		});
		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
			sources: [options.source ? getRelativePath(options.file || "", options.source) : options.file || ""],
			sourcesContent: options.includeContent ? [this.original] : void 0,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
		};
	}
	generateMap(options) {
		return new SourceMap(this.generateDecodedMap(options));
	}
	_ensureindentStr() {
		if (this.indentStr === void 0) this.indentStr = guessIndent(this.original);
	}
	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}
	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? "	" : this.indentStr;
	}
	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;
		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = void 0;
		}
		if (indentStr === void 0) {
			this._ensureindentStr();
			indentStr = this.indentStr || "	";
		}
		if (indentStr === "") return this;
		options = options || {};
		const isExcluded = {};
		if (options.exclude) (typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude).forEach((exclusion) => {
			for (let i$1 = exclusion[0]; i$1 < exclusion[1]; i$1 += 1) isExcluded[i$1] = true;
		});
		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};
		this.intro = this.intro.replace(pattern, replacer);
		let charIndex = 0;
		let chunk = this.firstChunk;
		while (chunk) {
			const end = chunk.end;
			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);
					if (chunk.content.length) shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
				}
			} else {
				charIndex = chunk.start;
				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];
						if (char === "\n") shouldIndentNextCharacter = true;
						else if (char !== "\r" && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;
							if (charIndex === chunk.start) chunk.prependRight(indentStr);
							else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}
					charIndex += 1;
				}
			}
			charIndex = chunk.end;
			chunk = chunk.next;
		}
		this.outro = this.outro.replace(pattern, replacer);
		return this;
	}
	insert() {
		throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
	}
	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
			warned.insertLeft = true;
		}
		return this.appendLeft(index, content);
	}
	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
			warned.insertRight = true;
		}
		return this.prependRight(index, content);
	}
	move(start, end, index) {
		start = start + this.offset;
		end = end + this.offset;
		index = index + this.offset;
		if (index >= start && index <= end) throw new Error("Cannot move a selection inside itself");
		this._split(start);
		this._split(end);
		this._split(index);
		const first = this.byStart[start];
		const last = this.byEnd[end];
		const oldLeft = first.previous;
		const oldRight = last.next;
		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;
		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;
		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;
		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}
		first.previous = newLeft;
		last.next = newRight || null;
		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}
	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, {
			...options,
			overwrite: !options.contentOnly
		});
	}
	update(start, end, content, options) {
		start = start + this.offset;
		end = end + this.offset;
		if (typeof content !== "string") throw new TypeError("replacement content must be a string");
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (end > this.original.length) throw new Error("end is out of bounds");
		if (start === end) throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");
		this._split(start);
		this._split(end);
		if (options === true) {
			if (!warned.storeName) {
				console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
				warned.storeName = true;
			}
			options = { storeName: true };
		}
		const storeName = options !== void 0 ? options.storeName : false;
		const overwrite = options !== void 0 ? options.overwrite : false;
		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true
			});
		}
		const first = this.byStart[start];
		const last = this.byEnd[end];
		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) throw new Error("Cannot overwrite across a split point");
				chunk = chunk.next;
				chunk.edit("", false);
			}
			first.edit(content, storeName, !overwrite);
		} else {
			const newChunk = new Chunk(start, end, "").edit(content, storeName);
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}
	prepend(content) {
		if (typeof content !== "string") throw new TypeError("outro content must be a string");
		this.intro = content + this.intro;
		return this;
	}
	prependLeft(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byEnd[index];
		if (chunk) chunk.prependLeft(content);
		else this.intro = content + this.intro;
		return this;
	}
	prependRight(index, content) {
		index = index + this.offset;
		if (typeof content !== "string") throw new TypeError("inserted content must be a string");
		this._split(index);
		const chunk = this.byStart[index];
		if (chunk) chunk.prependRight(content);
		else this.outro = content + this.outro;
		return this;
	}
	remove(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.intro = "";
			chunk.outro = "";
			chunk.edit("");
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	reset(start, end) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		if (start === end) return this;
		if (start < 0 || end > this.original.length) throw new Error("Character is out of bounds");
		if (start > end) throw new Error("end must be greater than start");
		this._split(start);
		this._split(end);
		let chunk = this.byStart[start];
		while (chunk) {
			chunk.reset();
			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}
	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while (chunk = chunk.previous);
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return "";
	}
	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}
			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}
			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while (chunk = chunk.previous);
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}
	slice(start = 0, end = this.original.length - this.offset) {
		start = start + this.offset;
		end = end + this.offset;
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}
		let result = "";
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			if (chunk.start < end && chunk.end >= end) return result;
			chunk = chunk.next;
		}
		if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) result += chunk.intro;
			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
			result += chunk.content.slice(sliceStart, sliceEnd);
			if (chunk.outro && (!containsEnd || chunk.end === end)) result += chunk.outro;
			if (containsEnd) break;
			chunk = chunk.next;
		}
		return result;
	}
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);
		return clone;
	}
	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;
		let chunk = this.lastSearchedChunk;
		const searchForward = index > chunk.end;
		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);
			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	}
	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			const loc = getLocator(this.original)(index);
			throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`);
		}
		const newChunk = chunk.split(index);
		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;
		if (chunk === this.lastChunk) this.lastChunk = newChunk;
		this.lastSearchedChunk = chunk;
		return true;
	}
	toString() {
		let str = this.intro;
		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}
		return str + this.outro;
	}
	isEmpty() {
		let chunk = this.firstChunk;
		do
			if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
		while (chunk = chunk.next);
		return true;
	}
	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		while (chunk = chunk.next);
		return length;
	}
	trimLines() {
		return this.trim("[\\r\\n]");
	}
	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}
	trimEndAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp((charType || "\\s") + "+$");
		this.outro = this.outro.replace(rx, "");
		if (this.outro.length) return true;
		let chunk = this.lastChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);
		return false;
	}
	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = /* @__PURE__ */ new RegExp("^" + (charType || "\\s") + "+");
		this.intro = this.intro.replace(rx, "");
		if (this.intro.length) return true;
		let chunk = this.firstChunk;
		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);
			if (chunk.end !== end) {
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;
				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}
			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);
		return false;
	}
	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}
	hasChanged() {
		return this.original !== this.toString();
	}
	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === "string") return replacement.replace(/\$(\$|&|\d+)/g, (_, i$1) => {
				if (i$1 === "$") return "$";
				if (i$1 === "&") return match[0];
				if (+i$1 < match.length) return match[+i$1];
				return `$${i$1}`;
			});
			else return replacement(...match, match.index, str, match.groups);
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while (match = re.exec(str)) matches.push(match);
			return matches;
		}
		if (searchValue.global) matchAll(searchValue, this.original).forEach((match) => {
			if (match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		});
		else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement$1 = getReplacement(match, this.original);
				if (replacement$1 !== match[0]) this.overwrite(match.index, match.index + match[0].length, replacement$1);
			}
		}
		return this;
	}
	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);
		if (index !== -1) this.overwrite(index, index + string.length, replacement);
		return this;
	}
	replace(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceString(searchValue, replacement);
		return this._replaceRegexp(searchValue, replacement);
	}
	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) if (original.slice(index, index + stringLength) !== replacement) this.overwrite(index, index + stringLength, replacement);
		return this;
	}
	replaceAll(searchValue, replacement) {
		if (typeof searchValue === "string") return this._replaceAllString(searchValue, replacement);
		if (!searchValue.global) throw new TypeError("MagicString.prototype.replaceAll called with a non-global RegExp argument");
		return this._replaceRegexp(searchValue, replacement);
	}
};

//#endregion
//#region src/plugins/additional-modules.ts
/**
* Plugin to support additional module types (`CompiledWasm`, `Data` and `Text`)
*/
const additionalModulesPlugin = createPlugin("additional-modules", (ctx) => {
	const additionalModulePaths = /* @__PURE__ */ new Set();
	return {
		enforce: "pre",
		applyToEnvironment(environment) {
			return ctx.getWorkerConfig(environment.name) !== void 0;
		},
		async resolveId(source, importer, options) {
			const additionalModuleType = matchAdditionalModule(source);
			if (!additionalModuleType) return;
			const resolved = await this.resolve(cleanUrl(source), importer, options);
			if (!resolved) throw new Error(`Import "${source}" not found. Does the file exist?`);
			additionalModulePaths.add(resolved.id);
			return {
				external: true,
				id: createModuleReference(additionalModuleType, resolved.id)
			};
		},
		hotUpdate(options) {
			if (additionalModulePaths.has(options.file)) {
				options.server.restart();
				return [];
			}
		},
		async renderChunk(code, chunk) {
			const matches = code.matchAll(additionalModuleGlobalRE);
			let magicString;
			for (const match of matches) {
				magicString ??= new MagicString(code);
				const [full, _, modulePath] = match;
				assert(modulePath, `Unexpected error: module path not found in reference ${full}.`);
				let source;
				try {
					source = await fsp.readFile(modulePath);
				} catch (error) {
					throw new Error(`Import "${modulePath}" not found. Does the file exist?`);
				}
				const referenceId = this.emitFile({
					type: "asset",
					name: path$2.basename(modulePath),
					originalFileName: modulePath,
					source
				});
				const emittedFileName = this.getFileName(referenceId);
				const relativePath = vite.normalizePath(path$2.relative(path$2.dirname(chunk.fileName), emittedFileName));
				const importPath = relativePath.startsWith(".") ? relativePath : `./${relativePath}`;
				magicString.update(match.index, match.index + full.length, importPath);
			}
			if (magicString) return {
				code: magicString.toString(),
				map: this.environment.config.build.sourcemap ? magicString.generateMap({ hires: "boundary" }) : null
			};
		}
	};
});
const ADDITIONAL_MODULE_PATTERN = `__CLOUDFLARE_MODULE__(${[
	"CompiledWasm",
	"Data",
	"Text"
].join("|")})__(.*?)__CLOUDFLARE_MODULE__`;
const additionalModuleRE = new RegExp(ADDITIONAL_MODULE_PATTERN);
const additionalModuleGlobalRE = new RegExp(ADDITIONAL_MODULE_PATTERN, "g");
const moduleRules = [
	{
		type: "CompiledWasm",
		extensions: [".wasm", ".wasm?module"]
	},
	{
		type: "Data",
		extensions: [".bin"]
	},
	{
		type: "Text",
		extensions: [".txt", ".html"]
	}
];
function matchAdditionalModule(source) {
	for (const rule of moduleRules) for (const extension of rule.extensions) if (source.endsWith(extension)) return rule.type;
	return null;
}
function createModuleReference(type, id) {
	return `__CLOUDFLARE_MODULE__${type}__${id}__CLOUDFLARE_MODULE__`;
}

//#endregion
//#region ../workers-shared/utils/configuration/constructConfiguration.ts
function constructRedirects({ redirects, redirectsFile, logger }) {
	if (!redirects) return {};
	const num_valid = redirects.rules.length;
	const num_invalid = redirects.invalid.length;
	const redirectsRelativePath = redirectsFile ? relative(process.cwd(), redirectsFile) : "";
	logger.log(`✨ Parsed ${num_valid} valid redirect rule${num_valid === 1 ? "" : "s"}.`);
	if (num_invalid > 0) {
		let invalidRedirectRulesList = ``;
		for (const { line, lineNumber, message } of redirects.invalid) {
			invalidRedirectRulesList += `▶︎ ${message}\n`;
			if (line) invalidRedirectRulesList += `    at ${redirectsRelativePath}${lineNumber ? `:${lineNumber}` : ""} | ${line}\n\n`;
		}
		logger.warn(`Found ${num_invalid} invalid redirect rule${num_invalid === 1 ? "" : "s"}:\n${invalidRedirectRulesList}`);
	}
	if (num_valid === 0) return {};
	const staticRedirects = {};
	const dynamicRedirects = {};
	let canCreateStaticRule = true;
	for (const rule of redirects.rules) {
		if (!rule.from.match(SPLAT_REGEX) && !rule.from.match(PLACEHOLDER_REGEX)) if (canCreateStaticRule) {
			staticRedirects[rule.from] = {
				status: rule.status,
				to: rule.to,
				lineNumber: rule.lineNumber
			};
			continue;
		} else logger.info(`The redirect rule ${rule.from} → ${rule.status} ${rule.to} could be made more performant by bringing it above any lines with splats or placeholders.`);
		dynamicRedirects[rule.from] = {
			status: rule.status,
			to: rule.to
		};
		canCreateStaticRule = false;
	}
	return { redirects: {
		version: REDIRECTS_VERSION,
		staticRules: staticRedirects,
		rules: dynamicRedirects
	} };
}
function constructHeaders({ headers, headersFile, logger }) {
	if (!headers) return {};
	const num_valid = headers.rules.length;
	const num_invalid = headers.invalid.length;
	const headersRelativePath = headersFile ? relative(process.cwd(), headersFile) : "";
	logger.log(`✨ Parsed ${num_valid} valid header rule${num_valid === 1 ? "" : "s"}.`);
	if (num_invalid > 0) {
		let invalidHeaderRulesList = ``;
		for (const { line, lineNumber, message } of headers.invalid) {
			invalidHeaderRulesList += `▶︎ ${message}\n`;
			if (line) invalidHeaderRulesList += `    at ${headersRelativePath}${lineNumber ? `:${lineNumber}` : ""} | ${line}\n\n`;
		}
		logger.warn(`Found ${num_invalid} invalid header rule${num_invalid === 1 ? "" : "s"}:\n${invalidHeaderRulesList}`);
	}
	if (num_valid === 0) return {};
	const rules = {};
	for (const rule of headers.rules) {
		const configuredRule = {};
		if (Object.keys(rule.headers).length) configuredRule.set = rule.headers;
		if (rule.unsetHeaders.length) configuredRule.unset = rule.unsetHeaders;
		rules[rule.path] = configuredRule;
	}
	return { headers: {
		version: HEADERS_VERSION,
		rules
	} };
}

//#endregion
//#region ../workers-shared/utils/configuration/validateURL.ts
const extractPathname = (path$3 = "/", includeSearch, includeHash) => {
	if (!path$3.startsWith("/")) path$3 = `/${path$3}`;
	const url = new URL(`//${path$3}`, "relative://");
	return `${url.pathname}${includeSearch ? url.search : ""}${includeHash ? url.hash : ""}`;
};
const URL_REGEX = /^https:\/\/+(?<host>[^/]+)\/?(?<path>.*)/;
const HOST_WITH_PORT_REGEX = /.*:\d+$/;
const PATH_REGEX = /^\//;
const validateUrl = (token, onlyRelative = false, disallowPorts = false, includeSearch = false, includeHash = false) => {
	const host = URL_REGEX.exec(token);
	if (host && host.groups && host.groups.host) {
		if (onlyRelative) return [void 0, `Only relative URLs are allowed. Skipping absolute URL ${token}.`];
		if (disallowPorts && host.groups.host.match(HOST_WITH_PORT_REGEX)) return [void 0, `Specifying ports is not supported. Skipping absolute URL ${token}.`];
		return [`https://${host.groups.host}${extractPathname(host.groups.path, includeSearch, includeHash)}`, void 0];
	} else {
		if (!token.startsWith("/") && onlyRelative) token = `/${token}`;
		if (PATH_REGEX.exec(token)) try {
			return [extractPathname(token, includeSearch, includeHash), void 0];
		} catch {
			return [void 0, `Error parsing URL segment ${token}. Skipping.`];
		}
	}
	return [void 0, onlyRelative ? "URLs should begin with a forward-slash." : "URLs should either be relative (e.g. begin with a forward-slash), or use HTTPS (e.g. begin with \"https://\")."];
};
function urlHasHost(token) {
	const host = URL_REGEX.exec(token);
	return Boolean(host && host.groups && host.groups.host);
}

//#endregion
//#region ../workers-shared/utils/configuration/parseHeaders.ts
const LINE_IS_PROBABLY_A_PATH = /* @__PURE__ */ new RegExp(/^([^\s]+:\/\/|^\/)/);
function parseHeaders(input, { maxRules = MAX_HEADER_RULES, maxLineLength = MAX_LINE_LENGTH } = {}) {
	const lines = input.split("\n");
	const rules = [];
	const invalid = [];
	let rule = void 0;
	for (let i$1 = 0; i$1 < lines.length; i$1++) {
		const line = (lines[i$1] || "").trim();
		if (line.length === 0 || line.startsWith("#")) continue;
		if (line.length > maxLineLength) {
			invalid.push({ message: `Ignoring line ${i$1 + 1} as it exceeds the maximum allowed length of ${maxLineLength}.` });
			continue;
		}
		if (LINE_IS_PROBABLY_A_PATH.test(line)) {
			if (rules.length >= maxRules) {
				invalid.push({ message: `Maximum number of rules supported is ${maxRules}. Skipping remaining ${lines.length - i$1} lines of file.` });
				break;
			}
			if (rule) if (isValidRule(rule)) rules.push({
				path: rule.path,
				headers: rule.headers,
				unsetHeaders: rule.unsetHeaders
			});
			else invalid.push({
				line: rule.line,
				lineNumber: i$1 + 1,
				message: "No headers specified"
			});
			const [path$3, pathError] = validateUrl(line, false, true);
			if (pathError) {
				invalid.push({
					line,
					lineNumber: i$1 + 1,
					message: pathError
				});
				rule = void 0;
				continue;
			}
			rule = {
				path: path$3,
				line,
				headers: {},
				unsetHeaders: []
			};
			continue;
		}
		if (!line.includes(HEADER_SEPARATOR)) {
			if (!rule) invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "Expected a path beginning with at least one forward-slash"
			});
			else if (line.trim().startsWith(UNSET_OPERATOR)) rule.unsetHeaders.push(line.trim().replace(UNSET_OPERATOR, ""));
			else invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "Expected a colon-separated header pair (e.g. name: value)"
			});
			continue;
		}
		const [rawName, ...rawValue] = line.split(HEADER_SEPARATOR);
		const name = (rawName || "").trim().toLowerCase();
		if (name.includes(" ")) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "Header name cannot include spaces"
			});
			continue;
		}
		const value = rawValue.join(HEADER_SEPARATOR).trim();
		if (name === "") {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "No header name specified"
			});
			continue;
		}
		if (value === "") {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "No header value specified"
			});
			continue;
		}
		if (!rule) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: `Path should come before header (${name}: ${value})`
			});
			continue;
		}
		const existingValues = rule.headers[name];
		rule.headers[name] = existingValues ? `${existingValues}, ${value}` : value;
	}
	if (rule) if (isValidRule(rule)) rules.push({
		path: rule.path,
		headers: rule.headers,
		unsetHeaders: rule.unsetHeaders
	});
	else invalid.push({
		line: rule.line,
		message: "No headers specified"
	});
	return {
		rules,
		invalid
	};
}
function isValidRule(rule) {
	return Object.keys(rule.headers).length > 0 || rule.unsetHeaders.length > 0;
}

//#endregion
//#region ../workers-shared/utils/configuration/parseRedirects.ts
function parseRedirects(input, { maxStaticRules = MAX_STATIC_REDIRECT_RULES, maxDynamicRules = MAX_DYNAMIC_REDIRECT_RULES, maxLineLength = MAX_LINE_LENGTH } = {}) {
	const lines = input.split("\n");
	const rules = [];
	const seen_paths = /* @__PURE__ */ new Set();
	const invalid = [];
	let staticRules = 0;
	let dynamicRules = 0;
	let canCreateStaticRule = true;
	for (let i$1 = 0; i$1 < lines.length; i$1++) {
		const line = (lines[i$1] || "").trim();
		if (line.length === 0 || line.startsWith("#")) continue;
		if (line.length > maxLineLength) {
			invalid.push({ message: `Ignoring line ${i$1 + 1} as it exceeds the maximum allowed length of ${maxLineLength}.` });
			continue;
		}
		const tokens = line.split(/\s+/);
		if (tokens.length < 2 || tokens.length > 3) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: `Expected exactly 2 or 3 whitespace-separated tokens. Got ${tokens.length}.`
			});
			continue;
		}
		const [str_from, str_to, str_status = "302"] = tokens;
		const fromResult = validateUrl(str_from, true, true, false, false);
		if (fromResult[0] === void 0) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: fromResult[1]
			});
			continue;
		}
		const from = fromResult[0];
		if (canCreateStaticRule && !from.match(SPLAT_REGEX) && !from.match(PLACEHOLDER_REGEX)) {
			staticRules += 1;
			if (staticRules > maxStaticRules) {
				invalid.push({ message: `Maximum number of static rules supported is ${maxStaticRules}. Skipping line.` });
				continue;
			}
		} else {
			dynamicRules += 1;
			canCreateStaticRule = false;
			if (dynamicRules > maxDynamicRules) {
				invalid.push({ message: `Maximum number of dynamic rules supported is ${maxDynamicRules}. Skipping remaining ${lines.length - i$1} lines of file.` });
				break;
			}
		}
		const toResult = validateUrl(str_to, false, false, true, true);
		if (toResult[0] === void 0) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: toResult[1]
			});
			continue;
		}
		const to = toResult[0];
		const status = Number(str_status);
		if (isNaN(status) || !PERMITTED_STATUS_CODES.has(status)) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: `Valid status codes are 200, 301, 302 (default), 303, 307, or 308. Got ${str_status}.`
			});
			continue;
		}
		if (/\/\*?$/.test(from) && /\/index(.html)?$/.test(to) && !urlHasHost(to)) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: "Infinite loop detected in this rule and has been ignored. This will cause a redirect to strip `.html` or `/index` and end up triggering this rule again. Please fix or remove this rule to silence this warning."
			});
			continue;
		}
		if (seen_paths.has(from)) {
			invalid.push({
				line,
				lineNumber: i$1 + 1,
				message: `Ignoring duplicate rule for path ${from}.`
			});
			continue;
		}
		seen_paths.add(from);
		if (status === 200) {
			if (urlHasHost(to)) {
				invalid.push({
					line,
					lineNumber: i$1 + 1,
					message: `Proxy (200) redirects can only point to relative paths. Got ${to}`
				});
				continue;
			}
		}
		rules.push({
			from,
			to,
			status,
			lineNumber: i$1 + 1
		});
	}
	return {
		rules,
		invalid
	};
}

//#endregion
//#region ../workers-shared/utils/constants.ts
/** manifest = [HEADER, [ entry = PATH_HASH, CONTENT_HASH, TAIL], [entry], ... , [entry] ] */
const PATH_HASH_SIZE = 16;
/** manifest = [HEADER, [ entry = PATH_HASH, CONTENT_HASH, TAIL], [entry], ... , [entry] ] */
const CONTENT_HASH_SIZE = 16;
/** manifest = [HEADER, [ entry = PATH_HASH, CONTENT_HASH, TAIL], [entry], ... , [entry] ] */
const TAIL_SIZE = 8;
/** manifest = [HEADER, [ entry = PATH_HASH, CONTENT_HASH, TAIL], [entry], ... , [entry] ] */
const ENTRY_SIZE = PATH_HASH_SIZE + CONTENT_HASH_SIZE + TAIL_SIZE;
/** Maximum size per asset that can be deployed with a Worker */
const MAX_ASSET_SIZE = 25 * 1024 * 1024;
const REDIRECTS_FILENAME = "_redirects";
const HEADERS_FILENAME = "_headers";

//#endregion
//#region ../../node_modules/.pnpm/ignore@5.3.1/node_modules/ignore/index.js
var require_ignore = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/ignore@5.3.1/node_modules/ignore/index.js": ((exports, module) => {
	function makeArray(subject) {
		return Array.isArray(subject) ? subject : [subject];
	}
	const EMPTY = "";
	const SPACE = " ";
	const ESCAPE = "\\";
	const REGEX_TEST_BLANK_LINE = /^\s+$/;
	const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
	const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
	const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
	const REGEX_SPLITALL_CRLF = /\r?\n/g;
	const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
	const SLASH = "/";
	let TMP_KEY_IGNORE = "node-ignore";
	/* istanbul ignore else */
	if (typeof Symbol !== "undefined") TMP_KEY_IGNORE = Symbol.for("node-ignore");
	const KEY_IGNORE = TMP_KEY_IGNORE;
	const define = (object, key, value) => Object.defineProperty(object, key, { value });
	const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
	const RETURN_FALSE = () => false;
	const sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
	const cleanRangeBackSlash = (slashes) => {
		const { length } = slashes;
		return slashes.slice(0, length - length % 2);
	};
	const REPLACERS = [
		[/^\uFEFF/, () => EMPTY],
		[/\\?\s+$/, (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY],
		[/\\\s/g, () => SPACE],
		[/[\\$.|*+(){^]/g, (match) => `\\${match}`],
		[/(?!\\)\?/g, () => "[^/]"],
		[/^\//, () => "^"],
		[/\//g, () => "\\/"],
		[/^\^*\\\*\\\*\\\//, () => "^(?:.*\\/)?"],
		[/^(?=[^^])/, function startingReplacer() {
			return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
		}],
		[/\\\/\\\*\\\*(?=\\\/|$)/g, (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"],
		[/(^|[^\\]+)(\\\*)+(?=.+)/g, (_, p1, p2) => {
			return p1 + p2.replace(/\\\*/g, "[^\\/]*");
		}],
		[/\\\\\\(?=[$.|*+(){^])/g, () => ESCAPE],
		[/\\\\/g, () => ESCAPE],
		[/(\\)?\[([^\]/]*?)(\\*)($|\])/g, (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"],
		[/(?:[^*])$/, (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`],
		[/(\^|\\\/)?\\\*$/, (_, p1) => {
			return `${p1 ? `${p1}[^/]+` : "[^/]*"}(?=$|\\/$)`;
		}]
	];
	const regexCache = Object.create(null);
	const makeRegex = (pattern, ignoreCase) => {
		let source = regexCache[pattern];
		if (!source) {
			source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
			regexCache[pattern] = source;
		}
		return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
	};
	const isString$1 = (subject) => typeof subject === "string";
	const checkPattern = (pattern) => pattern && isString$1(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
	const splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
	var IgnoreRule = class {
		constructor(origin, pattern, negative, regex) {
			this.origin = origin;
			this.pattern = pattern;
			this.negative = negative;
			this.regex = regex;
		}
	};
	const createRule = (pattern, ignoreCase) => {
		const origin = pattern;
		let negative = false;
		if (pattern.indexOf("!") === 0) {
			negative = true;
			pattern = pattern.substr(1);
		}
		pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
		const regex = makeRegex(pattern, ignoreCase);
		return new IgnoreRule(origin, pattern, negative, regex);
	};
	const throwError = (message, Ctor) => {
		throw new Ctor(message);
	};
	const checkPath = (path$3, originalPath, doThrow) => {
		if (!isString$1(path$3)) return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
		if (!path$3) return doThrow(`path must not be empty`, TypeError);
		if (checkPath.isNotRelative(path$3)) return doThrow(`path should be a \`path.relative()\`d string, but got "${originalPath}"`, RangeError);
		return true;
	};
	const isNotRelative = (path$3) => REGEX_TEST_INVALID_PATH.test(path$3);
	checkPath.isNotRelative = isNotRelative;
	checkPath.convert = (p) => p;
	var Ignore = class {
		constructor({ ignorecase = true, ignoreCase = ignorecase, allowRelativePaths = false } = {}) {
			define(this, KEY_IGNORE, true);
			this._rules = [];
			this._ignoreCase = ignoreCase;
			this._allowRelativePaths = allowRelativePaths;
			this._initCache();
		}
		_initCache() {
			this._ignoreCache = Object.create(null);
			this._testCache = Object.create(null);
		}
		_addPattern(pattern) {
			if (pattern && pattern[KEY_IGNORE]) {
				this._rules = this._rules.concat(pattern._rules);
				this._added = true;
				return;
			}
			if (checkPattern(pattern)) {
				const rule = createRule(pattern, this._ignoreCase);
				this._added = true;
				this._rules.push(rule);
			}
		}
		add(pattern) {
			this._added = false;
			makeArray(isString$1(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
			if (this._added) this._initCache();
			return this;
		}
		addPattern(pattern) {
			return this.add(pattern);
		}
		_testOne(path$3, checkUnignored) {
			let ignored = false;
			let unignored = false;
			this._rules.forEach((rule) => {
				const { negative } = rule;
				if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) return;
				if (rule.regex.test(path$3)) {
					ignored = !negative;
					unignored = negative;
				}
			});
			return {
				ignored,
				unignored
			};
		}
		_test(originalPath, cache$1, checkUnignored, slices) {
			const path$3 = originalPath && checkPath.convert(originalPath);
			checkPath(path$3, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
			return this._t(path$3, cache$1, checkUnignored, slices);
		}
		_t(path$3, cache$1, checkUnignored, slices) {
			if (path$3 in cache$1) return cache$1[path$3];
			if (!slices) slices = path$3.split(SLASH);
			slices.pop();
			if (!slices.length) return cache$1[path$3] = this._testOne(path$3, checkUnignored);
			const parent = this._t(slices.join(SLASH) + SLASH, cache$1, checkUnignored, slices);
			return cache$1[path$3] = parent.ignored ? parent : this._testOne(path$3, checkUnignored);
		}
		ignores(path$3) {
			return this._test(path$3, this._ignoreCache, false).ignored;
		}
		createFilter() {
			return (path$3) => !this.ignores(path$3);
		}
		filter(paths) {
			return makeArray(paths).filter(this.createFilter());
		}
		test(path$3) {
			return this._test(path$3, this._testCache, true);
		}
	};
	const factory = (options) => new Ignore(options);
	const isPathValid = (path$3) => checkPath(path$3 && checkPath.convert(path$3), path$3, RETURN_FALSE);
	factory.isPathValid = isPathValid;
	factory.default = factory;
	module.exports = factory;
	/* istanbul ignore if */
	if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
		const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
		checkPath.convert = makePosix;
		const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
		checkPath.isNotRelative = (path$3) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path$3) || isNotRelative(path$3);
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/mime@4.0.7/node_modules/mime/dist/types/other.js
var import_ignore = /* @__PURE__ */ __toESM(require_ignore());
const types$1 = {
	"application/prs.cww": ["cww"],
	"application/prs.xsf+xml": ["xsf"],
	"application/vnd.1000minds.decision-model+xml": ["1km"],
	"application/vnd.3gpp.pic-bw-large": ["plb"],
	"application/vnd.3gpp.pic-bw-small": ["psb"],
	"application/vnd.3gpp.pic-bw-var": ["pvb"],
	"application/vnd.3gpp2.tcap": ["tcap"],
	"application/vnd.3m.post-it-notes": ["pwn"],
	"application/vnd.accpac.simply.aso": ["aso"],
	"application/vnd.accpac.simply.imp": ["imp"],
	"application/vnd.acucobol": ["acu"],
	"application/vnd.acucorp": ["atc", "acutc"],
	"application/vnd.adobe.air-application-installer-package+zip": ["air"],
	"application/vnd.adobe.formscentral.fcdt": ["fcdt"],
	"application/vnd.adobe.fxp": ["fxp", "fxpl"],
	"application/vnd.adobe.xdp+xml": ["xdp"],
	"application/vnd.adobe.xfdf": ["*xfdf"],
	"application/vnd.age": ["age"],
	"application/vnd.ahead.space": ["ahead"],
	"application/vnd.airzip.filesecure.azf": ["azf"],
	"application/vnd.airzip.filesecure.azs": ["azs"],
	"application/vnd.amazon.ebook": ["azw"],
	"application/vnd.americandynamics.acc": ["acc"],
	"application/vnd.amiga.ami": ["ami"],
	"application/vnd.android.package-archive": ["apk"],
	"application/vnd.anser-web-certificate-issue-initiation": ["cii"],
	"application/vnd.anser-web-funds-transfer-initiation": ["fti"],
	"application/vnd.antix.game-component": ["atx"],
	"application/vnd.apple.installer+xml": ["mpkg"],
	"application/vnd.apple.keynote": ["key"],
	"application/vnd.apple.mpegurl": ["m3u8"],
	"application/vnd.apple.numbers": ["numbers"],
	"application/vnd.apple.pages": ["pages"],
	"application/vnd.apple.pkpass": ["pkpass"],
	"application/vnd.aristanetworks.swi": ["swi"],
	"application/vnd.astraea-software.iota": ["iota"],
	"application/vnd.audiograph": ["aep"],
	"application/vnd.autodesk.fbx": ["fbx"],
	"application/vnd.balsamiq.bmml+xml": ["bmml"],
	"application/vnd.blueice.multipass": ["mpm"],
	"application/vnd.bmi": ["bmi"],
	"application/vnd.businessobjects": ["rep"],
	"application/vnd.chemdraw+xml": ["cdxml"],
	"application/vnd.chipnuts.karaoke-mmd": ["mmd"],
	"application/vnd.cinderella": ["cdy"],
	"application/vnd.citationstyles.style+xml": ["csl"],
	"application/vnd.claymore": ["cla"],
	"application/vnd.cloanto.rp9": ["rp9"],
	"application/vnd.clonk.c4group": [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	],
	"application/vnd.cluetrust.cartomobile-config": ["c11amc"],
	"application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
	"application/vnd.commonspace": ["csp"],
	"application/vnd.contact.cmsg": ["cdbcmsg"],
	"application/vnd.cosmocaller": ["cmc"],
	"application/vnd.crick.clicker": ["clkx"],
	"application/vnd.crick.clicker.keyboard": ["clkk"],
	"application/vnd.crick.clicker.palette": ["clkp"],
	"application/vnd.crick.clicker.template": ["clkt"],
	"application/vnd.crick.clicker.wordbank": ["clkw"],
	"application/vnd.criticaltools.wbs+xml": ["wbs"],
	"application/vnd.ctc-posml": ["pml"],
	"application/vnd.cups-ppd": ["ppd"],
	"application/vnd.curl.car": ["car"],
	"application/vnd.curl.pcurl": ["pcurl"],
	"application/vnd.dart": ["dart"],
	"application/vnd.data-vision.rdz": ["rdz"],
	"application/vnd.dbf": ["dbf"],
	"application/vnd.dcmp+xml": ["dcmp"],
	"application/vnd.dece.data": [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	],
	"application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
	"application/vnd.dece.unspecified": ["uvx", "uvvx"],
	"application/vnd.dece.zip": ["uvz", "uvvz"],
	"application/vnd.denovo.fcselayout-link": ["fe_launch"],
	"application/vnd.dna": ["dna"],
	"application/vnd.dolby.mlp": ["mlp"],
	"application/vnd.dpgraph": ["dpg"],
	"application/vnd.dreamfactory": ["dfac"],
	"application/vnd.ds-keypoint": ["kpxx"],
	"application/vnd.dvb.ait": ["ait"],
	"application/vnd.dvb.service": ["svc"],
	"application/vnd.dynageo": ["geo"],
	"application/vnd.ecowin.chart": ["mag"],
	"application/vnd.enliven": ["nml"],
	"application/vnd.epson.esf": ["esf"],
	"application/vnd.epson.msf": ["msf"],
	"application/vnd.epson.quickanime": ["qam"],
	"application/vnd.epson.salt": ["slt"],
	"application/vnd.epson.ssf": ["ssf"],
	"application/vnd.eszigno3+xml": ["es3", "et3"],
	"application/vnd.ezpix-album": ["ez2"],
	"application/vnd.ezpix-package": ["ez3"],
	"application/vnd.fdf": ["*fdf"],
	"application/vnd.fdsn.mseed": ["mseed"],
	"application/vnd.fdsn.seed": ["seed", "dataless"],
	"application/vnd.flographit": ["gph"],
	"application/vnd.fluxtime.clip": ["ftc"],
	"application/vnd.framemaker": [
		"fm",
		"frame",
		"maker",
		"book"
	],
	"application/vnd.frogans.fnc": ["fnc"],
	"application/vnd.frogans.ltf": ["ltf"],
	"application/vnd.fsc.weblaunch": ["fsc"],
	"application/vnd.fujitsu.oasys": ["oas"],
	"application/vnd.fujitsu.oasys2": ["oa2"],
	"application/vnd.fujitsu.oasys3": ["oa3"],
	"application/vnd.fujitsu.oasysgp": ["fg5"],
	"application/vnd.fujitsu.oasysprs": ["bh2"],
	"application/vnd.fujixerox.ddd": ["ddd"],
	"application/vnd.fujixerox.docuworks": ["xdw"],
	"application/vnd.fujixerox.docuworks.binder": ["xbd"],
	"application/vnd.fuzzysheet": ["fzs"],
	"application/vnd.genomatix.tuxedo": ["txd"],
	"application/vnd.geogebra.file": ["ggb"],
	"application/vnd.geogebra.slides": ["ggs"],
	"application/vnd.geogebra.tool": ["ggt"],
	"application/vnd.geometry-explorer": ["gex", "gre"],
	"application/vnd.geonext": ["gxt"],
	"application/vnd.geoplan": ["g2w"],
	"application/vnd.geospace": ["g3w"],
	"application/vnd.gmx": ["gmx"],
	"application/vnd.google-apps.document": ["gdoc"],
	"application/vnd.google-apps.drawing": ["gdraw"],
	"application/vnd.google-apps.form": ["gform"],
	"application/vnd.google-apps.jam": ["gjam"],
	"application/vnd.google-apps.map": ["gmap"],
	"application/vnd.google-apps.presentation": ["gslides"],
	"application/vnd.google-apps.script": ["gscript"],
	"application/vnd.google-apps.site": ["gsite"],
	"application/vnd.google-apps.spreadsheet": ["gsheet"],
	"application/vnd.google-earth.kml+xml": ["kml"],
	"application/vnd.google-earth.kmz": ["kmz"],
	"application/vnd.gov.sk.xmldatacontainer+xml": ["xdcf"],
	"application/vnd.grafeq": ["gqf", "gqs"],
	"application/vnd.groove-account": ["gac"],
	"application/vnd.groove-help": ["ghf"],
	"application/vnd.groove-identity-message": ["gim"],
	"application/vnd.groove-injector": ["grv"],
	"application/vnd.groove-tool-message": ["gtm"],
	"application/vnd.groove-tool-template": ["tpl"],
	"application/vnd.groove-vcard": ["vcg"],
	"application/vnd.hal+xml": ["hal"],
	"application/vnd.handheld-entertainment+xml": ["zmm"],
	"application/vnd.hbci": ["hbci"],
	"application/vnd.hhe.lesson-player": ["les"],
	"application/vnd.hp-hpgl": ["hpgl"],
	"application/vnd.hp-hpid": ["hpid"],
	"application/vnd.hp-hps": ["hps"],
	"application/vnd.hp-jlyt": ["jlt"],
	"application/vnd.hp-pcl": ["pcl"],
	"application/vnd.hp-pclxl": ["pclxl"],
	"application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
	"application/vnd.ibm.minipay": ["mpy"],
	"application/vnd.ibm.modcap": [
		"afp",
		"listafp",
		"list3820"
	],
	"application/vnd.ibm.rights-management": ["irm"],
	"application/vnd.ibm.secure-container": ["sc"],
	"application/vnd.iccprofile": ["icc", "icm"],
	"application/vnd.igloader": ["igl"],
	"application/vnd.immervision-ivp": ["ivp"],
	"application/vnd.immervision-ivu": ["ivu"],
	"application/vnd.insors.igm": ["igm"],
	"application/vnd.intercon.formnet": ["xpw", "xpx"],
	"application/vnd.intergeo": ["i2g"],
	"application/vnd.intu.qbo": ["qbo"],
	"application/vnd.intu.qfx": ["qfx"],
	"application/vnd.ipunplugged.rcprofile": ["rcprofile"],
	"application/vnd.irepository.package+xml": ["irp"],
	"application/vnd.is-xpr": ["xpr"],
	"application/vnd.isac.fcs": ["fcs"],
	"application/vnd.jam": ["jam"],
	"application/vnd.jcp.javame.midlet-rms": ["rms"],
	"application/vnd.jisp": ["jisp"],
	"application/vnd.joost.joda-archive": ["joda"],
	"application/vnd.kahootz": ["ktz", "ktr"],
	"application/vnd.kde.karbon": ["karbon"],
	"application/vnd.kde.kchart": ["chrt"],
	"application/vnd.kde.kformula": ["kfo"],
	"application/vnd.kde.kivio": ["flw"],
	"application/vnd.kde.kontour": ["kon"],
	"application/vnd.kde.kpresenter": ["kpr", "kpt"],
	"application/vnd.kde.kspread": ["ksp"],
	"application/vnd.kde.kword": ["kwd", "kwt"],
	"application/vnd.kenameaapp": ["htke"],
	"application/vnd.kidspiration": ["kia"],
	"application/vnd.kinar": ["kne", "knp"],
	"application/vnd.koan": [
		"skp",
		"skd",
		"skt",
		"skm"
	],
	"application/vnd.kodak-descriptor": ["sse"],
	"application/vnd.las.las+xml": ["lasxml"],
	"application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
	"application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
	"application/vnd.lotus-1-2-3": ["123"],
	"application/vnd.lotus-approach": ["apr"],
	"application/vnd.lotus-freelance": ["pre"],
	"application/vnd.lotus-notes": ["nsf"],
	"application/vnd.lotus-organizer": ["org"],
	"application/vnd.lotus-screencam": ["scm"],
	"application/vnd.lotus-wordpro": ["lwp"],
	"application/vnd.macports.portpkg": ["portpkg"],
	"application/vnd.mapbox-vector-tile": ["mvt"],
	"application/vnd.mcd": ["mcd"],
	"application/vnd.medcalcdata": ["mc1"],
	"application/vnd.mediastation.cdkey": ["cdkey"],
	"application/vnd.mfer": ["mwf"],
	"application/vnd.mfmp": ["mfm"],
	"application/vnd.micrografx.flo": ["flo"],
	"application/vnd.micrografx.igx": ["igx"],
	"application/vnd.mif": ["mif"],
	"application/vnd.mobius.daf": ["daf"],
	"application/vnd.mobius.dis": ["dis"],
	"application/vnd.mobius.mbk": ["mbk"],
	"application/vnd.mobius.mqy": ["mqy"],
	"application/vnd.mobius.msl": ["msl"],
	"application/vnd.mobius.plc": ["plc"],
	"application/vnd.mobius.txf": ["txf"],
	"application/vnd.mophun.application": ["mpn"],
	"application/vnd.mophun.certificate": ["mpc"],
	"application/vnd.mozilla.xul+xml": ["xul"],
	"application/vnd.ms-artgalry": ["cil"],
	"application/vnd.ms-cab-compressed": ["cab"],
	"application/vnd.ms-excel": [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	],
	"application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
	"application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
	"application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
	"application/vnd.ms-fontobject": ["eot"],
	"application/vnd.ms-htmlhelp": ["chm"],
	"application/vnd.ms-ims": ["ims"],
	"application/vnd.ms-lrm": ["lrm"],
	"application/vnd.ms-officetheme": ["thmx"],
	"application/vnd.ms-outlook": ["msg"],
	"application/vnd.ms-pki.seccat": ["cat"],
	"application/vnd.ms-pki.stl": ["*stl"],
	"application/vnd.ms-powerpoint": [
		"ppt",
		"pps",
		"pot"
	],
	"application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
	"application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
	"application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
	"application/vnd.ms-project": ["*mpp", "mpt"],
	"application/vnd.ms-visio.viewer": ["vdx"],
	"application/vnd.ms-word.document.macroenabled.12": ["docm"],
	"application/vnd.ms-word.template.macroenabled.12": ["dotm"],
	"application/vnd.ms-works": [
		"wps",
		"wks",
		"wcm",
		"wdb"
	],
	"application/vnd.ms-wpl": ["wpl"],
	"application/vnd.ms-xpsdocument": ["xps"],
	"application/vnd.mseq": ["mseq"],
	"application/vnd.musician": ["mus"],
	"application/vnd.muvee.style": ["msty"],
	"application/vnd.mynfc": ["taglet"],
	"application/vnd.nato.bindingdataobject+xml": ["bdo"],
	"application/vnd.neurolanguage.nlu": ["nlu"],
	"application/vnd.nitf": ["ntf", "nitf"],
	"application/vnd.noblenet-directory": ["nnd"],
	"application/vnd.noblenet-sealer": ["nns"],
	"application/vnd.noblenet-web": ["nnw"],
	"application/vnd.nokia.n-gage.ac+xml": ["*ac"],
	"application/vnd.nokia.n-gage.data": ["ngdat"],
	"application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
	"application/vnd.nokia.radio-preset": ["rpst"],
	"application/vnd.nokia.radio-presets": ["rpss"],
	"application/vnd.novadigm.edm": ["edm"],
	"application/vnd.novadigm.edx": ["edx"],
	"application/vnd.novadigm.ext": ["ext"],
	"application/vnd.oasis.opendocument.chart": ["odc"],
	"application/vnd.oasis.opendocument.chart-template": ["otc"],
	"application/vnd.oasis.opendocument.database": ["odb"],
	"application/vnd.oasis.opendocument.formula": ["odf"],
	"application/vnd.oasis.opendocument.formula-template": ["odft"],
	"application/vnd.oasis.opendocument.graphics": ["odg"],
	"application/vnd.oasis.opendocument.graphics-template": ["otg"],
	"application/vnd.oasis.opendocument.image": ["odi"],
	"application/vnd.oasis.opendocument.image-template": ["oti"],
	"application/vnd.oasis.opendocument.presentation": ["odp"],
	"application/vnd.oasis.opendocument.presentation-template": ["otp"],
	"application/vnd.oasis.opendocument.spreadsheet": ["ods"],
	"application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
	"application/vnd.oasis.opendocument.text": ["odt"],
	"application/vnd.oasis.opendocument.text-master": ["odm"],
	"application/vnd.oasis.opendocument.text-template": ["ott"],
	"application/vnd.oasis.opendocument.text-web": ["oth"],
	"application/vnd.olpc-sugar": ["xo"],
	"application/vnd.oma.dd2+xml": ["dd2"],
	"application/vnd.openblox.game+xml": ["obgx"],
	"application/vnd.openofficeorg.extension": ["oxt"],
	"application/vnd.openstreetmap.data+xml": ["osm"],
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
	"application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
	"application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
	"application/vnd.osgeo.mapguide.package": ["mgp"],
	"application/vnd.osgi.dp": ["dp"],
	"application/vnd.osgi.subsystem": ["esa"],
	"application/vnd.palm": [
		"pdb",
		"pqa",
		"oprc"
	],
	"application/vnd.pawaafile": ["paw"],
	"application/vnd.pg.format": ["str"],
	"application/vnd.pg.osasli": ["ei6"],
	"application/vnd.picsel": ["efif"],
	"application/vnd.pmi.widget": ["wg"],
	"application/vnd.pocketlearn": ["plf"],
	"application/vnd.powerbuilder6": ["pbd"],
	"application/vnd.previewsystems.box": ["box"],
	"application/vnd.procrate.brushset": ["brushset"],
	"application/vnd.procreate.brush": ["brush"],
	"application/vnd.procreate.dream": ["drm"],
	"application/vnd.proteus.magazine": ["mgz"],
	"application/vnd.publishare-delta-tree": ["qps"],
	"application/vnd.pvi.ptid1": ["ptid"],
	"application/vnd.pwg-xhtml-print+xml": ["xhtm"],
	"application/vnd.quark.quarkxpress": [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	],
	"application/vnd.rar": ["rar"],
	"application/vnd.realvnc.bed": ["bed"],
	"application/vnd.recordare.musicxml": ["mxl"],
	"application/vnd.recordare.musicxml+xml": ["musicxml"],
	"application/vnd.rig.cryptonote": ["cryptonote"],
	"application/vnd.rim.cod": ["cod"],
	"application/vnd.rn-realmedia": ["rm"],
	"application/vnd.rn-realmedia-vbr": ["rmvb"],
	"application/vnd.route66.link66+xml": ["link66"],
	"application/vnd.sailingtracker.track": ["st"],
	"application/vnd.seemail": ["see"],
	"application/vnd.sema": ["sema"],
	"application/vnd.semd": ["semd"],
	"application/vnd.semf": ["semf"],
	"application/vnd.shana.informed.formdata": ["ifm"],
	"application/vnd.shana.informed.formtemplate": ["itp"],
	"application/vnd.shana.informed.interchange": ["iif"],
	"application/vnd.shana.informed.package": ["ipk"],
	"application/vnd.simtech-mindmapper": ["twd", "twds"],
	"application/vnd.smaf": ["mmf"],
	"application/vnd.smart.teacher": ["teacher"],
	"application/vnd.software602.filler.form+xml": ["fo"],
	"application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
	"application/vnd.spotfire.dxp": ["dxp"],
	"application/vnd.spotfire.sfs": ["sfs"],
	"application/vnd.stardivision.calc": ["sdc"],
	"application/vnd.stardivision.draw": ["sda"],
	"application/vnd.stardivision.impress": ["sdd"],
	"application/vnd.stardivision.math": ["smf"],
	"application/vnd.stardivision.writer": ["sdw", "vor"],
	"application/vnd.stardivision.writer-global": ["sgl"],
	"application/vnd.stepmania.package": ["smzip"],
	"application/vnd.stepmania.stepchart": ["sm"],
	"application/vnd.sun.wadl+xml": ["wadl"],
	"application/vnd.sun.xml.calc": ["sxc"],
	"application/vnd.sun.xml.calc.template": ["stc"],
	"application/vnd.sun.xml.draw": ["sxd"],
	"application/vnd.sun.xml.draw.template": ["std"],
	"application/vnd.sun.xml.impress": ["sxi"],
	"application/vnd.sun.xml.impress.template": ["sti"],
	"application/vnd.sun.xml.math": ["sxm"],
	"application/vnd.sun.xml.writer": ["sxw"],
	"application/vnd.sun.xml.writer.global": ["sxg"],
	"application/vnd.sun.xml.writer.template": ["stw"],
	"application/vnd.sus-calendar": ["sus", "susp"],
	"application/vnd.svd": ["svd"],
	"application/vnd.symbian.install": ["sis", "sisx"],
	"application/vnd.syncml+xml": ["xsm"],
	"application/vnd.syncml.dm+wbxml": ["bdm"],
	"application/vnd.syncml.dm+xml": ["xdm"],
	"application/vnd.syncml.dmddf+xml": ["ddf"],
	"application/vnd.tao.intent-module-archive": ["tao"],
	"application/vnd.tcpdump.pcap": [
		"pcap",
		"cap",
		"dmp"
	],
	"application/vnd.tmobile-livetv": ["tmo"],
	"application/vnd.trid.tpt": ["tpt"],
	"application/vnd.triscape.mxs": ["mxs"],
	"application/vnd.trueapp": ["tra"],
	"application/vnd.ufdl": ["ufd", "ufdl"],
	"application/vnd.uiq.theme": ["utz"],
	"application/vnd.umajin": ["umj"],
	"application/vnd.unity": ["unityweb"],
	"application/vnd.uoml+xml": ["uoml", "uo"],
	"application/vnd.vcx": ["vcx"],
	"application/vnd.visio": [
		"vsd",
		"vst",
		"vss",
		"vsw",
		"vsdx",
		"vtx"
	],
	"application/vnd.visionary": ["vis"],
	"application/vnd.vsf": ["vsf"],
	"application/vnd.wap.wbxml": ["wbxml"],
	"application/vnd.wap.wmlc": ["wmlc"],
	"application/vnd.wap.wmlscriptc": ["wmlsc"],
	"application/vnd.webturbo": ["wtb"],
	"application/vnd.wolfram.player": ["nbp"],
	"application/vnd.wordperfect": ["wpd"],
	"application/vnd.wqd": ["wqd"],
	"application/vnd.wt.stf": ["stf"],
	"application/vnd.xara": ["xar"],
	"application/vnd.xfdl": ["xfdl"],
	"application/vnd.yamaha.hv-dic": ["hvd"],
	"application/vnd.yamaha.hv-script": ["hvs"],
	"application/vnd.yamaha.hv-voice": ["hvp"],
	"application/vnd.yamaha.openscoreformat": ["osf"],
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
	"application/vnd.yamaha.smaf-audio": ["saf"],
	"application/vnd.yamaha.smaf-phrase": ["spf"],
	"application/vnd.yellowriver-custom-menu": ["cmp"],
	"application/vnd.zul": ["zir", "zirz"],
	"application/vnd.zzazz.deck+xml": ["zaz"],
	"application/x-7z-compressed": ["7z"],
	"application/x-abiword": ["abw"],
	"application/x-ace-compressed": ["ace"],
	"application/x-apple-diskimage": ["*dmg"],
	"application/x-arj": ["arj"],
	"application/x-authorware-bin": [
		"aab",
		"x32",
		"u32",
		"vox"
	],
	"application/x-authorware-map": ["aam"],
	"application/x-authorware-seg": ["aas"],
	"application/x-bcpio": ["bcpio"],
	"application/x-bdoc": ["*bdoc"],
	"application/x-bittorrent": ["torrent"],
	"application/x-blender": ["blend"],
	"application/x-blorb": ["blb", "blorb"],
	"application/x-bzip": ["bz"],
	"application/x-bzip2": ["bz2", "boz"],
	"application/x-cbr": [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	],
	"application/x-cdlink": ["vcd"],
	"application/x-cfs-compressed": ["cfs"],
	"application/x-chat": ["chat"],
	"application/x-chess-pgn": ["pgn"],
	"application/x-chrome-extension": ["crx"],
	"application/x-cocoa": ["cco"],
	"application/x-compressed": ["*rar"],
	"application/x-conference": ["nsc"],
	"application/x-cpio": ["cpio"],
	"application/x-csh": ["csh"],
	"application/x-debian-package": ["*deb", "udeb"],
	"application/x-dgc-compressed": ["dgc"],
	"application/x-director": [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	],
	"application/x-doom": ["wad"],
	"application/x-dtbncx+xml": ["ncx"],
	"application/x-dtbook+xml": ["dtb"],
	"application/x-dtbresource+xml": ["res"],
	"application/x-dvi": ["dvi"],
	"application/x-envoy": ["evy"],
	"application/x-eva": ["eva"],
	"application/x-font-bdf": ["bdf"],
	"application/x-font-ghostscript": ["gsf"],
	"application/x-font-linux-psf": ["psf"],
	"application/x-font-pcf": ["pcf"],
	"application/x-font-snf": ["snf"],
	"application/x-font-type1": [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	],
	"application/x-freearc": ["arc"],
	"application/x-futuresplash": ["spl"],
	"application/x-gca-compressed": ["gca"],
	"application/x-glulx": ["ulx"],
	"application/x-gnumeric": ["gnumeric"],
	"application/x-gramps-xml": ["gramps"],
	"application/x-gtar": ["gtar"],
	"application/x-hdf": ["hdf"],
	"application/x-httpd-php": ["php"],
	"application/x-install-instructions": ["install"],
	"application/x-ipynb+json": ["ipynb"],
	"application/x-iso9660-image": ["*iso"],
	"application/x-iwork-keynote-sffkey": ["*key"],
	"application/x-iwork-numbers-sffnumbers": ["*numbers"],
	"application/x-iwork-pages-sffpages": ["*pages"],
	"application/x-java-archive-diff": ["jardiff"],
	"application/x-java-jnlp-file": ["jnlp"],
	"application/x-keepass2": ["kdbx"],
	"application/x-latex": ["latex"],
	"application/x-lua-bytecode": ["luac"],
	"application/x-lzh-compressed": ["lzh", "lha"],
	"application/x-makeself": ["run"],
	"application/x-mie": ["mie"],
	"application/x-mobipocket-ebook": ["*prc", "mobi"],
	"application/x-ms-application": ["application"],
	"application/x-ms-shortcut": ["lnk"],
	"application/x-ms-wmd": ["wmd"],
	"application/x-ms-wmz": ["wmz"],
	"application/x-ms-xbap": ["xbap"],
	"application/x-msaccess": ["mdb"],
	"application/x-msbinder": ["obd"],
	"application/x-mscardfile": ["crd"],
	"application/x-msclip": ["clp"],
	"application/x-msdos-program": ["*exe"],
	"application/x-msdownload": [
		"*exe",
		"*dll",
		"com",
		"bat",
		"*msi"
	],
	"application/x-msmediaview": [
		"mvb",
		"m13",
		"m14"
	],
	"application/x-msmetafile": [
		"*wmf",
		"*wmz",
		"*emf",
		"emz"
	],
	"application/x-msmoney": ["mny"],
	"application/x-mspublisher": ["pub"],
	"application/x-msschedule": ["scd"],
	"application/x-msterminal": ["trm"],
	"application/x-mswrite": ["wri"],
	"application/x-netcdf": ["nc", "cdf"],
	"application/x-ns-proxy-autoconfig": ["pac"],
	"application/x-nzb": ["nzb"],
	"application/x-perl": ["pl", "pm"],
	"application/x-pilot": ["*prc", "*pdb"],
	"application/x-pkcs12": ["p12", "pfx"],
	"application/x-pkcs7-certificates": ["p7b", "spc"],
	"application/x-pkcs7-certreqresp": ["p7r"],
	"application/x-rar-compressed": ["*rar"],
	"application/x-redhat-package-manager": ["rpm"],
	"application/x-research-info-systems": ["ris"],
	"application/x-sea": ["sea"],
	"application/x-sh": ["sh"],
	"application/x-shar": ["shar"],
	"application/x-shockwave-flash": ["swf"],
	"application/x-silverlight-app": ["xap"],
	"application/x-sql": ["*sql"],
	"application/x-stuffit": ["sit"],
	"application/x-stuffitx": ["sitx"],
	"application/x-subrip": ["srt"],
	"application/x-sv4cpio": ["sv4cpio"],
	"application/x-sv4crc": ["sv4crc"],
	"application/x-t3vm-image": ["t3"],
	"application/x-tads": ["gam"],
	"application/x-tar": ["tar"],
	"application/x-tcl": ["tcl", "tk"],
	"application/x-tex": ["tex"],
	"application/x-tex-tfm": ["tfm"],
	"application/x-texinfo": ["texinfo", "texi"],
	"application/x-tgif": ["*obj"],
	"application/x-ustar": ["ustar"],
	"application/x-virtualbox-hdd": ["hdd"],
	"application/x-virtualbox-ova": ["ova"],
	"application/x-virtualbox-ovf": ["ovf"],
	"application/x-virtualbox-vbox": ["vbox"],
	"application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
	"application/x-virtualbox-vdi": ["vdi"],
	"application/x-virtualbox-vhd": ["vhd"],
	"application/x-virtualbox-vmdk": ["vmdk"],
	"application/x-wais-source": ["src"],
	"application/x-web-app-manifest+json": ["webapp"],
	"application/x-x509-ca-cert": [
		"der",
		"crt",
		"pem"
	],
	"application/x-xfig": ["fig"],
	"application/x-xliff+xml": ["*xlf"],
	"application/x-xpinstall": ["xpi"],
	"application/x-xz": ["xz"],
	"application/x-zip-compressed": ["*zip"],
	"application/x-zmachine": [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	],
	"audio/vnd.dece.audio": ["uva", "uvva"],
	"audio/vnd.digital-winds": ["eol"],
	"audio/vnd.dra": ["dra"],
	"audio/vnd.dts": ["dts"],
	"audio/vnd.dts.hd": ["dtshd"],
	"audio/vnd.lucent.voice": ["lvp"],
	"audio/vnd.ms-playready.media.pya": ["pya"],
	"audio/vnd.nuera.ecelp4800": ["ecelp4800"],
	"audio/vnd.nuera.ecelp7470": ["ecelp7470"],
	"audio/vnd.nuera.ecelp9600": ["ecelp9600"],
	"audio/vnd.rip": ["rip"],
	"audio/x-aac": ["*aac"],
	"audio/x-aiff": [
		"aif",
		"aiff",
		"aifc"
	],
	"audio/x-caf": ["caf"],
	"audio/x-flac": ["flac"],
	"audio/x-m4a": ["*m4a"],
	"audio/x-matroska": ["mka"],
	"audio/x-mpegurl": ["m3u"],
	"audio/x-ms-wax": ["wax"],
	"audio/x-ms-wma": ["wma"],
	"audio/x-pn-realaudio": ["ram", "ra"],
	"audio/x-pn-realaudio-plugin": ["rmp"],
	"audio/x-realaudio": ["*ra"],
	"audio/x-wav": ["*wav"],
	"chemical/x-cdx": ["cdx"],
	"chemical/x-cif": ["cif"],
	"chemical/x-cmdf": ["cmdf"],
	"chemical/x-cml": ["cml"],
	"chemical/x-csml": ["csml"],
	"chemical/x-xyz": ["xyz"],
	"image/prs.btif": ["btif", "btf"],
	"image/prs.pti": ["pti"],
	"image/vnd.adobe.photoshop": ["psd"],
	"image/vnd.airzip.accelerator.azv": ["azv"],
	"image/vnd.dece.graphic": [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	],
	"image/vnd.djvu": ["djvu", "djv"],
	"image/vnd.dvb.subtitle": ["*sub"],
	"image/vnd.dwg": ["dwg"],
	"image/vnd.dxf": ["dxf"],
	"image/vnd.fastbidsheet": ["fbs"],
	"image/vnd.fpx": ["fpx"],
	"image/vnd.fst": ["fst"],
	"image/vnd.fujixerox.edmics-mmr": ["mmr"],
	"image/vnd.fujixerox.edmics-rlc": ["rlc"],
	"image/vnd.microsoft.icon": ["ico"],
	"image/vnd.ms-dds": ["dds"],
	"image/vnd.ms-modi": ["mdi"],
	"image/vnd.ms-photo": ["wdp"],
	"image/vnd.net-fpx": ["npx"],
	"image/vnd.pco.b16": ["b16"],
	"image/vnd.tencent.tap": ["tap"],
	"image/vnd.valve.source.texture": ["vtf"],
	"image/vnd.wap.wbmp": ["wbmp"],
	"image/vnd.xiff": ["xif"],
	"image/vnd.zbrush.pcx": ["pcx"],
	"image/x-3ds": ["3ds"],
	"image/x-adobe-dng": ["dng"],
	"image/x-cmu-raster": ["ras"],
	"image/x-cmx": ["cmx"],
	"image/x-freehand": [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	],
	"image/x-icon": ["*ico"],
	"image/x-jng": ["jng"],
	"image/x-mrsid-image": ["sid"],
	"image/x-ms-bmp": ["*bmp"],
	"image/x-pcx": ["*pcx"],
	"image/x-pict": ["pic", "pct"],
	"image/x-portable-anymap": ["pnm"],
	"image/x-portable-bitmap": ["pbm"],
	"image/x-portable-graymap": ["pgm"],
	"image/x-portable-pixmap": ["ppm"],
	"image/x-rgb": ["rgb"],
	"image/x-tga": ["tga"],
	"image/x-xbitmap": ["xbm"],
	"image/x-xpixmap": ["xpm"],
	"image/x-xwindowdump": ["xwd"],
	"message/vnd.wfa.wsc": ["wsc"],
	"model/vnd.bary": ["bary"],
	"model/vnd.cld": ["cld"],
	"model/vnd.collada+xml": ["dae"],
	"model/vnd.dwf": ["dwf"],
	"model/vnd.gdl": ["gdl"],
	"model/vnd.gtw": ["gtw"],
	"model/vnd.mts": ["*mts"],
	"model/vnd.opengex": ["ogex"],
	"model/vnd.parasolid.transmit.binary": ["x_b"],
	"model/vnd.parasolid.transmit.text": ["x_t"],
	"model/vnd.pytha.pyox": ["pyo", "pyox"],
	"model/vnd.sap.vds": ["vds"],
	"model/vnd.usda": ["usda"],
	"model/vnd.usdz+zip": ["usdz"],
	"model/vnd.valve.source.compiled-map": ["bsp"],
	"model/vnd.vtu": ["vtu"],
	"text/prs.lines.tag": ["dsc"],
	"text/vnd.curl": ["curl"],
	"text/vnd.curl.dcurl": ["dcurl"],
	"text/vnd.curl.mcurl": ["mcurl"],
	"text/vnd.curl.scurl": ["scurl"],
	"text/vnd.dvb.subtitle": ["sub"],
	"text/vnd.familysearch.gedcom": ["ged"],
	"text/vnd.fly": ["fly"],
	"text/vnd.fmi.flexstor": ["flx"],
	"text/vnd.graphviz": ["gv"],
	"text/vnd.in3d.3dml": ["3dml"],
	"text/vnd.in3d.spot": ["spot"],
	"text/vnd.sun.j2me.app-descriptor": ["jad"],
	"text/vnd.wap.wml": ["wml"],
	"text/vnd.wap.wmlscript": ["wmls"],
	"text/x-asm": ["s", "asm"],
	"text/x-c": [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	],
	"text/x-component": ["htc"],
	"text/x-fortran": [
		"f",
		"for",
		"f77",
		"f90"
	],
	"text/x-handlebars-template": ["hbs"],
	"text/x-java-source": ["java"],
	"text/x-lua": ["lua"],
	"text/x-markdown": ["mkd"],
	"text/x-nfo": ["nfo"],
	"text/x-opml": ["opml"],
	"text/x-org": ["*org"],
	"text/x-pascal": ["p", "pas"],
	"text/x-processing": ["pde"],
	"text/x-sass": ["sass"],
	"text/x-scss": ["scss"],
	"text/x-setext": ["etx"],
	"text/x-sfv": ["sfv"],
	"text/x-suse-ymp": ["ymp"],
	"text/x-uuencode": ["uu"],
	"text/x-vcalendar": ["vcs"],
	"text/x-vcard": ["vcf"],
	"video/vnd.dece.hd": ["uvh", "uvvh"],
	"video/vnd.dece.mobile": ["uvm", "uvvm"],
	"video/vnd.dece.pd": ["uvp", "uvvp"],
	"video/vnd.dece.sd": ["uvs", "uvvs"],
	"video/vnd.dece.video": ["uvv", "uvvv"],
	"video/vnd.dvb.file": ["dvb"],
	"video/vnd.fvt": ["fvt"],
	"video/vnd.mpegurl": ["mxu", "m4u"],
	"video/vnd.ms-playready.media.pyv": ["pyv"],
	"video/vnd.uvvu.mp4": ["uvu", "uvvu"],
	"video/vnd.vivo": ["viv"],
	"video/x-f4v": ["f4v"],
	"video/x-fli": ["fli"],
	"video/x-flv": ["flv"],
	"video/x-m4v": ["m4v"],
	"video/x-matroska": [
		"mkv",
		"mk3d",
		"mks"
	],
	"video/x-mng": ["mng"],
	"video/x-ms-asf": ["asf", "asx"],
	"video/x-ms-vob": ["vob"],
	"video/x-ms-wm": ["wm"],
	"video/x-ms-wmv": ["wmv"],
	"video/x-ms-wmx": ["wmx"],
	"video/x-ms-wvx": ["wvx"],
	"video/x-msvideo": ["avi"],
	"video/x-sgi-movie": ["movie"],
	"video/x-smv": ["smv"],
	"x-conference/x-cooltalk": ["ice"]
};
Object.freeze(types$1);
var other_default = types$1;

//#endregion
//#region ../../node_modules/.pnpm/mime@4.0.7/node_modules/mime/dist/types/standard.js
const types = {
	"application/andrew-inset": ["ez"],
	"application/appinstaller": ["appinstaller"],
	"application/applixware": ["aw"],
	"application/appx": ["appx"],
	"application/appxbundle": ["appxbundle"],
	"application/atom+xml": ["atom"],
	"application/atomcat+xml": ["atomcat"],
	"application/atomdeleted+xml": ["atomdeleted"],
	"application/atomsvc+xml": ["atomsvc"],
	"application/atsc-dwd+xml": ["dwd"],
	"application/atsc-held+xml": ["held"],
	"application/atsc-rsat+xml": ["rsat"],
	"application/automationml-aml+xml": ["aml"],
	"application/automationml-amlx+zip": ["amlx"],
	"application/bdoc": ["bdoc"],
	"application/calendar+xml": ["xcs"],
	"application/ccxml+xml": ["ccxml"],
	"application/cdfx+xml": ["cdfx"],
	"application/cdmi-capability": ["cdmia"],
	"application/cdmi-container": ["cdmic"],
	"application/cdmi-domain": ["cdmid"],
	"application/cdmi-object": ["cdmio"],
	"application/cdmi-queue": ["cdmiq"],
	"application/cpl+xml": ["cpl"],
	"application/cu-seeme": ["cu"],
	"application/cwl": ["cwl"],
	"application/dash+xml": ["mpd"],
	"application/dash-patch+xml": ["mpp"],
	"application/davmount+xml": ["davmount"],
	"application/dicom": ["dcm"],
	"application/docbook+xml": ["dbk"],
	"application/dssc+der": ["dssc"],
	"application/dssc+xml": ["xdssc"],
	"application/ecmascript": ["ecma"],
	"application/emma+xml": ["emma"],
	"application/emotionml+xml": ["emotionml"],
	"application/epub+zip": ["epub"],
	"application/exi": ["exi"],
	"application/express": ["exp"],
	"application/fdf": ["fdf"],
	"application/fdt+xml": ["fdt"],
	"application/font-tdpfr": ["pfr"],
	"application/geo+json": ["geojson"],
	"application/gml+xml": ["gml"],
	"application/gpx+xml": ["gpx"],
	"application/gxf": ["gxf"],
	"application/gzip": ["gz"],
	"application/hjson": ["hjson"],
	"application/hyperstudio": ["stk"],
	"application/inkml+xml": ["ink", "inkml"],
	"application/ipfix": ["ipfix"],
	"application/its+xml": ["its"],
	"application/java-archive": [
		"jar",
		"war",
		"ear"
	],
	"application/java-serialized-object": ["ser"],
	"application/java-vm": ["class"],
	"application/javascript": ["*js"],
	"application/json": ["json", "map"],
	"application/json5": ["json5"],
	"application/jsonml+json": ["jsonml"],
	"application/ld+json": ["jsonld"],
	"application/lgr+xml": ["lgr"],
	"application/lost+xml": ["lostxml"],
	"application/mac-binhex40": ["hqx"],
	"application/mac-compactpro": ["cpt"],
	"application/mads+xml": ["mads"],
	"application/manifest+json": ["webmanifest"],
	"application/marc": ["mrc"],
	"application/marcxml+xml": ["mrcx"],
	"application/mathematica": [
		"ma",
		"nb",
		"mb"
	],
	"application/mathml+xml": ["mathml"],
	"application/mbox": ["mbox"],
	"application/media-policy-dataset+xml": ["mpf"],
	"application/mediaservercontrol+xml": ["mscml"],
	"application/metalink+xml": ["metalink"],
	"application/metalink4+xml": ["meta4"],
	"application/mets+xml": ["mets"],
	"application/mmt-aei+xml": ["maei"],
	"application/mmt-usd+xml": ["musd"],
	"application/mods+xml": ["mods"],
	"application/mp21": ["m21", "mp21"],
	"application/mp4": [
		"*mp4",
		"*mpg4",
		"mp4s",
		"m4p"
	],
	"application/msix": ["msix"],
	"application/msixbundle": ["msixbundle"],
	"application/msword": ["doc", "dot"],
	"application/mxf": ["mxf"],
	"application/n-quads": ["nq"],
	"application/n-triples": ["nt"],
	"application/node": ["cjs"],
	"application/octet-stream": [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	],
	"application/oda": ["oda"],
	"application/oebps-package+xml": ["opf"],
	"application/ogg": ["ogx"],
	"application/omdoc+xml": ["omdoc"],
	"application/onenote": [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg",
		"one",
		"onea"
	],
	"application/oxps": ["oxps"],
	"application/p2p-overlay+xml": ["relo"],
	"application/patch-ops-error+xml": ["xer"],
	"application/pdf": ["pdf"],
	"application/pgp-encrypted": ["pgp"],
	"application/pgp-keys": ["asc"],
	"application/pgp-signature": ["sig", "*asc"],
	"application/pics-rules": ["prf"],
	"application/pkcs10": ["p10"],
	"application/pkcs7-mime": ["p7m", "p7c"],
	"application/pkcs7-signature": ["p7s"],
	"application/pkcs8": ["p8"],
	"application/pkix-attr-cert": ["ac"],
	"application/pkix-cert": ["cer"],
	"application/pkix-crl": ["crl"],
	"application/pkix-pkipath": ["pkipath"],
	"application/pkixcmp": ["pki"],
	"application/pls+xml": ["pls"],
	"application/postscript": [
		"ai",
		"eps",
		"ps"
	],
	"application/provenance+xml": ["provx"],
	"application/pskc+xml": ["pskcxml"],
	"application/raml+yaml": ["raml"],
	"application/rdf+xml": ["rdf", "owl"],
	"application/reginfo+xml": ["rif"],
	"application/relax-ng-compact-syntax": ["rnc"],
	"application/resource-lists+xml": ["rl"],
	"application/resource-lists-diff+xml": ["rld"],
	"application/rls-services+xml": ["rs"],
	"application/route-apd+xml": ["rapd"],
	"application/route-s-tsid+xml": ["sls"],
	"application/route-usd+xml": ["rusd"],
	"application/rpki-ghostbusters": ["gbr"],
	"application/rpki-manifest": ["mft"],
	"application/rpki-roa": ["roa"],
	"application/rsd+xml": ["rsd"],
	"application/rss+xml": ["rss"],
	"application/rtf": ["rtf"],
	"application/sbml+xml": ["sbml"],
	"application/scvp-cv-request": ["scq"],
	"application/scvp-cv-response": ["scs"],
	"application/scvp-vp-request": ["spq"],
	"application/scvp-vp-response": ["spp"],
	"application/sdp": ["sdp"],
	"application/senml+xml": ["senmlx"],
	"application/sensml+xml": ["sensmlx"],
	"application/set-payment-initiation": ["setpay"],
	"application/set-registration-initiation": ["setreg"],
	"application/shf+xml": ["shf"],
	"application/sieve": ["siv", "sieve"],
	"application/smil+xml": ["smi", "smil"],
	"application/sparql-query": ["rq"],
	"application/sparql-results+xml": ["srx"],
	"application/sql": ["sql"],
	"application/srgs": ["gram"],
	"application/srgs+xml": ["grxml"],
	"application/sru+xml": ["sru"],
	"application/ssdl+xml": ["ssdl"],
	"application/ssml+xml": ["ssml"],
	"application/swid+xml": ["swidtag"],
	"application/tei+xml": ["tei", "teicorpus"],
	"application/thraud+xml": ["tfi"],
	"application/timestamped-data": ["tsd"],
	"application/toml": ["toml"],
	"application/trig": ["trig"],
	"application/ttml+xml": ["ttml"],
	"application/ubjson": ["ubj"],
	"application/urc-ressheet+xml": ["rsheet"],
	"application/urc-targetdesc+xml": ["td"],
	"application/voicexml+xml": ["vxml"],
	"application/wasm": ["wasm"],
	"application/watcherinfo+xml": ["wif"],
	"application/widget": ["wgt"],
	"application/winhlp": ["hlp"],
	"application/wsdl+xml": ["wsdl"],
	"application/wspolicy+xml": ["wspolicy"],
	"application/xaml+xml": ["xaml"],
	"application/xcap-att+xml": ["xav"],
	"application/xcap-caps+xml": ["xca"],
	"application/xcap-diff+xml": ["xdf"],
	"application/xcap-el+xml": ["xel"],
	"application/xcap-ns+xml": ["xns"],
	"application/xenc+xml": ["xenc"],
	"application/xfdf": ["xfdf"],
	"application/xhtml+xml": ["xhtml", "xht"],
	"application/xliff+xml": ["xlf"],
	"application/xml": [
		"xml",
		"xsl",
		"xsd",
		"rng"
	],
	"application/xml-dtd": ["dtd"],
	"application/xop+xml": ["xop"],
	"application/xproc+xml": ["xpl"],
	"application/xslt+xml": ["*xsl", "xslt"],
	"application/xspf+xml": ["xspf"],
	"application/xv+xml": [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	],
	"application/yang": ["yang"],
	"application/yin+xml": ["yin"],
	"application/zip": ["zip"],
	"application/zip+dotlottie": ["lottie"],
	"audio/3gpp": ["*3gpp"],
	"audio/aac": ["adts", "aac"],
	"audio/adpcm": ["adp"],
	"audio/amr": ["amr"],
	"audio/basic": ["au", "snd"],
	"audio/midi": [
		"mid",
		"midi",
		"kar",
		"rmi"
	],
	"audio/mobile-xmf": ["mxmf"],
	"audio/mp3": ["*mp3"],
	"audio/mp4": [
		"m4a",
		"mp4a",
		"m4b"
	],
	"audio/mpeg": [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	],
	"audio/ogg": [
		"oga",
		"ogg",
		"spx",
		"opus"
	],
	"audio/s3m": ["s3m"],
	"audio/silk": ["sil"],
	"audio/wav": ["wav"],
	"audio/wave": ["*wav"],
	"audio/webm": ["weba"],
	"audio/xm": ["xm"],
	"font/collection": ["ttc"],
	"font/otf": ["otf"],
	"font/ttf": ["ttf"],
	"font/woff": ["woff"],
	"font/woff2": ["woff2"],
	"image/aces": ["exr"],
	"image/apng": ["apng"],
	"image/avci": ["avci"],
	"image/avcs": ["avcs"],
	"image/avif": ["avif"],
	"image/bmp": ["bmp", "dib"],
	"image/cgm": ["cgm"],
	"image/dicom-rle": ["drle"],
	"image/dpx": ["dpx"],
	"image/emf": ["emf"],
	"image/fits": ["fits"],
	"image/g3fax": ["g3"],
	"image/gif": ["gif"],
	"image/heic": ["heic"],
	"image/heic-sequence": ["heics"],
	"image/heif": ["heif"],
	"image/heif-sequence": ["heifs"],
	"image/hej2k": ["hej2"],
	"image/ief": ["ief"],
	"image/jaii": ["jaii"],
	"image/jais": ["jais"],
	"image/jls": ["jls"],
	"image/jp2": ["jp2", "jpg2"],
	"image/jpeg": [
		"jpg",
		"jpeg",
		"jpe"
	],
	"image/jph": ["jph"],
	"image/jphc": ["jhc"],
	"image/jpm": ["jpm", "jpgm"],
	"image/jpx": ["jpx", "jpf"],
	"image/jxl": ["jxl"],
	"image/jxr": ["jxr"],
	"image/jxra": ["jxra"],
	"image/jxrs": ["jxrs"],
	"image/jxs": ["jxs"],
	"image/jxsc": ["jxsc"],
	"image/jxsi": ["jxsi"],
	"image/jxss": ["jxss"],
	"image/ktx": ["ktx"],
	"image/ktx2": ["ktx2"],
	"image/pjpeg": ["jfif"],
	"image/png": ["png"],
	"image/sgi": ["sgi"],
	"image/svg+xml": ["svg", "svgz"],
	"image/t38": ["t38"],
	"image/tiff": ["tif", "tiff"],
	"image/tiff-fx": ["tfx"],
	"image/webp": ["webp"],
	"image/wmf": ["wmf"],
	"message/disposition-notification": ["disposition-notification"],
	"message/global": ["u8msg"],
	"message/global-delivery-status": ["u8dsn"],
	"message/global-disposition-notification": ["u8mdn"],
	"message/global-headers": ["u8hdr"],
	"message/rfc822": [
		"eml",
		"mime",
		"mht",
		"mhtml"
	],
	"model/3mf": ["3mf"],
	"model/gltf+json": ["gltf"],
	"model/gltf-binary": ["glb"],
	"model/iges": ["igs", "iges"],
	"model/jt": ["jt"],
	"model/mesh": [
		"msh",
		"mesh",
		"silo"
	],
	"model/mtl": ["mtl"],
	"model/obj": ["obj"],
	"model/prc": ["prc"],
	"model/step": [
		"step",
		"stp",
		"stpnc",
		"p21",
		"210"
	],
	"model/step+xml": ["stpx"],
	"model/step+zip": ["stpz"],
	"model/step-xml+zip": ["stpxz"],
	"model/stl": ["stl"],
	"model/u3d": ["u3d"],
	"model/vrml": ["wrl", "vrml"],
	"model/x3d+binary": ["*x3db", "x3dbz"],
	"model/x3d+fastinfoset": ["x3db"],
	"model/x3d+vrml": ["*x3dv", "x3dvz"],
	"model/x3d+xml": ["x3d", "x3dz"],
	"model/x3d-vrml": ["x3dv"],
	"text/cache-manifest": ["appcache", "manifest"],
	"text/calendar": ["ics", "ifb"],
	"text/coffeescript": ["coffee", "litcoffee"],
	"text/css": ["css"],
	"text/csv": ["csv"],
	"text/html": [
		"html",
		"htm",
		"shtml"
	],
	"text/jade": ["jade"],
	"text/javascript": ["js", "mjs"],
	"text/jsx": ["jsx"],
	"text/less": ["less"],
	"text/markdown": ["md", "markdown"],
	"text/mathml": ["mml"],
	"text/mdx": ["mdx"],
	"text/n3": ["n3"],
	"text/plain": [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	],
	"text/richtext": ["rtx"],
	"text/rtf": ["*rtf"],
	"text/sgml": ["sgml", "sgm"],
	"text/shex": ["shex"],
	"text/slim": ["slim", "slm"],
	"text/spdx": ["spdx"],
	"text/stylus": ["stylus", "styl"],
	"text/tab-separated-values": ["tsv"],
	"text/troff": [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	],
	"text/turtle": ["ttl"],
	"text/uri-list": [
		"uri",
		"uris",
		"urls"
	],
	"text/vcard": ["vcard"],
	"text/vtt": ["vtt"],
	"text/wgsl": ["wgsl"],
	"text/xml": ["*xml"],
	"text/yaml": ["yaml", "yml"],
	"video/3gpp": ["3gp", "3gpp"],
	"video/3gpp2": ["3g2"],
	"video/h261": ["h261"],
	"video/h263": ["h263"],
	"video/h264": ["h264"],
	"video/iso.segment": ["m4s"],
	"video/jpeg": ["jpgv"],
	"video/jpm": ["*jpm", "*jpgm"],
	"video/mj2": ["mj2", "mjp2"],
	"video/mp2t": [
		"ts",
		"m2t",
		"m2ts",
		"mts"
	],
	"video/mp4": [
		"mp4",
		"mp4v",
		"mpg4"
	],
	"video/mpeg": [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	],
	"video/ogg": ["ogv"],
	"video/quicktime": ["qt", "mov"],
	"video/webm": ["webm"]
};
Object.freeze(types);
var standard_default = types;

//#endregion
//#region ../../node_modules/.pnpm/mime@4.0.7/node_modules/mime/dist/src/Mime.js
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Mime_extensionToType, _Mime_typeToExtension, _Mime_typeToExtensions;
var Mime = class {
	constructor(...args) {
		_Mime_extensionToType.set(this, /* @__PURE__ */ new Map());
		_Mime_typeToExtension.set(this, /* @__PURE__ */ new Map());
		_Mime_typeToExtensions.set(this, /* @__PURE__ */ new Map());
		for (const arg of args) this.define(arg);
	}
	define(typeMap, force = false) {
		for (let [type, extensions] of Object.entries(typeMap)) {
			type = type.toLowerCase();
			extensions = extensions.map((ext) => ext.toLowerCase());
			if (!__classPrivateFieldGet(this, _Mime_typeToExtensions, "f").has(type)) __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").set(type, /* @__PURE__ */ new Set());
			const allExtensions = __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type);
			let first = true;
			for (let extension of extensions) {
				const starred = extension.startsWith("*");
				extension = starred ? extension.slice(1) : extension;
				allExtensions?.add(extension);
				if (first) __classPrivateFieldGet(this, _Mime_typeToExtension, "f").set(type, extension);
				first = false;
				if (starred) continue;
				const currentType = __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(extension);
				if (currentType && currentType != type && !force) throw new Error(`"${type} -> ${extension}" conflicts with "${currentType} -> ${extension}". Pass \`force=true\` to override this definition.`);
				__classPrivateFieldGet(this, _Mime_extensionToType, "f").set(extension, type);
			}
		}
		return this;
	}
	getType(path$3) {
		if (typeof path$3 !== "string") return null;
		const last = path$3.replace(/^.*[/\\]/s, "").toLowerCase();
		const ext = last.replace(/^.*\./s, "").toLowerCase();
		const hasPath = last.length < path$3.length;
		if (!(ext.length < last.length - 1) && hasPath) return null;
		return __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(ext) ?? null;
	}
	getExtension(type) {
		if (typeof type !== "string") return null;
		type = type?.split?.(";")[0];
		return (type && __classPrivateFieldGet(this, _Mime_typeToExtension, "f").get(type.trim().toLowerCase())) ?? null;
	}
	getAllExtensions(type) {
		if (typeof type !== "string") return null;
		return __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type.toLowerCase()) ?? null;
	}
	_freeze() {
		this.define = () => {
			throw new Error("define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances");
		};
		Object.freeze(this);
		for (const extensions of __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").values()) Object.freeze(extensions);
		return this;
	}
	_getTestState() {
		return {
			types: __classPrivateFieldGet(this, _Mime_extensionToType, "f"),
			extensions: __classPrivateFieldGet(this, _Mime_typeToExtension, "f")
		};
	}
};
_Mime_extensionToType = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtension = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtensions = /* @__PURE__ */ new WeakMap();
var Mime_default = Mime;

//#endregion
//#region ../../node_modules/.pnpm/mime@4.0.7/node_modules/mime/dist/src/index.js
var src_default = new Mime_default(standard_default, other_default)._freeze();

//#endregion
//#region ../workers-shared/utils/helpers.ts
function thrownIsDoesNotExistError(thrown) {
	return thrown instanceof Error && "code" in thrown && thrown.code === "ENOENT";
}
function maybeGetFile(filePath) {
	try {
		return readFileSync(filePath, "utf8");
	} catch (e) {
		if (!thrownIsDoesNotExistError(e)) throw e;
	}
}

//#endregion
//#region ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/index.mjs
var util;
(function(util$2) {
	util$2.assertEqual = (val) => val;
	function assertIs(_arg) {}
	util$2.assertIs = assertIs;
	function assertNever(_x) {
		throw new Error();
	}
	util$2.assertNever = assertNever;
	util$2.arrayToEnum = (items) => {
		const obj = {};
		for (const item of items) obj[item] = item;
		return obj;
	};
	util$2.getValidEnumValues = (obj) => {
		const validKeys = util$2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
		const filtered = {};
		for (const k of validKeys) filtered[k] = obj[k];
		return util$2.objectValues(filtered);
	};
	util$2.objectValues = (obj) => {
		return util$2.objectKeys(obj).map(function(e) {
			return obj[e];
		});
	};
	util$2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
		const keys = [];
		for (const key in object) if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
		return keys;
	};
	util$2.find = (arr, checker) => {
		for (const item of arr) if (checker(item)) return item;
	};
	util$2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
	function joinValues(array, separator = " | ") {
		return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
	}
	util$2.joinValues = joinValues;
	util$2.jsonStringifyReplacer = (_, value) => {
		if (typeof value === "bigint") return value.toString();
		return value;
	};
})(util || (util = {}));
var objectUtil;
(function(objectUtil$1) {
	objectUtil$1.mergeShapes = (first, second) => {
		return {
			...first,
			...second
		};
	};
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
	"string",
	"nan",
	"number",
	"integer",
	"float",
	"boolean",
	"date",
	"bigint",
	"symbol",
	"function",
	"undefined",
	"null",
	"array",
	"object",
	"unknown",
	"promise",
	"void",
	"never",
	"map",
	"set"
]);
const getParsedType = (data$1) => {
	switch (typeof data$1) {
		case "undefined": return ZodParsedType.undefined;
		case "string": return ZodParsedType.string;
		case "number": return isNaN(data$1) ? ZodParsedType.nan : ZodParsedType.number;
		case "boolean": return ZodParsedType.boolean;
		case "function": return ZodParsedType.function;
		case "bigint": return ZodParsedType.bigint;
		case "symbol": return ZodParsedType.symbol;
		case "object":
			if (Array.isArray(data$1)) return ZodParsedType.array;
			if (data$1 === null) return ZodParsedType.null;
			if (data$1.then && typeof data$1.then === "function" && data$1.catch && typeof data$1.catch === "function") return ZodParsedType.promise;
			if (typeof Map !== "undefined" && data$1 instanceof Map) return ZodParsedType.map;
			if (typeof Set !== "undefined" && data$1 instanceof Set) return ZodParsedType.set;
			if (typeof Date !== "undefined" && data$1 instanceof Date) return ZodParsedType.date;
			return ZodParsedType.object;
		default: return ZodParsedType.unknown;
	}
};
const ZodIssueCode = util.arrayToEnum([
	"invalid_type",
	"invalid_literal",
	"custom",
	"invalid_union",
	"invalid_union_discriminator",
	"invalid_enum_value",
	"unrecognized_keys",
	"invalid_arguments",
	"invalid_return_type",
	"invalid_date",
	"invalid_string",
	"too_small",
	"too_big",
	"invalid_intersection_types",
	"not_multiple_of",
	"not_finite"
]);
const quotelessJson = (obj) => {
	return JSON.stringify(obj, null, 2).replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
	constructor(issues) {
		super();
		this.issues = [];
		this.addIssue = (sub) => {
			this.issues = [...this.issues, sub];
		};
		this.addIssues = (subs = []) => {
			this.issues = [...this.issues, ...subs];
		};
		const actualProto = new.target.prototype;
		if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
		else this.__proto__ = actualProto;
		this.name = "ZodError";
		this.issues = issues;
	}
	get errors() {
		return this.issues;
	}
	format(_mapper) {
		const mapper = _mapper || function(issue) {
			return issue.message;
		};
		const fieldErrors = { _errors: [] };
		const processError = (error) => {
			for (const issue of error.issues) if (issue.code === "invalid_union") issue.unionErrors.map(processError);
			else if (issue.code === "invalid_return_type") processError(issue.returnTypeError);
			else if (issue.code === "invalid_arguments") processError(issue.argumentsError);
			else if (issue.path.length === 0) fieldErrors._errors.push(mapper(issue));
			else {
				let curr = fieldErrors;
				let i$1 = 0;
				while (i$1 < issue.path.length) {
					const el = issue.path[i$1];
					if (!(i$1 === issue.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
					else {
						curr[el] = curr[el] || { _errors: [] };
						curr[el]._errors.push(mapper(issue));
					}
					curr = curr[el];
					i$1++;
				}
			}
		};
		processError(this);
		return fieldErrors;
	}
	toString() {
		return this.message;
	}
	get message() {
		return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
	}
	get isEmpty() {
		return this.issues.length === 0;
	}
	flatten(mapper = (issue) => issue.message) {
		const fieldErrors = {};
		const formErrors = [];
		for (const sub of this.issues) if (sub.path.length > 0) {
			fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
			fieldErrors[sub.path[0]].push(mapper(sub));
		} else formErrors.push(mapper(sub));
		return {
			formErrors,
			fieldErrors
		};
	}
	get formErrors() {
		return this.flatten();
	}
};
ZodError.create = (issues) => {
	return new ZodError(issues);
};
const errorMap = (issue, _ctx) => {
	let message;
	switch (issue.code) {
		case ZodIssueCode.invalid_type:
			if (issue.received === ZodParsedType.undefined) message = "Required";
			else message = `Expected ${issue.expected}, received ${issue.received}`;
			break;
		case ZodIssueCode.invalid_literal:
			message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
			break;
		case ZodIssueCode.unrecognized_keys:
			message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
			break;
		case ZodIssueCode.invalid_union:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_union_discriminator:
			message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
			break;
		case ZodIssueCode.invalid_enum_value:
			message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
			break;
		case ZodIssueCode.invalid_arguments:
			message = `Invalid function arguments`;
			break;
		case ZodIssueCode.invalid_return_type:
			message = `Invalid function return type`;
			break;
		case ZodIssueCode.invalid_date:
			message = `Invalid date`;
			break;
		case ZodIssueCode.invalid_string:
			if (typeof issue.validation === "object") if ("includes" in issue.validation) {
				message = `Invalid input: must include "${issue.validation.includes}"`;
				if (typeof issue.validation.position === "number") message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
			} else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
			else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
			else util.assertNever(issue.validation);
			else if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
			else message = "Invalid";
			break;
		case ZodIssueCode.too_small:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.too_big:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.custom:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_intersection_types:
			message = `Intersection results could not be merged`;
			break;
		case ZodIssueCode.not_multiple_of:
			message = `Number must be a multiple of ${issue.multipleOf}`;
			break;
		case ZodIssueCode.not_finite:
			message = "Number must be finite";
			break;
		default:
			message = _ctx.defaultError;
			util.assertNever(issue);
	}
	return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
	overrideErrorMap = map;
}
function getErrorMap() {
	return overrideErrorMap;
}
const makeIssue = (params) => {
	const { data: data$1, path: path$3, errorMaps, issueData } = params;
	const fullPath = [...path$3, ...issueData.path || []];
	const fullIssue = {
		...issueData,
		path: fullPath
	};
	let errorMessage = "";
	const maps = errorMaps.filter((m) => !!m).slice().reverse();
	for (const map of maps) errorMessage = map(fullIssue, {
		data: data$1,
		defaultError: errorMessage
	}).message;
	return {
		...issueData,
		path: fullPath,
		message: issueData.message || errorMessage
	};
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
	const issue = makeIssue({
		issueData,
		data: ctx.data,
		path: ctx.path,
		errorMaps: [
			ctx.common.contextualErrorMap,
			ctx.schemaErrorMap,
			getErrorMap(),
			errorMap
		].filter((x) => !!x)
	});
	ctx.common.issues.push(issue);
}
var ParseStatus = class ParseStatus {
	constructor() {
		this.value = "valid";
	}
	dirty() {
		if (this.value === "valid") this.value = "dirty";
	}
	abort() {
		if (this.value !== "aborted") this.value = "aborted";
	}
	static mergeArray(status, results) {
		const arrayValue = [];
		for (const s of results) {
			if (s.status === "aborted") return INVALID;
			if (s.status === "dirty") status.dirty();
			arrayValue.push(s.value);
		}
		return {
			status: status.value,
			value: arrayValue
		};
	}
	static async mergeObjectAsync(status, pairs) {
		const syncPairs = [];
		for (const pair of pairs) syncPairs.push({
			key: await pair.key,
			value: await pair.value
		});
		return ParseStatus.mergeObjectSync(status, syncPairs);
	}
	static mergeObjectSync(status, pairs) {
		const finalObject = {};
		for (const pair of pairs) {
			const { key, value } = pair;
			if (key.status === "aborted") return INVALID;
			if (value.status === "aborted") return INVALID;
			if (key.status === "dirty") status.dirty();
			if (value.status === "dirty") status.dirty();
			if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) finalObject[key.value] = value.value;
		}
		return {
			status: status.value,
			value: finalObject
		};
	}
};
const INVALID = Object.freeze({ status: "aborted" });
const DIRTY = (value) => ({
	status: "dirty",
	value
});
const OK = (value) => ({
	status: "valid",
	value
});
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil$1) {
	errorUtil$1.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	errorUtil$1.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
	constructor(parent, value, path$3, key) {
		this._cachedPath = [];
		this.parent = parent;
		this.data = value;
		this._path = path$3;
		this._key = key;
	}
	get path() {
		if (!this._cachedPath.length) if (this._key instanceof Array) this._cachedPath.push(...this._path, ...this._key);
		else this._cachedPath.push(...this._path, this._key);
		return this._cachedPath;
	}
};
const handleResult = (ctx, result) => {
	if (isValid(result)) return {
		success: true,
		data: result.value
	};
	else {
		if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
		return {
			success: false,
			get error() {
				if (this._error) return this._error;
				this._error = new ZodError(ctx.common.issues);
				return this._error;
			}
		};
	}
};
function processCreateParams(params) {
	if (!params) return {};
	const { errorMap: errorMap$1, invalid_type_error, required_error, description } = params;
	if (errorMap$1 && (invalid_type_error || required_error)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	if (errorMap$1) return {
		errorMap: errorMap$1,
		description
	};
	const customMap = (iss, ctx) => {
		if (iss.code !== "invalid_type") return { message: ctx.defaultError };
		if (typeof ctx.data === "undefined") return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
		return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
	};
	return {
		errorMap: customMap,
		description
	};
}
var ZodType = class {
	constructor(def) {
		/** Alias of safeParseAsync */
		this.spa = this.safeParseAsync;
		this._def = def;
		this.parse = this.parse.bind(this);
		this.safeParse = this.safeParse.bind(this);
		this.parseAsync = this.parseAsync.bind(this);
		this.safeParseAsync = this.safeParseAsync.bind(this);
		this.spa = this.spa.bind(this);
		this.refine = this.refine.bind(this);
		this.refinement = this.refinement.bind(this);
		this.superRefine = this.superRefine.bind(this);
		this.optional = this.optional.bind(this);
		this.nullable = this.nullable.bind(this);
		this.nullish = this.nullish.bind(this);
		this.array = this.array.bind(this);
		this.promise = this.promise.bind(this);
		this.or = this.or.bind(this);
		this.and = this.and.bind(this);
		this.transform = this.transform.bind(this);
		this.brand = this.brand.bind(this);
		this.default = this.default.bind(this);
		this.catch = this.catch.bind(this);
		this.describe = this.describe.bind(this);
		this.pipe = this.pipe.bind(this);
		this.readonly = this.readonly.bind(this);
		this.isNullable = this.isNullable.bind(this);
		this.isOptional = this.isOptional.bind(this);
	}
	get description() {
		return this._def.description;
	}
	_getType(input) {
		return getParsedType(input.data);
	}
	_getOrReturnCtx(input, ctx) {
		return ctx || {
			common: input.parent.common,
			data: input.data,
			parsedType: getParsedType(input.data),
			schemaErrorMap: this._def.errorMap,
			path: input.path,
			parent: input.parent
		};
	}
	_processInputParams(input) {
		return {
			status: new ParseStatus(),
			ctx: {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent
			}
		};
	}
	_parseSync(input) {
		const result = this._parse(input);
		if (isAsync(result)) throw new Error("Synchronous parse encountered promise.");
		return result;
	}
	_parseAsync(input) {
		const result = this._parse(input);
		return Promise.resolve(result);
	}
	parse(data$1, params) {
		const result = this.safeParse(data$1, params);
		if (result.success) return result.data;
		throw result.error;
	}
	safeParse(data$1, params) {
		var _a;
		const ctx = {
			common: {
				issues: [],
				async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
				contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
			},
			path: (params === null || params === void 0 ? void 0 : params.path) || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data: data$1,
			parsedType: getParsedType(data$1)
		};
		return handleResult(ctx, this._parseSync({
			data: data$1,
			path: ctx.path,
			parent: ctx
		}));
	}
	async parseAsync(data$1, params) {
		const result = await this.safeParseAsync(data$1, params);
		if (result.success) return result.data;
		throw result.error;
	}
	async safeParseAsync(data$1, params) {
		const ctx = {
			common: {
				issues: [],
				contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
				async: true
			},
			path: (params === null || params === void 0 ? void 0 : params.path) || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data: data$1,
			parsedType: getParsedType(data$1)
		};
		const maybeAsyncResult = this._parse({
			data: data$1,
			path: ctx.path,
			parent: ctx
		});
		return handleResult(ctx, await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult)));
	}
	refine(check, message) {
		const getIssueProperties = (val) => {
			if (typeof message === "string" || typeof message === "undefined") return { message };
			else if (typeof message === "function") return message(val);
			else return message;
		};
		return this._refinement((val, ctx) => {
			const result = check(val);
			const setError = () => ctx.addIssue({
				code: ZodIssueCode.custom,
				...getIssueProperties(val)
			});
			if (typeof Promise !== "undefined" && result instanceof Promise) return result.then((data$1) => {
				if (!data$1) {
					setError();
					return false;
				} else return true;
			});
			if (!result) {
				setError();
				return false;
			} else return true;
		});
	}
	refinement(check, refinementData) {
		return this._refinement((val, ctx) => {
			if (!check(val)) {
				ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
				return false;
			} else return true;
		});
	}
	_refinement(refinement) {
		return new ZodEffects({
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "refinement",
				refinement
			}
		});
	}
	superRefine(refinement) {
		return this._refinement(refinement);
	}
	optional() {
		return ZodOptional.create(this, this._def);
	}
	nullable() {
		return ZodNullable.create(this, this._def);
	}
	nullish() {
		return this.nullable().optional();
	}
	array() {
		return ZodArray.create(this, this._def);
	}
	promise() {
		return ZodPromise.create(this, this._def);
	}
	or(option) {
		return ZodUnion.create([this, option], this._def);
	}
	and(incoming) {
		return ZodIntersection.create(this, incoming, this._def);
	}
	transform(transform) {
		return new ZodEffects({
			...processCreateParams(this._def),
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "transform",
				transform
			}
		});
	}
	default(def) {
		const defaultValueFunc = typeof def === "function" ? def : () => def;
		return new ZodDefault({
			...processCreateParams(this._def),
			innerType: this,
			defaultValue: defaultValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodDefault
		});
	}
	brand() {
		return new ZodBranded({
			typeName: ZodFirstPartyTypeKind.ZodBranded,
			type: this,
			...processCreateParams(this._def)
		});
	}
	catch(def) {
		const catchValueFunc = typeof def === "function" ? def : () => def;
		return new ZodCatch({
			...processCreateParams(this._def),
			innerType: this,
			catchValue: catchValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodCatch
		});
	}
	describe(description) {
		const This = this.constructor;
		return new This({
			...this._def,
			description
		});
	}
	pipe(target$1) {
		return ZodPipeline.create(this, target$1);
	}
	readonly() {
		return ZodReadonly.create(this);
	}
	isOptional() {
		return this.safeParse(void 0).success;
	}
	isNullable() {
		return this.safeParse(null).success;
	}
};
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
	if (args.precision) if (args.offset) return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	else return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
	else if (args.precision === 0) if (args.offset) return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	else return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
	else if (args.offset) return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	else return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
};
function isValidIP(ip, version$1) {
	if ((version$1 === "v4" || !version$1) && ipv4Regex.test(ip)) return true;
	if ((version$1 === "v6" || !version$1) && ipv6Regex.test(ip)) return true;
	return false;
}
var ZodString = class ZodString extends ZodType {
	constructor() {
		super(...arguments);
		this._regex = (regex, validation, message) => this.refinement((data$1) => regex.test(data$1), {
			validation,
			code: ZodIssueCode.invalid_string,
			...errorUtil.errToObj(message)
		});
		/**
		* @deprecated Use z.string().min(1) instead.
		* @see {@link ZodString.min}
		*/
		this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
		this.trim = () => new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "trim" }]
		});
		this.toLowerCase = () => new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toLowerCase" }]
		});
		this.toUpperCase = () => new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toUpperCase" }]
		});
	}
	_parse(input) {
		if (this._def.coerce) input.data = String(input.data);
		if (this._getType(input) !== ZodParsedType.string) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.string,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.length < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.length > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "length") {
			const tooBig = input.data.length > check.value;
			const tooSmall = input.data.length < check.value;
			if (tooBig || tooSmall) {
				ctx = this._getOrReturnCtx(input, ctx);
				if (tooBig) addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				else if (tooSmall) addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "email") {
			if (!emailRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "email",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "emoji") {
			if (!emojiRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "emoji",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "uuid") {
			if (!uuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "uuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cuid") {
			if (!cuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cuid2") {
			if (!cuid2Regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid2",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "ulid") {
			if (!ulidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ulid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "url") try {
			new URL(input.data);
		} catch (_a) {
			ctx = this._getOrReturnCtx(input, ctx);
			addIssueToContext(ctx, {
				validation: "url",
				code: ZodIssueCode.invalid_string,
				message: check.message
			});
			status.dirty();
		}
		else if (check.kind === "regex") {
			check.regex.lastIndex = 0;
			if (!check.regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "regex",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "trim") input.data = input.data.trim();
		else if (check.kind === "includes") {
			if (!input.data.includes(check.value, check.position)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: {
						includes: check.value,
						position: check.position
					},
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "toLowerCase") input.data = input.data.toLowerCase();
		else if (check.kind === "toUpperCase") input.data = input.data.toUpperCase();
		else if (check.kind === "startsWith") {
			if (!input.data.startsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { startsWith: check.value },
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "endsWith") {
			if (!input.data.endsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { endsWith: check.value },
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "datetime") {
			if (!datetimeRegex(check).test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "datetime",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "ip") {
			if (!isValidIP(input.data, check.version)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ip",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	_addCheck(check) {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	email(message) {
		return this._addCheck({
			kind: "email",
			...errorUtil.errToObj(message)
		});
	}
	url(message) {
		return this._addCheck({
			kind: "url",
			...errorUtil.errToObj(message)
		});
	}
	emoji(message) {
		return this._addCheck({
			kind: "emoji",
			...errorUtil.errToObj(message)
		});
	}
	uuid(message) {
		return this._addCheck({
			kind: "uuid",
			...errorUtil.errToObj(message)
		});
	}
	cuid(message) {
		return this._addCheck({
			kind: "cuid",
			...errorUtil.errToObj(message)
		});
	}
	cuid2(message) {
		return this._addCheck({
			kind: "cuid2",
			...errorUtil.errToObj(message)
		});
	}
	ulid(message) {
		return this._addCheck({
			kind: "ulid",
			...errorUtil.errToObj(message)
		});
	}
	ip(options) {
		return this._addCheck({
			kind: "ip",
			...errorUtil.errToObj(options)
		});
	}
	datetime(options) {
		var _a;
		if (typeof options === "string") return this._addCheck({
			kind: "datetime",
			precision: null,
			offset: false,
			message: options
		});
		return this._addCheck({
			kind: "datetime",
			precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
			offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
			...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
		});
	}
	regex(regex, message) {
		return this._addCheck({
			kind: "regex",
			regex,
			...errorUtil.errToObj(message)
		});
	}
	includes(value, options) {
		return this._addCheck({
			kind: "includes",
			value,
			position: options === null || options === void 0 ? void 0 : options.position,
			...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
		});
	}
	startsWith(value, message) {
		return this._addCheck({
			kind: "startsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	endsWith(value, message) {
		return this._addCheck({
			kind: "endsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	min(minLength, message) {
		return this._addCheck({
			kind: "min",
			value: minLength,
			...errorUtil.errToObj(message)
		});
	}
	max(maxLength, message) {
		return this._addCheck({
			kind: "max",
			value: maxLength,
			...errorUtil.errToObj(message)
		});
	}
	length(len, message) {
		return this._addCheck({
			kind: "length",
			value: len,
			...errorUtil.errToObj(message)
		});
	}
	get isDatetime() {
		return !!this._def.checks.find((ch) => ch.kind === "datetime");
	}
	get isEmail() {
		return !!this._def.checks.find((ch) => ch.kind === "email");
	}
	get isURL() {
		return !!this._def.checks.find((ch) => ch.kind === "url");
	}
	get isEmoji() {
		return !!this._def.checks.find((ch) => ch.kind === "emoji");
	}
	get isUUID() {
		return !!this._def.checks.find((ch) => ch.kind === "uuid");
	}
	get isCUID() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid");
	}
	get isCUID2() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	}
	get isULID() {
		return !!this._def.checks.find((ch) => ch.kind === "ulid");
	}
	get isIP() {
		return !!this._def.checks.find((ch) => ch.kind === "ip");
	}
	get minLength() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxLength() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
};
ZodString.create = (params) => {
	var _a;
	return new ZodString({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodString,
		coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
		...processCreateParams(params)
	});
};
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepDecCount = (step.toString().split(".")[1] || "").length;
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	return parseInt(val.toFixed(decCount).replace(".", "")) % parseInt(step.toFixed(decCount).replace(".", "")) / Math.pow(10, decCount);
}
var ZodNumber = class ZodNumber extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
		this.step = this.multipleOf;
	}
	_parse(input) {
		if (this._def.coerce) input.data = Number(input.data);
		if (this._getType(input) !== ZodParsedType.number) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.number,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		let ctx = void 0;
		const status = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "int") {
			if (!util.isInteger(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: "integer",
					received: "float",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (floatSafeRemainder(input.data, check.value) !== 0) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "finite") {
			if (!Number.isFinite(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_finite,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	int(message) {
		return this._addCheck({
			kind: "int",
			message: errorUtil.toString(message)
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	finite(message) {
		return this._addCheck({
			kind: "finite",
			message: errorUtil.toString(message)
		});
	}
	safe(message) {
		return this._addCheck({
			kind: "min",
			inclusive: true,
			value: Number.MIN_SAFE_INTEGER,
			message: errorUtil.toString(message)
		})._addCheck({
			kind: "max",
			inclusive: true,
			value: Number.MAX_SAFE_INTEGER,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
	get isInt() {
		return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
	}
	get isFinite() {
		let max = null, min = null;
		for (const ch of this._def.checks) if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") return true;
		else if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		} else if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return Number.isFinite(min) && Number.isFinite(max);
	}
};
ZodNumber.create = (params) => {
	return new ZodNumber({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodNumber,
		coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
		...processCreateParams(params)
	});
};
var ZodBigInt = class ZodBigInt extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
	}
	_parse(input) {
		if (this._def.coerce) input.data = BigInt(input.data);
		if (this._getType(input) !== ZodParsedType.bigint) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.bigint,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		let ctx = void 0;
		const status = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					type: "bigint",
					minimum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					type: "bigint",
					maximum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (input.data % check.value !== BigInt(0)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
};
ZodBigInt.create = (params) => {
	var _a;
	return new ZodBigInt({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodBigInt,
		coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
		...processCreateParams(params)
	});
};
var ZodBoolean = class extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = Boolean(input.data);
		if (this._getType(input) !== ZodParsedType.boolean) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.boolean,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodBoolean.create = (params) => {
	return new ZodBoolean({
		typeName: ZodFirstPartyTypeKind.ZodBoolean,
		coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
		...processCreateParams(params)
	});
};
var ZodDate = class ZodDate extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = new Date(input.data);
		if (this._getType(input) !== ZodParsedType.date) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.date,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		if (isNaN(input.data.getTime())) {
			addIssueToContext(this._getOrReturnCtx(input), { code: ZodIssueCode.invalid_date });
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.getTime() < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					message: check.message,
					inclusive: true,
					exact: false,
					minimum: check.value,
					type: "date"
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.getTime() > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					message: check.message,
					inclusive: true,
					exact: false,
					maximum: check.value,
					type: "date"
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: new Date(input.data.getTime())
		};
	}
	_addCheck(check) {
		return new ZodDate({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	min(minDate, message) {
		return this._addCheck({
			kind: "min",
			value: minDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	max(maxDate, message) {
		return this._addCheck({
			kind: "max",
			value: maxDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	get minDate() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min != null ? new Date(min) : null;
	}
	get maxDate() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max != null ? new Date(max) : null;
	}
};
ZodDate.create = (params) => {
	return new ZodDate({
		checks: [],
		coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
		typeName: ZodFirstPartyTypeKind.ZodDate,
		...processCreateParams(params)
	});
};
var ZodSymbol = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.symbol) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.symbol,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodSymbol.create = (params) => {
	return new ZodSymbol({
		typeName: ZodFirstPartyTypeKind.ZodSymbol,
		...processCreateParams(params)
	});
};
var ZodUndefined = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.undefined,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodUndefined.create = (params) => {
	return new ZodUndefined({
		typeName: ZodFirstPartyTypeKind.ZodUndefined,
		...processCreateParams(params)
	});
};
var ZodNull = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.null) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.null,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodNull.create = (params) => {
	return new ZodNull({
		typeName: ZodFirstPartyTypeKind.ZodNull,
		...processCreateParams(params)
	});
};
var ZodAny = class extends ZodType {
	constructor() {
		super(...arguments);
		this._any = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodAny.create = (params) => {
	return new ZodAny({
		typeName: ZodFirstPartyTypeKind.ZodAny,
		...processCreateParams(params)
	});
};
var ZodUnknown = class extends ZodType {
	constructor() {
		super(...arguments);
		this._unknown = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodUnknown.create = (params) => {
	return new ZodUnknown({
		typeName: ZodFirstPartyTypeKind.ZodUnknown,
		...processCreateParams(params)
	});
};
var ZodNever = class extends ZodType {
	_parse(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.never,
			received: ctx.parsedType
		});
		return INVALID;
	}
};
ZodNever.create = (params) => {
	return new ZodNever({
		typeName: ZodFirstPartyTypeKind.ZodNever,
		...processCreateParams(params)
	});
};
var ZodVoid = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.void,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodVoid.create = (params) => {
	return new ZodVoid({
		typeName: ZodFirstPartyTypeKind.ZodVoid,
		...processCreateParams(params)
	});
};
var ZodArray = class ZodArray extends ZodType {
	_parse(input) {
		const { ctx, status } = this._processInputParams(input);
		const def = this._def;
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (def.exactLength !== null) {
			const tooBig = ctx.data.length > def.exactLength.value;
			const tooSmall = ctx.data.length < def.exactLength.value;
			if (tooBig || tooSmall) {
				addIssueToContext(ctx, {
					code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
					minimum: tooSmall ? def.exactLength.value : void 0,
					maximum: tooBig ? def.exactLength.value : void 0,
					type: "array",
					inclusive: true,
					exact: true,
					message: def.exactLength.message
				});
				status.dirty();
			}
		}
		if (def.minLength !== null) {
			if (ctx.data.length < def.minLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.minLength.message
				});
				status.dirty();
			}
		}
		if (def.maxLength !== null) {
			if (ctx.data.length > def.maxLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.maxLength.message
				});
				status.dirty();
			}
		}
		if (ctx.common.async) return Promise.all([...ctx.data].map((item, i$1) => {
			return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i$1));
		})).then((result$1) => {
			return ParseStatus.mergeArray(status, result$1);
		});
		const result = [...ctx.data].map((item, i$1) => {
			return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i$1));
		});
		return ParseStatus.mergeArray(status, result);
	}
	get element() {
		return this._def.type;
	}
	min(minLength, message) {
		return new ZodArray({
			...this._def,
			minLength: {
				value: minLength,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxLength, message) {
		return new ZodArray({
			...this._def,
			maxLength: {
				value: maxLength,
				message: errorUtil.toString(message)
			}
		});
	}
	length(len, message) {
		return new ZodArray({
			...this._def,
			exactLength: {
				value: len,
				message: errorUtil.toString(message)
			}
		});
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodArray.create = (schema, params) => {
	return new ZodArray({
		type: schema,
		minLength: null,
		maxLength: null,
		exactLength: null,
		typeName: ZodFirstPartyTypeKind.ZodArray,
		...processCreateParams(params)
	});
};
function deepPartialify(schema) {
	if (schema instanceof ZodObject) {
		const newShape = {};
		for (const key in schema.shape) {
			const fieldSchema = schema.shape[key];
			newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
		}
		return new ZodObject({
			...schema._def,
			shape: () => newShape
		});
	} else if (schema instanceof ZodArray) return new ZodArray({
		...schema._def,
		type: deepPartialify(schema.element)
	});
	else if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	else return schema;
}
var ZodObject = class ZodObject extends ZodType {
	constructor() {
		super(...arguments);
		this._cached = null;
		/**
		* @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
		* If you want to pass through unknown properties, use `.passthrough()` instead.
		*/
		this.nonstrict = this.passthrough;
		/**
		* @deprecated Use `.extend` instead
		*  */
		this.augment = this.extend;
	}
	_getCached() {
		if (this._cached !== null) return this._cached;
		const shape = this._def.shape();
		return this._cached = {
			shape,
			keys: util.objectKeys(shape)
		};
	}
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.object) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const { status, ctx } = this._processInputParams(input);
		const { shape, keys: shapeKeys } = this._getCached();
		const extraKeys = [];
		if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
			for (const key in ctx.data) if (!shapeKeys.includes(key)) extraKeys.push(key);
		}
		const pairs = [];
		for (const key of shapeKeys) {
			const keyValidator = shape[key];
			const value = ctx.data[key];
			pairs.push({
				key: {
					status: "valid",
					value: key
				},
				value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
				alwaysSet: key in ctx.data
			});
		}
		if (this._def.catchall instanceof ZodNever) {
			const unknownKeys = this._def.unknownKeys;
			if (unknownKeys === "passthrough") for (const key of extraKeys) pairs.push({
				key: {
					status: "valid",
					value: key
				},
				value: {
					status: "valid",
					value: ctx.data[key]
				}
			});
			else if (unknownKeys === "strict") {
				if (extraKeys.length > 0) {
					addIssueToContext(ctx, {
						code: ZodIssueCode.unrecognized_keys,
						keys: extraKeys
					});
					status.dirty();
				}
			} else if (unknownKeys === "strip");
			else throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
		} else {
			const catchall = this._def.catchall;
			for (const key of extraKeys) {
				const value = ctx.data[key];
				pairs.push({
					key: {
						status: "valid",
						value: key
					},
					value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
					alwaysSet: key in ctx.data
				});
			}
		}
		if (ctx.common.async) return Promise.resolve().then(async () => {
			const syncPairs = [];
			for (const pair of pairs) {
				const key = await pair.key;
				syncPairs.push({
					key,
					value: await pair.value,
					alwaysSet: pair.alwaysSet
				});
			}
			return syncPairs;
		}).then((syncPairs) => {
			return ParseStatus.mergeObjectSync(status, syncPairs);
		});
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get shape() {
		return this._def.shape();
	}
	strict(message) {
		errorUtil.errToObj;
		return new ZodObject({
			...this._def,
			unknownKeys: "strict",
			...message !== void 0 ? { errorMap: (issue, ctx) => {
				var _a, _b, _c, _d;
				const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
				if (issue.code === "unrecognized_keys") return { message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError };
				return { message: defaultError };
			} } : {}
		});
	}
	strip() {
		return new ZodObject({
			...this._def,
			unknownKeys: "strip"
		});
	}
	passthrough() {
		return new ZodObject({
			...this._def,
			unknownKeys: "passthrough"
		});
	}
	extend(augmentation) {
		return new ZodObject({
			...this._def,
			shape: () => ({
				...this._def.shape(),
				...augmentation
			})
		});
	}
	/**
	* Prior to zod@1.0.12 there was a bug in the
	* inferred type of merged objects. Please
	* upgrade if you are experiencing issues.
	*/
	merge(merging) {
		return new ZodObject({
			unknownKeys: merging._def.unknownKeys,
			catchall: merging._def.catchall,
			shape: () => ({
				...this._def.shape(),
				...merging._def.shape()
			}),
			typeName: ZodFirstPartyTypeKind.ZodObject
		});
	}
	setKey(key, schema) {
		return this.augment({ [key]: schema });
	}
	catchall(index) {
		return new ZodObject({
			...this._def,
			catchall: index
		});
	}
	pick(mask) {
		const shape = {};
		util.objectKeys(mask).forEach((key) => {
			if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
		});
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	omit(mask) {
		const shape = {};
		util.objectKeys(this.shape).forEach((key) => {
			if (!mask[key]) shape[key] = this.shape[key];
		});
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	/**
	* @deprecated
	*/
	deepPartial() {
		return deepPartialify(this);
	}
	partial(mask) {
		const newShape = {};
		util.objectKeys(this.shape).forEach((key) => {
			const fieldSchema = this.shape[key];
			if (mask && !mask[key]) newShape[key] = fieldSchema;
			else newShape[key] = fieldSchema.optional();
		});
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	required(mask) {
		const newShape = {};
		util.objectKeys(this.shape).forEach((key) => {
			if (mask && !mask[key]) newShape[key] = this.shape[key];
			else {
				let newField = this.shape[key];
				while (newField instanceof ZodOptional) newField = newField._def.innerType;
				newShape[key] = newField;
			}
		});
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	keyof() {
		return createZodEnum(util.objectKeys(this.shape));
	}
};
ZodObject.create = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.strictCreate = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strict",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.lazycreate = (shape, params) => {
	return new ZodObject({
		shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
var ZodUnion = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const options = this._def.options;
		function handleResults(results) {
			for (const result of results) if (result.result.status === "valid") return result.result;
			for (const result of results) if (result.result.status === "dirty") {
				ctx.common.issues.push(...result.ctx.common.issues);
				return result.result;
			}
			const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
		if (ctx.common.async) return Promise.all(options.map(async (option) => {
			const childCtx = {
				...ctx,
				common: {
					...ctx.common,
					issues: []
				},
				parent: null
			};
			return {
				result: await option._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				}),
				ctx: childCtx
			};
		})).then(handleResults);
		else {
			let dirty = void 0;
			const issues = [];
			for (const option of options) {
				const childCtx = {
					...ctx,
					common: {
						...ctx.common,
						issues: []
					},
					parent: null
				};
				const result = option._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				});
				if (result.status === "valid") return result;
				else if (result.status === "dirty" && !dirty) dirty = {
					result,
					ctx: childCtx
				};
				if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
			}
			if (dirty) {
				ctx.common.issues.push(...dirty.ctx.common.issues);
				return dirty.result;
			}
			const unionErrors = issues.map((issues$1) => new ZodError(issues$1));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
	}
	get options() {
		return this._def.options;
	}
};
ZodUnion.create = (types$3, params) => {
	return new ZodUnion({
		options: types$3,
		typeName: ZodFirstPartyTypeKind.ZodUnion,
		...processCreateParams(params)
	});
};
const getDiscriminator = (type) => {
	if (type instanceof ZodLazy) return getDiscriminator(type.schema);
	else if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
	else if (type instanceof ZodLiteral) return [type.value];
	else if (type instanceof ZodEnum) return type.options;
	else if (type instanceof ZodNativeEnum) return Object.keys(type.enum);
	else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
	else if (type instanceof ZodUndefined) return [void 0];
	else if (type instanceof ZodNull) return [null];
	else return null;
};
var ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const discriminator = this.discriminator;
		const discriminatorValue = ctx.data[discriminator];
		const option = this.optionsMap.get(discriminatorValue);
		if (!option) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union_discriminator,
				options: Array.from(this.optionsMap.keys()),
				path: [discriminator]
			});
			return INVALID;
		}
		if (ctx.common.async) return option._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
		else return option._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
	get discriminator() {
		return this._def.discriminator;
	}
	get options() {
		return this._def.options;
	}
	get optionsMap() {
		return this._def.optionsMap;
	}
	/**
	* The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	* However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	* have a different value for each object in the union.
	* @param discriminator the name of the discriminator property
	* @param types an array of object schemas
	* @param params
	*/
	static create(discriminator, options, params) {
		const optionsMap = /* @__PURE__ */ new Map();
		for (const type of options) {
			const discriminatorValues = getDiscriminator(type.shape[discriminator]);
			if (!discriminatorValues) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
			for (const value of discriminatorValues) {
				if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
				optionsMap.set(value, type);
			}
		}
		return new ZodDiscriminatedUnion({
			typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
			discriminator,
			options,
			optionsMap,
			...processCreateParams(params)
		});
	}
};
function mergeValues(a, b) {
	const aType = getParsedType(a);
	const bType = getParsedType(b);
	if (a === b) return {
		valid: true,
		data: a
	};
	else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
		const bKeys = util.objectKeys(b);
		const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a[key], b[key]);
			if (!sharedValue.valid) return { valid: false };
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	} else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
		if (a.length !== b.length) return { valid: false };
		const newArray = [];
		for (let index = 0; index < a.length; index++) {
			const itemA = a[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return { valid: false };
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	} else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) return {
		valid: true,
		data: a
	};
	else return { valid: false };
}
var ZodIntersection = class extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const handleParsed = (parsedLeft, parsedRight) => {
			if (isAborted(parsedLeft) || isAborted(parsedRight)) return INVALID;
			const merged = mergeValues(parsedLeft.value, parsedRight.value);
			if (!merged.valid) {
				addIssueToContext(ctx, { code: ZodIssueCode.invalid_intersection_types });
				return INVALID;
			}
			if (isDirty(parsedLeft) || isDirty(parsedRight)) status.dirty();
			return {
				status: status.value,
				value: merged.data
			};
		};
		if (ctx.common.async) return Promise.all([this._def.left._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		})]).then(([left, right]) => handleParsed(left, right));
		else return handleParsed(this._def.left._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}));
	}
};
ZodIntersection.create = (left, right, params) => {
	return new ZodIntersection({
		left,
		right,
		typeName: ZodFirstPartyTypeKind.ZodIntersection,
		...processCreateParams(params)
	});
};
var ZodTuple = class ZodTuple extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (ctx.data.length < this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_small,
				minimum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			return INVALID;
		}
		if (!this._def.rest && ctx.data.length > this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_big,
				maximum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			status.dirty();
		}
		const items = [...ctx.data].map((item, itemIndex) => {
			const schema = this._def.items[itemIndex] || this._def.rest;
			if (!schema) return null;
			return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
		}).filter((x) => !!x);
		if (ctx.common.async) return Promise.all(items).then((results) => {
			return ParseStatus.mergeArray(status, results);
		});
		else return ParseStatus.mergeArray(status, items);
	}
	get items() {
		return this._def.items;
	}
	rest(rest) {
		return new ZodTuple({
			...this._def,
			rest
		});
	}
};
ZodTuple.create = (schemas, params) => {
	if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	return new ZodTuple({
		items: schemas,
		typeName: ZodFirstPartyTypeKind.ZodTuple,
		rest: null,
		...processCreateParams(params)
	});
};
var ZodRecord = class ZodRecord extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const pairs = [];
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		for (const key in ctx.data) pairs.push({
			key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
			value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
		});
		if (ctx.common.async) return ParseStatus.mergeObjectAsync(status, pairs);
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get element() {
		return this._def.valueType;
	}
	static create(first, second, third) {
		if (second instanceof ZodType) return new ZodRecord({
			keyType: first,
			valueType: second,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(third)
		});
		return new ZodRecord({
			keyType: ZodString.create(),
			valueType: first,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(second)
		});
	}
};
var ZodMap = class extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.map) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.map,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		const pairs = [...ctx.data.entries()].map(([key, value], index) => {
			return {
				key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
				value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
			};
		});
		if (ctx.common.async) {
			const finalMap = /* @__PURE__ */ new Map();
			return Promise.resolve().then(async () => {
				for (const pair of pairs) {
					const key = await pair.key;
					const value = await pair.value;
					if (key.status === "aborted" || value.status === "aborted") return INVALID;
					if (key.status === "dirty" || value.status === "dirty") status.dirty();
					finalMap.set(key.value, value.value);
				}
				return {
					status: status.value,
					value: finalMap
				};
			});
		} else {
			const finalMap = /* @__PURE__ */ new Map();
			for (const pair of pairs) {
				const key = pair.key;
				const value = pair.value;
				if (key.status === "aborted" || value.status === "aborted") return INVALID;
				if (key.status === "dirty" || value.status === "dirty") status.dirty();
				finalMap.set(key.value, value.value);
			}
			return {
				status: status.value,
				value: finalMap
			};
		}
	}
};
ZodMap.create = (keyType, valueType, params) => {
	return new ZodMap({
		valueType,
		keyType,
		typeName: ZodFirstPartyTypeKind.ZodMap,
		...processCreateParams(params)
	});
};
var ZodSet = class ZodSet extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.set) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.set,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const def = this._def;
		if (def.minSize !== null) {
			if (ctx.data.size < def.minSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.minSize.message
				});
				status.dirty();
			}
		}
		if (def.maxSize !== null) {
			if (ctx.data.size > def.maxSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.maxSize.message
				});
				status.dirty();
			}
		}
		const valueType = this._def.valueType;
		function finalizeSet(elements$1) {
			const parsedSet = /* @__PURE__ */ new Set();
			for (const element of elements$1) {
				if (element.status === "aborted") return INVALID;
				if (element.status === "dirty") status.dirty();
				parsedSet.add(element.value);
			}
			return {
				status: status.value,
				value: parsedSet
			};
		}
		const elements = [...ctx.data.values()].map((item, i$1) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i$1)));
		if (ctx.common.async) return Promise.all(elements).then((elements$1) => finalizeSet(elements$1));
		else return finalizeSet(elements);
	}
	min(minSize, message) {
		return new ZodSet({
			...this._def,
			minSize: {
				value: minSize,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxSize, message) {
		return new ZodSet({
			...this._def,
			maxSize: {
				value: maxSize,
				message: errorUtil.toString(message)
			}
		});
	}
	size(size, message) {
		return this.min(size, message).max(size, message);
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodSet.create = (valueType, params) => {
	return new ZodSet({
		valueType,
		minSize: null,
		maxSize: null,
		typeName: ZodFirstPartyTypeKind.ZodSet,
		...processCreateParams(params)
	});
};
var ZodFunction = class ZodFunction extends ZodType {
	constructor() {
		super(...arguments);
		this.validate = this.implement;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.function) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.function,
				received: ctx.parsedType
			});
			return INVALID;
		}
		function makeArgsIssue(args, error) {
			return makeIssue({
				data: args,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					errorMap
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_arguments,
					argumentsError: error
				}
			});
		}
		function makeReturnsIssue(returns, error) {
			return makeIssue({
				data: returns,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					errorMap
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_return_type,
					returnTypeError: error
				}
			});
		}
		const params = { errorMap: ctx.common.contextualErrorMap };
		const fn = ctx.data;
		if (this._def.returns instanceof ZodPromise) {
			const me = this;
			return OK(async function(...args) {
				const error = new ZodError([]);
				const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
					error.addIssue(makeArgsIssue(args, e));
					throw error;
				});
				const result = await Reflect.apply(fn, this, parsedArgs);
				return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
					error.addIssue(makeReturnsIssue(result, e));
					throw error;
				});
			});
		} else {
			const me = this;
			return OK(function(...args) {
				const parsedArgs = me._def.args.safeParse(args, params);
				if (!parsedArgs.success) throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
				const result = Reflect.apply(fn, this, parsedArgs.data);
				const parsedReturns = me._def.returns.safeParse(result, params);
				if (!parsedReturns.success) throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
				return parsedReturns.data;
			});
		}
	}
	parameters() {
		return this._def.args;
	}
	returnType() {
		return this._def.returns;
	}
	args(...items) {
		return new ZodFunction({
			...this._def,
			args: ZodTuple.create(items).rest(ZodUnknown.create())
		});
	}
	returns(returnType) {
		return new ZodFunction({
			...this._def,
			returns: returnType
		});
	}
	implement(func) {
		return this.parse(func);
	}
	strictImplement(func) {
		return this.parse(func);
	}
	static create(args, returns, params) {
		return new ZodFunction({
			args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
			returns: returns || ZodUnknown.create(),
			typeName: ZodFirstPartyTypeKind.ZodFunction,
			...processCreateParams(params)
		});
	}
};
var ZodLazy = class extends ZodType {
	get schema() {
		return this._def.getter();
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		return this._def.getter()._parse({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
};
ZodLazy.create = (getter, params) => {
	return new ZodLazy({
		getter,
		typeName: ZodFirstPartyTypeKind.ZodLazy,
		...processCreateParams(params)
	});
};
var ZodLiteral = class extends ZodType {
	_parse(input) {
		if (input.data !== this._def.value) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_literal,
				expected: this._def.value
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
	get value() {
		return this._def.value;
	}
};
ZodLiteral.create = (value, params) => {
	return new ZodLiteral({
		value,
		typeName: ZodFirstPartyTypeKind.ZodLiteral,
		...processCreateParams(params)
	});
};
function createZodEnum(values, params) {
	return new ZodEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodEnum,
		...processCreateParams(params)
	});
}
var ZodEnum = class ZodEnum extends ZodType {
	_parse(input) {
		if (typeof input.data !== "string") {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (this._def.values.indexOf(input.data) === -1) {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get options() {
		return this._def.values;
	}
	get enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Values() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	extract(values) {
		return ZodEnum.create(values);
	}
	exclude(values) {
		return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
	}
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
	_parse(input) {
		const nativeEnumValues = util.getValidEnumValues(this._def.values);
		const ctx = this._getOrReturnCtx(input);
		if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (nativeEnumValues.indexOf(input.data) === -1) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get enum() {
		return this._def.values;
	}
};
ZodNativeEnum.create = (values, params) => {
	return new ZodNativeEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
		...processCreateParams(params)
	});
};
var ZodPromise = class extends ZodType {
	unwrap() {
		return this._def.type;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.promise,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK((ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data)).then((data$1) => {
			return this._def.type.parseAsync(data$1, {
				path: ctx.path,
				errorMap: ctx.common.contextualErrorMap
			});
		}));
	}
};
ZodPromise.create = (schema, params) => {
	return new ZodPromise({
		type: schema,
		typeName: ZodFirstPartyTypeKind.ZodPromise,
		...processCreateParams(params)
	});
};
var ZodEffects = class extends ZodType {
	innerType() {
		return this._def.schema;
	}
	sourceType() {
		return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const effect = this._def.effect || null;
		const checkCtx = {
			addIssue: (arg) => {
				addIssueToContext(ctx, arg);
				if (arg.fatal) status.abort();
				else status.dirty();
			},
			get path() {
				return ctx.path;
			}
		};
		checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
		if (effect.type === "preprocess") {
			const processed = effect.transform(ctx.data, checkCtx);
			if (ctx.common.issues.length) return {
				status: "dirty",
				value: ctx.data
			};
			if (ctx.common.async) return Promise.resolve(processed).then((processed$1) => {
				return this._def.schema._parseAsync({
					data: processed$1,
					path: ctx.path,
					parent: ctx
				});
			});
			else return this._def.schema._parseSync({
				data: processed,
				path: ctx.path,
				parent: ctx
			});
		}
		if (effect.type === "refinement") {
			const executeRefinement = (acc) => {
				const result = effect.refinement(acc, checkCtx);
				if (ctx.common.async) return Promise.resolve(result);
				if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
				return acc;
			};
			if (ctx.common.async === false) {
				const inner = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				executeRefinement(inner.value);
				return {
					status: status.value,
					value: inner.value
				};
			} else return this._def.schema._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			}).then((inner) => {
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				return executeRefinement(inner.value).then(() => {
					return {
						status: status.value,
						value: inner.value
					};
				});
			});
		}
		if (effect.type === "transform") if (ctx.common.async === false) {
			const base = this._def.schema._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (!isValid(base)) return base;
			const result = effect.transform(base.value, checkCtx);
			if (result instanceof Promise) throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
			return {
				status: status.value,
				value: result
			};
		} else return this._def.schema._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}).then((base) => {
			if (!isValid(base)) return base;
			return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
				status: status.value,
				value: result
			}));
		});
		util.assertNever(effect);
	}
};
ZodEffects.create = (schema, effect, params) => {
	return new ZodEffects({
		schema,
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		effect,
		...processCreateParams(params)
	});
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	return new ZodEffects({
		schema,
		effect: {
			type: "preprocess",
			transform: preprocess
		},
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		...processCreateParams(params)
	});
};
var ZodOptional = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.undefined) return OK(void 0);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodOptional.create = (type, params) => {
	return new ZodOptional({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodOptional,
		...processCreateParams(params)
	});
};
var ZodNullable = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.null) return OK(null);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodNullable.create = (type, params) => {
	return new ZodNullable({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodNullable,
		...processCreateParams(params)
	});
};
var ZodDefault = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		let data$1 = ctx.data;
		if (ctx.parsedType === ZodParsedType.undefined) data$1 = this._def.defaultValue();
		return this._def.innerType._parse({
			data: data$1,
			path: ctx.path,
			parent: ctx
		});
	}
	removeDefault() {
		return this._def.innerType;
	}
};
ZodDefault.create = (type, params) => {
	return new ZodDefault({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodDefault,
		defaultValue: typeof params.default === "function" ? params.default : () => params.default,
		...processCreateParams(params)
	});
};
var ZodCatch = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const newCtx = {
			...ctx,
			common: {
				...ctx.common,
				issues: []
			}
		};
		const result = this._def.innerType._parse({
			data: newCtx.data,
			path: newCtx.path,
			parent: { ...newCtx }
		});
		if (isAsync(result)) return result.then((result$1) => {
			return {
				status: "valid",
				value: result$1.status === "valid" ? result$1.value : this._def.catchValue({
					get error() {
						return new ZodError(newCtx.common.issues);
					},
					input: newCtx.data
				})
			};
		});
		else return {
			status: "valid",
			value: result.status === "valid" ? result.value : this._def.catchValue({
				get error() {
					return new ZodError(newCtx.common.issues);
				},
				input: newCtx.data
			})
		};
	}
	removeCatch() {
		return this._def.innerType;
	}
};
ZodCatch.create = (type, params) => {
	return new ZodCatch({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodCatch,
		catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
		...processCreateParams(params)
	});
};
var ZodNaN = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.nan) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.nan,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
};
ZodNaN.create = (params) => {
	return new ZodNaN({
		typeName: ZodFirstPartyTypeKind.ZodNaN,
		...processCreateParams(params)
	});
};
const BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const data$1 = ctx.data;
		return this._def.type._parse({
			data: data$1,
			path: ctx.path,
			parent: ctx
		});
	}
	unwrap() {
		return this._def.type;
	}
};
var ZodPipeline = class ZodPipeline extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.common.async) {
			const handleAsync = async () => {
				const inResult = await this._def.in._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inResult.status === "aborted") return INVALID;
				if (inResult.status === "dirty") {
					status.dirty();
					return DIRTY(inResult.value);
				} else return this._def.out._parseAsync({
					data: inResult.value,
					path: ctx.path,
					parent: ctx
				});
			};
			return handleAsync();
		} else {
			const inResult = this._def.in._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (inResult.status === "aborted") return INVALID;
			if (inResult.status === "dirty") {
				status.dirty();
				return {
					status: "dirty",
					value: inResult.value
				};
			} else return this._def.out._parseSync({
				data: inResult.value,
				path: ctx.path,
				parent: ctx
			});
		}
	}
	static create(a, b) {
		return new ZodPipeline({
			in: a,
			out: b,
			typeName: ZodFirstPartyTypeKind.ZodPipeline
		});
	}
};
var ZodReadonly = class extends ZodType {
	_parse(input) {
		const result = this._def.innerType._parse(input);
		if (isValid(result)) result.value = Object.freeze(result.value);
		return result;
	}
};
ZodReadonly.create = (type, params) => {
	return new ZodReadonly({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodReadonly,
		...processCreateParams(params)
	});
};
const custom = (check, params = {}, fatal) => {
	if (check) return ZodAny.create().superRefine((data$1, ctx) => {
		var _a, _b;
		if (!check(data$1)) {
			const p = typeof params === "function" ? params(data$1) : typeof params === "string" ? { message: params } : params;
			const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
			const p2 = typeof p === "string" ? { message: p } : p;
			ctx.addIssue({
				code: "custom",
				...p2,
				fatal: _fatal
			});
		}
	});
	return ZodAny.create();
};
const late = { object: ZodObject.lazycreate };
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind$1) {
	ZodFirstPartyTypeKind$1["ZodString"] = "ZodString";
	ZodFirstPartyTypeKind$1["ZodNumber"] = "ZodNumber";
	ZodFirstPartyTypeKind$1["ZodNaN"] = "ZodNaN";
	ZodFirstPartyTypeKind$1["ZodBigInt"] = "ZodBigInt";
	ZodFirstPartyTypeKind$1["ZodBoolean"] = "ZodBoolean";
	ZodFirstPartyTypeKind$1["ZodDate"] = "ZodDate";
	ZodFirstPartyTypeKind$1["ZodSymbol"] = "ZodSymbol";
	ZodFirstPartyTypeKind$1["ZodUndefined"] = "ZodUndefined";
	ZodFirstPartyTypeKind$1["ZodNull"] = "ZodNull";
	ZodFirstPartyTypeKind$1["ZodAny"] = "ZodAny";
	ZodFirstPartyTypeKind$1["ZodUnknown"] = "ZodUnknown";
	ZodFirstPartyTypeKind$1["ZodNever"] = "ZodNever";
	ZodFirstPartyTypeKind$1["ZodVoid"] = "ZodVoid";
	ZodFirstPartyTypeKind$1["ZodArray"] = "ZodArray";
	ZodFirstPartyTypeKind$1["ZodObject"] = "ZodObject";
	ZodFirstPartyTypeKind$1["ZodUnion"] = "ZodUnion";
	ZodFirstPartyTypeKind$1["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	ZodFirstPartyTypeKind$1["ZodIntersection"] = "ZodIntersection";
	ZodFirstPartyTypeKind$1["ZodTuple"] = "ZodTuple";
	ZodFirstPartyTypeKind$1["ZodRecord"] = "ZodRecord";
	ZodFirstPartyTypeKind$1["ZodMap"] = "ZodMap";
	ZodFirstPartyTypeKind$1["ZodSet"] = "ZodSet";
	ZodFirstPartyTypeKind$1["ZodFunction"] = "ZodFunction";
	ZodFirstPartyTypeKind$1["ZodLazy"] = "ZodLazy";
	ZodFirstPartyTypeKind$1["ZodLiteral"] = "ZodLiteral";
	ZodFirstPartyTypeKind$1["ZodEnum"] = "ZodEnum";
	ZodFirstPartyTypeKind$1["ZodEffects"] = "ZodEffects";
	ZodFirstPartyTypeKind$1["ZodNativeEnum"] = "ZodNativeEnum";
	ZodFirstPartyTypeKind$1["ZodOptional"] = "ZodOptional";
	ZodFirstPartyTypeKind$1["ZodNullable"] = "ZodNullable";
	ZodFirstPartyTypeKind$1["ZodDefault"] = "ZodDefault";
	ZodFirstPartyTypeKind$1["ZodCatch"] = "ZodCatch";
	ZodFirstPartyTypeKind$1["ZodPromise"] = "ZodPromise";
	ZodFirstPartyTypeKind$1["ZodBranded"] = "ZodBranded";
	ZodFirstPartyTypeKind$1["ZodPipeline"] = "ZodPipeline";
	ZodFirstPartyTypeKind$1["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = { message: `Input not instance of ${cls.name}` }) => custom((data$1) => data$1 instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
	string: ((arg) => ZodString.create({
		...arg,
		coerce: true
	})),
	number: ((arg) => ZodNumber.create({
		...arg,
		coerce: true
	})),
	boolean: ((arg) => ZodBoolean.create({
		...arg,
		coerce: true
	})),
	bigint: ((arg) => ZodBigInt.create({
		...arg,
		coerce: true
	})),
	date: ((arg) => ZodDate.create({
		...arg,
		coerce: true
	}))
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	defaultErrorMap: errorMap,
	setErrorMap,
	getErrorMap,
	makeIssue,
	EMPTY_PATH,
	addIssueToContext,
	ParseStatus,
	INVALID,
	DIRTY,
	OK,
	isAborted,
	isDirty,
	isValid,
	isAsync,
	get util() {
		return util;
	},
	get objectUtil() {
		return objectUtil;
	},
	ZodParsedType,
	getParsedType,
	ZodType,
	ZodString,
	ZodNumber,
	ZodBigInt,
	ZodBoolean,
	ZodDate,
	ZodSymbol,
	ZodUndefined,
	ZodNull,
	ZodAny,
	ZodUnknown,
	ZodNever,
	ZodVoid,
	ZodArray,
	ZodObject,
	ZodUnion,
	ZodDiscriminatedUnion,
	ZodIntersection,
	ZodTuple,
	ZodRecord,
	ZodMap,
	ZodSet,
	ZodFunction,
	ZodLazy,
	ZodLiteral,
	ZodEnum,
	ZodNativeEnum,
	ZodPromise,
	ZodEffects,
	ZodTransformer: ZodEffects,
	ZodOptional,
	ZodNullable,
	ZodDefault,
	ZodCatch,
	ZodNaN,
	BRAND,
	ZodBranded,
	ZodPipeline,
	ZodReadonly,
	custom,
	Schema: ZodType,
	ZodSchema: ZodType,
	late,
	get ZodFirstPartyTypeKind() {
		return ZodFirstPartyTypeKind;
	},
	coerce,
	any: anyType,
	array: arrayType,
	bigint: bigIntType,
	boolean: booleanType,
	date: dateType,
	discriminatedUnion: discriminatedUnionType,
	effect: effectsType,
	"enum": enumType,
	"function": functionType,
	"instanceof": instanceOfType,
	intersection: intersectionType,
	lazy: lazyType,
	literal: literalType,
	map: mapType,
	nan: nanType,
	nativeEnum: nativeEnumType,
	never: neverType,
	"null": nullType,
	nullable: nullableType,
	number: numberType,
	object: objectType,
	oboolean,
	onumber,
	optional: optionalType,
	ostring,
	pipeline: pipelineType,
	preprocess: preprocessType,
	promise: promiseType,
	record: recordType,
	set: setType,
	strictObject: strictObjectType,
	string: stringType,
	symbol: symbolType,
	transformer: effectsType,
	tuple: tupleType,
	"undefined": undefinedType,
	union: unionType,
	unknown: unknownType,
	"void": voidType,
	NEVER,
	ZodIssueCode,
	quotelessJson,
	ZodError
});

//#endregion
//#region ../workers-shared/utils/types.ts
const InternalConfigSchema = z.object({
	account_id: z.number().optional(),
	script_id: z.number().optional(),
	debug: z.boolean().optional()
});
const StaticRoutingSchema = z.object({
	user_worker: z.array(z.string()),
	asset_worker: z.array(z.string()).optional()
});
const RouterConfigSchema = z.object({
	invoke_user_worker_ahead_of_assets: z.boolean().optional(),
	static_routing: StaticRoutingSchema.optional(),
	has_user_worker: z.boolean().optional(),
	...InternalConfigSchema.shape
});
const EyeballRouterConfigSchema = z.union([z.object({ limitedAssetsOnly: z.boolean().optional() }), z.null()]);
const MetadataStaticRedirectEntry = z.object({
	status: z.number(),
	to: z.string(),
	lineNumber: z.number()
});
const MetadataRedirectEntry = z.object({
	status: z.number(),
	to: z.string()
});
const MetadataStaticRedirects = z.record(MetadataStaticRedirectEntry);
const MetadataRedirects = z.record(MetadataRedirectEntry);
const MetadataHeaderEntry = z.object({
	set: z.record(z.string()).optional(),
	unset: z.array(z.string()).optional()
});
const MetadataHeaders = z.record(MetadataHeaderEntry);
const RedirectsSchema = z.object({
	version: z.literal(1),
	staticRules: MetadataStaticRedirects,
	rules: MetadataRedirects
}).optional();
const HeadersSchema = z.object({
	version: z.literal(2),
	rules: MetadataHeaders
}).optional();
const AssetConfigSchema = z.object({
	compatibility_date: z.string().optional(),
	compatibility_flags: z.array(z.string()).optional(),
	html_handling: z.enum([
		"auto-trailing-slash",
		"force-trailing-slash",
		"drop-trailing-slash",
		"none"
	]).optional(),
	not_found_handling: z.enum([
		"single-page-application",
		"404-page",
		"none"
	]).optional(),
	redirects: RedirectsSchema,
	headers: HeadersSchema,
	has_static_routing: z.boolean().optional(),
	...InternalConfigSchema.shape
});

//#endregion
//#region src/asset-config.ts
/**
* Returns true if the `changedFile` matches one of the _headers or _redirects files,
* and the experimental support for these files is turned on.
*/
function hasAssetsConfigChanged(resolvedPluginConfig, resolvedViteConfig, changedFilePath) {
	if (!resolvedPluginConfig.experimental?.headersAndRedirectsDevModeSupport) return false;
	return [getRedirectsConfigPath(resolvedViteConfig), getHeadersConfigPath(resolvedViteConfig)].includes(changedFilePath);
}
/**
* Computes the assets config that will be passed to Miniflare,
* taking into account whether experimental _headers and _redirects support is on.
*/
function getAssetsConfig(resolvedPluginConfig, entryWorkerConfig, resolvedConfig) {
	const assetsConfig = resolvedPluginConfig.type === "assets-only" ? resolvedPluginConfig.config.assets : entryWorkerConfig?.assets;
	const config = {
		...resolvedPluginConfig.type === "assets-only" ? {
			compatibility_date: resolvedPluginConfig.config.compatibility_date,
			compatibility_flags: resolvedPluginConfig.config.compatibility_flags
		} : {
			...entryWorkerConfig?.compatibility_date ? { compatibility_date: entryWorkerConfig.compatibility_date } : {},
			...entryWorkerConfig?.compatibility_flags ? { compatibility_flags: entryWorkerConfig.compatibility_flags } : {}
		},
		...assetsConfig,
		has_static_routing: resolvedPluginConfig.type === "workers" && resolvedPluginConfig.staticRouting ? true : false
	};
	if (!resolvedPluginConfig.experimental?.headersAndRedirectsDevModeSupport) return config;
	const logger = {
		debug() {},
		log(message) {
			resolvedConfig.logger.info(message);
		},
		info(message) {
			resolvedConfig.logger.info(message);
		},
		warn(message) {
			resolvedConfig.logger.warn(message);
		},
		error(error) {
			resolvedConfig.logger.error(error.message, { error });
		}
	};
	const redirectsFile = getRedirectsConfigPath(resolvedConfig);
	const redirectsContents = maybeGetFile(redirectsFile);
	const redirects = redirectsContents && RedirectsSchema.parse(constructRedirects({
		redirects: parseRedirects(redirectsContents),
		redirectsFile,
		logger
	}).redirects);
	const headersFile = getHeadersConfigPath(resolvedConfig);
	const headersContents = maybeGetFile(headersFile);
	const headers = headersContents && HeadersSchema.parse(constructHeaders({
		headers: parseHeaders(headersContents),
		headersFile,
		logger
	}).headers);
	return {
		...config,
		...redirects ? { redirects } : {},
		...headers ? { headers } : {}
	};
}
function getRedirectsConfigPath(config) {
	return path$2.join(config.publicDir, REDIRECTS_FILENAME);
}
function getHeadersConfigPath(config) {
	return path$2.join(config.publicDir, HEADERS_FILENAME);
}

//#endregion
//#region src/shared.ts
const UNKNOWN_HOST = "http://localhost";
const INIT_PATH = "/__vite_plugin_cloudflare_init__";
const GET_EXPORT_TYPES_PATH = "/__vite_plugin_cloudflare_get_export_types__";
const WORKER_ENTRY_PATH_HEADER = "__VITE_WORKER_ENTRY_PATH__";
const IS_ENTRY_WORKER_HEADER = "__VITE_IS_ENTRY_WORKER__";
const virtualPrefix = "virtual:cloudflare/";
const VIRTUAL_WORKER_ENTRY = `${virtualPrefix}worker-entry`;
const VIRTUAL_EXPORT_TYPES = `${virtualPrefix}export-types`;

//#endregion
//#region src/plugins/virtual-modules.ts
const VIRTUAL_USER_ENTRY = `${virtualPrefix}user-entry`;
const VIRTUAL_CLIENT_FALLBACK_ENTRY = `${virtualPrefix}client-fallback-entry`;
/**
* Plugin to provide virtual modules
*/
const virtualModulesPlugin = createPlugin("virtual-modules", (ctx) => {
	return {
		applyToEnvironment(environment) {
			return ctx.getWorkerConfig(environment.name) !== void 0;
		},
		resolveId(source) {
			if (source === VIRTUAL_WORKER_ENTRY || source === VIRTUAL_EXPORT_TYPES) return `\0${source}`;
			if (source === VIRTUAL_USER_ENTRY) {
				const workerConfig = ctx.getWorkerConfig(this.environment.name);
				assert(workerConfig, "Expected `workerConfig` to be defined");
				return this.resolve(workerConfig.main);
			}
		},
		load(id) {
			if (id === `\0${VIRTUAL_WORKER_ENTRY}`) {
				const nodeJsCompat = ctx.getNodeJsCompat(this.environment.name);
				return `
${nodeJsCompat ? nodeJsCompat.injectGlobalCode() : ""}
import { getExportTypes } from "${VIRTUAL_EXPORT_TYPES}";
import * as mod from "${VIRTUAL_USER_ENTRY}";
export * from "${VIRTUAL_USER_ENTRY}";
export default mod.default ?? {};
if (import.meta.hot) {
	import.meta.hot.accept((module) => {
		const exportTypes = getExportTypes(module);
		import.meta.hot.send("vite-plugin-cloudflare:worker-export-types", exportTypes);
	});
}
				`;
			}
			if (id === `\0${VIRTUAL_EXPORT_TYPES}`) return `
import {
	WorkerEntrypoint,
	DurableObject,
	WorkflowEntrypoint,
} from "cloudflare:workers";

const baseClasses = new Map([
	["WorkerEntrypoint", WorkerEntrypoint],
	["DurableObject", DurableObject],
	["WorkflowEntrypoint", WorkflowEntrypoint],
]);

export function getExportTypes(module) {
	const exportTypes = {};

	for (const [key, value] of Object.entries(module)) {
		if (key === "default") {
			continue;
		}

		let exportType

		if (typeof value === "function") {
			for (const [type, baseClass] of baseClasses) {
				if (baseClass.prototype.isPrototypeOf(value.prototype)) {
					exportType = type;
					break;
				}
			}
		}

		exportTypes[key] = exportType;
	}

	return exportTypes;
}
				`;
		}
	};
});
/**
* Plugin to provide a virtual fallback entry file for the `client` environment.
* This is used as the entry file for the client build when only the `public` directory is present.
*/
const virtualClientFallbackPlugin = createPlugin("virtual-client-fallback", () => {
	return {
		applyToEnvironment(environment) {
			return environment.name === "client";
		},
		resolveId(source) {
			if (source === VIRTUAL_CLIENT_FALLBACK_ENTRY) return `\0${VIRTUAL_CLIENT_FALLBACK_ENTRY}`;
		},
		load(id) {
			if (id === `\0${VIRTUAL_CLIENT_FALLBACK_ENTRY}`) return ``;
		}
	};
});

//#endregion
//#region src/build.ts
const CLIENT_FALLBACK_ENTRY_NAME = "__cloudflare_fallback_entry__";
function createBuildApp(resolvedPluginConfig) {
	return async (builder) => {
		const clientEnvironment = builder.environments.client;
		assert(clientEnvironment, `No "client" environment`);
		const defaultHtmlPath = path$2.resolve(builder.config.root, "index.html");
		const hasClientEntry = clientEnvironment.config.build.rollupOptions.input || fs$1.existsSync(defaultHtmlPath);
		if (resolvedPluginConfig.type === "assets-only") {
			if (hasClientEntry) await builder.build(clientEnvironment);
			else if (getHasPublicAssets(builder.config)) await fallbackBuild(builder, clientEnvironment);
			return;
		}
		const workerEnvironments = [...resolvedPluginConfig.environmentNameToWorkerMap.keys()].map((environmentName) => {
			const environment = builder.environments[environmentName];
			assert(environment, `"${environmentName}" environment not found`);
			return environment;
		});
		await Promise.all(workerEnvironments.map((environment) => builder.build(environment)));
		const { entryWorkerEnvironmentName } = resolvedPluginConfig;
		const entryWorkerEnvironment = builder.environments[entryWorkerEnvironmentName];
		assert(entryWorkerEnvironment, `No "${entryWorkerEnvironmentName}" environment`);
		const entryWorkerBuildDirectory = path$2.resolve(builder.config.root, entryWorkerEnvironment.config.build.outDir);
		const importedAssetPaths = getImportedAssetPaths(loadViteManifest(entryWorkerBuildDirectory));
		if (hasClientEntry) await builder.build(clientEnvironment);
		else if (importedAssetPaths.size || getHasPublicAssets(builder.config)) await fallbackBuild(builder, clientEnvironment);
		else {
			const entryWorkerConfigPath = path$2.join(entryWorkerBuildDirectory, "wrangler.json");
			const workerConfig = JSON.parse(fs$1.readFileSync(entryWorkerConfigPath, "utf-8"));
			workerConfig.assets = void 0;
			fs$1.writeFileSync(entryWorkerConfigPath, JSON.stringify(workerConfig));
			return;
		}
		const clientBuildDirectory = path$2.resolve(builder.config.root, clientEnvironment.config.build.outDir);
		const movedAssetPaths = [];
		for (const assetPath of importedAssetPaths) {
			const src = path$2.join(entryWorkerBuildDirectory, assetPath);
			const dest = path$2.join(clientBuildDirectory, assetPath);
			if (!fs$1.existsSync(src)) continue;
			if (fs$1.existsSync(dest)) fs$1.unlinkSync(src);
			else {
				const destDir = path$2.dirname(dest);
				fs$1.mkdirSync(destDir, { recursive: true });
				fs$1.renameSync(src, dest);
				movedAssetPaths.push(dest);
			}
		}
		if (movedAssetPaths.length) builder.config.logger.info([`${colors.green("✓")} ${movedAssetPaths.length} asset${movedAssetPaths.length > 1 ? "s" : ""} moved from "${entryWorkerEnvironmentName}" to "client" build output.`, ...movedAssetPaths.map((assetPath) => colors.dim(path$2.relative(builder.config.root, assetPath)))].join("\n"));
	};
}
function getHasPublicAssets({ publicDir }) {
	let hasPublicAssets = false;
	if (publicDir) try {
		if (fs$1.readdirSync(publicDir).length) hasPublicAssets = true;
	} catch (error) {}
	return hasPublicAssets;
}
async function fallbackBuild(builder, environment) {
	environment.config.build.rollupOptions = {
		input: VIRTUAL_CLIENT_FALLBACK_ENTRY,
		logLevel: "silent",
		output: { entryFileNames: CLIENT_FALLBACK_ENTRY_NAME }
	};
	await builder.build(environment);
	const fallbackEntryPath = path$2.resolve(builder.config.root, environment.config.build.outDir, CLIENT_FALLBACK_ENTRY_NAME);
	fs$1.unlinkSync(fallbackEntryPath);
}
function loadViteManifest(directory) {
	const contents = fs$1.readFileSync(path$2.resolve(directory, ".vite", "manifest.json"), "utf-8");
	return JSON.parse(contents);
}
function getImportedAssetPaths(viteManifest) {
	const assetPaths = Object.values(viteManifest).flatMap((chunk) => chunk.assets ?? []);
	return new Set(assetPaths);
}

//#endregion
//#region src/cloudflare-environment.ts
const MAIN_ENTRY_NAME = "index";
const webSocketUndefinedError = "The WebSocket is undefined";
function createHotChannel(webSocketContainer) {
	const listenersMap = /* @__PURE__ */ new Map();
	const client = { send(payload) {
		const webSocket = webSocketContainer.webSocket;
		assert(webSocket, webSocketUndefinedError);
		webSocket.send(JSON.stringify(payload));
	} };
	function onMessage(event) {
		const payload = JSON.parse(event.data.toString());
		const listeners = listenersMap.get(payload.event) ?? /* @__PURE__ */ new Set();
		for (const listener of listeners) listener(payload.data, client);
	}
	return {
		send(payload) {
			const webSocket = webSocketContainer.webSocket;
			assert(webSocket, webSocketUndefinedError);
			webSocket.send(JSON.stringify(payload));
		},
		on(event, listener) {
			const listeners = listenersMap.get(event) ?? /* @__PURE__ */ new Set();
			listeners.add(listener);
			listenersMap.set(event, listeners);
		},
		off(event, listener) {
			listenersMap.get(event)?.delete(listener);
		},
		listen() {
			const webSocket = webSocketContainer.webSocket;
			assert(webSocket, webSocketUndefinedError);
			webSocket.addEventListener("message", onMessage);
		},
		close() {
			const webSocket = webSocketContainer.webSocket;
			assert(webSocket, webSocketUndefinedError);
			webSocket.removeEventListener("message", onMessage);
		}
	};
}
var CloudflareDevEnvironment = class extends vite.DevEnvironment {
	#webSocketContainer;
	constructor(name, config) {
		const webSocketContainer = {};
		super(name, config, {
			hot: true,
			transport: createHotChannel(webSocketContainer)
		});
		this.#webSocketContainer = webSocketContainer;
	}
	async initRunner(miniflare, workerConfig, isEntryWorker) {
		const response = await miniflare.dispatchFetch(new URL(INIT_PATH, UNKNOWN_HOST), { headers: {
			[CoreHeaders.ROUTE_OVERRIDE]: workerConfig.name,
			[WORKER_ENTRY_PATH_HEADER]: encodeURIComponent(workerConfig.main),
			[IS_ENTRY_WORKER_HEADER]: String(isEntryWorker),
			upgrade: "websocket"
		} });
		assert(response.ok, `Failed to initialize module runner, error: ${await response.text()}`);
		const webSocket = response.webSocket;
		assert(webSocket, "Failed to establish WebSocket");
		webSocket.accept();
		this.#webSocketContainer.webSocket = webSocket;
	}
	async fetchWorkerExportTypes(miniflare, workerConfig) {
		await this.depsOptimizer?.init();
		return await (await miniflare.dispatchFetch(new URL(GET_EXPORT_TYPES_PATH, UNKNOWN_HOST), { headers: { [CoreHeaders.ROUTE_OVERRIDE]: workerConfig.name } })).json();
	}
	async fetchModule(id, importer, options) {
		if (additionalModuleRE.test(id)) return {
			externalize: id,
			type: "module"
		};
		return super.fetchModule(id, importer, options);
	}
};
const cloudflareBuiltInModules = [
	"cloudflare:email",
	"cloudflare:node",
	"cloudflare:sockets",
	"cloudflare:workers",
	"cloudflare:workflows"
];
const defaultConditions = [
	"workerd",
	"worker",
	"module",
	"browser"
];
const target = "es2022";
function createCloudflareEnvironmentOptions({ workerConfig, userConfig, mode, environmentName, isEntryWorker, hasNodeJsCompat: hasNodeJsCompat$1 }) {
	const define$1 = getProcessEnvReplacements(hasNodeJsCompat$1, mode);
	return {
		resolve: {
			noExternal: true,
			conditions: [...defaultConditions, "development|production"],
			builtins: [...cloudflareBuiltInModules]
		},
		define: define$1,
		dev: { createEnvironment(name, config) {
			return new CloudflareDevEnvironment(name, config);
		} },
		build: {
			createEnvironment(name, config) {
				return new vite.BuildEnvironment(name, config);
			},
			target,
			emitAssets: true,
			manifest: isEntryWorker,
			outDir: getOutputDirectory(userConfig, environmentName),
			copyPublicDir: false,
			ssr: true,
			rollupOptions: {
				input: { [MAIN_ENTRY_NAME]: VIRTUAL_WORKER_ENTRY },
				preserveEntrySignatures: "strict",
				..."rolldownVersion" in vite ? { platform: "neutral" } : {}
			}
		},
		optimizeDeps: {
			noDiscovery: false,
			entries: vite.normalizePath(workerConfig.main),
			exclude: [...cloudflareBuiltInModules],
			esbuildOptions: {
				platform: "neutral",
				target,
				conditions: [...defaultConditions, "development"],
				resolveExtensions: [
					".mjs",
					".js",
					".mts",
					".ts",
					".jsx",
					".tsx",
					".json",
					".cjs",
					".cts",
					".ctx"
				],
				define: define$1
			}
		},
		keepProcessEnv: true
	};
}
/**
* Gets `process.env` replacement values.
* `process.env.NODE_ENV` is always replaced.
* `process.env` is replaced with an empty object if `nodejs_compat` is not enabled
* @param hasNodeJsCompat - whether `nodejs_compat` is enabled
* @param mode - the Vite mode
* @returns replacement values
*/
function getProcessEnvReplacements(hasNodeJsCompat$1, mode) {
	const nodeEnv = process.env.NODE_ENV || mode;
	const nodeEnvReplacements = {
		"process.env.NODE_ENV": JSON.stringify(nodeEnv),
		"global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
		"globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv)
	};
	return hasNodeJsCompat$1 ? nodeEnvReplacements : {
		...nodeEnvReplacements,
		"process.env": "{}",
		"global.process.env": "{}",
		"globalThis.process.env": "{}"
	};
}
function initRunners(resolvedPluginConfig, viteDevServer, miniflare) {
	return Promise.all([...resolvedPluginConfig.environmentNameToWorkerMap].map(([environmentName, worker]) => {
		debuglog("Initializing worker:", worker.config.name);
		const isEntryWorker = environmentName === resolvedPluginConfig.entryWorkerEnvironmentName;
		return viteDevServer.environments[environmentName].initRunner(miniflare, worker.config, isEntryWorker);
	}));
}

//#endregion
//#region src/dev-vars.ts
/**
* Gets any variables with which to augment the Worker config in preview mode.
*
* Calls `unstable_getVarsForDev` with the current Cloudflare environment to get local dev variables from the `.dev.vars` and `.env` files.
*/
function getLocalDevVarsForPreview(configPath, cloudflareEnv) {
	const dotDevDotVars = unstable_getVarsForDev(configPath, void 0, {}, cloudflareEnv);
	const dotDevDotVarsEntries = Array.from(Object.entries(dotDevDotVars));
	if (dotDevDotVarsEntries.length > 0) return dotDevDotVarsEntries.map(([key, value]) => {
		return `${key} = "${value?.toString().replaceAll(`"`, `\\"`)}"\n`;
	}).join("");
}
/**
* Returns `true` if the `changedFile` matches a `.dev.vars` or `.env` file.
*/
function hasLocalDevVarsFileChanged({ configPaths, cloudflareEnv }, changedFilePath) {
	return [...configPaths].some((configPath) => {
		const configDir = path$2.dirname(configPath);
		return [
			".dev.vars",
			".env",
			...cloudflareEnv ? [`.dev.vars.${cloudflareEnv}`, `.env.${cloudflareEnv}`] : []
		].some((localDevFile) => changedFilePath === path$2.join(configDir, localDevFile));
	});
}

//#endregion
//#region src/vite-config.ts
/**
* Throws an error if Worker environments include configuration options that are incompatible with the plugin.
*/
function validateWorkerEnvironmentOptions(resolvedPluginConfig, resolvedViteConfig) {
	const disallowedEnvironmentOptionsMap = /* @__PURE__ */ new Map();
	for (const environmentName of resolvedPluginConfig.environmentNameToWorkerMap.keys()) {
		const environmentOptions = resolvedViteConfig.environments[environmentName];
		assert(environmentOptions, `Missing environment config for "${environmentName}"`);
		const { resolve: resolve$1 } = environmentOptions;
		const disallowedEnvironmentOptions = {};
		if (resolve$1.external === true || resolve$1.external.length) disallowedEnvironmentOptions.resolveExternal = resolve$1.external;
		if (Object.keys(disallowedEnvironmentOptions).length) disallowedEnvironmentOptionsMap.set(environmentName, disallowedEnvironmentOptions);
	}
	if (disallowedEnvironmentOptionsMap.size) {
		const errorMessage = `The following environment options are incompatible with the Cloudflare Vite plugin:\n${[...disallowedEnvironmentOptionsMap].map(([environmentName, disallowedEnvironmentOptions]) => disallowedEnvironmentOptions.resolveExternal && `	- "${environmentName}" environment: \`resolve.external\`: ${JSON.stringify(disallowedEnvironmentOptions.resolveExternal)}\n`).join("")}To resolve this issue, avoid setting \`resolve.external\` in your Cloudflare Worker environments.\n`;
		throw new Error(errorMessage);
	}
}

//#endregion
//#region src/plugins/config.ts
/**
* Plugin to handle configuration and config file watching
*/
const configPlugin = createPlugin("config", (ctx) => {
	return {
		config(userConfig, env) {
			if (ctx.resolvedPluginConfig.type === "preview") return { appType: "custom" };
			if (!ctx.hasShownWorkerConfigWarnings) {
				ctx.setHasShownWorkerConfigWarnings(true);
				const workerConfigWarnings = getWarningForWorkersConfigs(ctx.resolvedPluginConfig.rawConfigs);
				if (workerConfigWarnings) console.warn(workerConfigWarnings);
			}
			return {
				appType: "custom",
				server: { fs: { deny: [
					...[
						".env",
						".env.*",
						"*.{crt,pem}",
						"**/.git/**"
					],
					".dev.vars",
					".dev.vars.*"
				] } },
				environments: ctx.resolvedPluginConfig.type === "workers" ? {
					...Object.fromEntries([...ctx.resolvedPluginConfig.environmentNameToWorkerMap].map(([environmentName, worker]) => {
						return [environmentName, createCloudflareEnvironmentOptions({
							workerConfig: worker.config,
							userConfig,
							mode: env.mode,
							environmentName,
							isEntryWorker: ctx.resolvedPluginConfig.type === "workers" && environmentName === ctx.resolvedPluginConfig.entryWorkerEnvironmentName,
							hasNodeJsCompat: ctx.getNodeJsCompat(environmentName) !== void 0
						})];
					})),
					client: {
						build: { outDir: getOutputDirectory(userConfig, "client") },
						optimizeDeps: { exclude: [...cloudflareBuiltInModules] }
					}
				} : void 0,
				builder: { buildApp: userConfig.builder?.buildApp ?? createBuildApp(ctx.resolvedPluginConfig) }
			};
		},
		configResolved(resolvedViteConfig) {
			ctx.setResolvedViteConfig(resolvedViteConfig);
			if (ctx.resolvedPluginConfig.type === "workers") validateWorkerEnvironmentOptions(ctx.resolvedPluginConfig, ctx.resolvedViteConfig);
		},
		buildStart() {
			ctx.setHasShownWorkerConfigWarnings(false);
		},
		configureServer(viteDevServer) {
			const configChangedHandler = async (changedFilePath) => {
				assertIsNotPreview(ctx);
				if (ctx.resolvedPluginConfig.configPaths.has(changedFilePath) || hasLocalDevVarsFileChanged(ctx.resolvedPluginConfig, changedFilePath) || hasAssetsConfigChanged(ctx.resolvedPluginConfig, ctx.resolvedViteConfig, changedFilePath)) {
					debuglog("Config changed: " + changedFilePath);
					viteDevServer.watcher.off("change", configChangedHandler);
					debuglog("Restarting dev server and aborting previous setup");
					await viteDevServer.restart();
				}
			};
			viteDevServer.watcher.on("change", configChangedHandler);
		}
	};
});

//#endregion
//#region src/debug.ts
const DEBUG_PATH = "/__debug";
const DEFAULT_INSPECTOR_PORT = 9229;
/**
* Gets the inspector port option that should be passed to Miniflare based on the user's plugin config
*/
async function getInputInspectorPort(ctx, viteServer) {
	if (ctx.resolvedPluginConfig.inspectorPort === void 0 || ctx.resolvedPluginConfig.inspectorPort === 0) {
		const resolvedInspectorPort = await ctx.getResolvedInspectorPort();
		if (resolvedInspectorPort !== null) return resolvedInspectorPort;
	}
	const inputInspectorPort = ctx.resolvedPluginConfig.inspectorPort ?? await getFirstAvailablePort(DEFAULT_INSPECTOR_PORT);
	if (ctx.resolvedPluginConfig.inspectorPort === void 0 && inputInspectorPort !== DEFAULT_INSPECTOR_PORT) viteServer.config.logger.warn(colors.dim(`Default inspector port ${DEFAULT_INSPECTOR_PORT} not available, using ${inputInspectorPort} instead\n`));
	return inputInspectorPort;
}
function getFirstAvailablePort(start) {
	return getPort({ port: portNumbers(start, 65535) });
}
/**
* Modifies the URL printing logic to also include a URL that developers can use to open DevTools to debug their Worker(s)
*/
function addDebugToVitePrintUrls(server) {
	const originalPrintUrls = server.printUrls;
	server.printUrls = () => {
		originalPrintUrls();
		const localUrl = server.resolvedUrls?.local[0];
		if (localUrl) {
			const { protocol, hostname, port } = new URL(localUrl);
			const colorDebugUrl = (url) => colors.dim(colors.yellow(url.replace(/:(\d+)\//, (_, port$1) => `:${colors.bold(port$1)}/`)));
			server.config.logger.info(`  ${colors.green("➜")}  ${colors.bold("Debug")}:   ${colorDebugUrl(`${protocol}//${hostname}:${port}${DEBUG_PATH}`)}`);
		}
	};
}
/**
* Generate HTML that comprises a single script that:
*  - redirects the page to the DevTools for debugging the first available Worker
*  - opens tabs to the DevTools for all the remaining workers if any
*
* Note: this works based on the Miniflare inspector proxy logic (where Workers are available via
* their names)
*/
function getDebugPathHtml(workerNames, inspectorPort) {
	assert(workerNames.length >= 1, "no workers present to debug");
	const workerDevtoolsUrls = workerNames.map((workerName) => {
		const localhost = `localhost:${inspectorPort}/${workerName}`;
		return `https://devtools.devprod.cloudflare.dev/js_app?${new URLSearchParams({
			theme: "systemPreferred",
			debugger: "true",
			ws: localhost,
			domain: workerName
		})}`;
	});
	return `
		<script>
			const workerUrls = ${JSON.stringify(workerDevtoolsUrls)};
			const [firstUrl, ...rest] = workerUrls;
			for (const workerUrl of rest) {
				// open new tabs for the devtools of the various workers
				window.open(workerUrl);
			}
			// redirect the current tab to the devtools of the first worker
			window.location.replace(firstUrl);
		<\/script>
    `;
}

//#endregion
//#region src/plugins/debug.ts
/**
* Plugin to provide a `/__debug` path for debugging Workers
*/
const debugPlugin = createPlugin("debug", (ctx) => {
	return {
		enforce: "pre",
		configureServer(viteDevServer) {
			assertIsNotPreview(ctx);
			if (!!process.env.VSCODE_INSPECTOR_OPTIONS) return;
			if (ctx.resolvedPluginConfig.type === "workers" && ctx.resolvedPluginConfig.inspectorPort !== false) addDebugToVitePrintUrls(viteDevServer);
			const workerNames = ctx.resolvedPluginConfig.type === "workers" ? [...ctx.resolvedPluginConfig.environmentNameToWorkerMap.values()].map((worker) => worker.config.name) : [];
			viteDevServer.middlewares.use(DEBUG_PATH, async (_, res, next) => {
				const resolvedInspectorPort = await ctx.getResolvedInspectorPort();
				if (resolvedInspectorPort) {
					const html = getDebugPathHtml(workerNames, resolvedInspectorPort);
					res.setHeader("Content-Type", "text/html");
					res.end(html);
				} else next();
			});
		},
		async configurePreviewServer(vitePreviewServer) {
			assertIsPreview(ctx);
			if (!!process.env.VSCODE_INSPECTOR_OPTIONS) return;
			if (ctx.resolvedPluginConfig.workers.length >= 1 && ctx.resolvedPluginConfig.inspectorPort !== false) addDebugToVitePrintUrls(vitePreviewServer);
			const workerNames = ctx.resolvedPluginConfig.workers.map((worker) => {
				assert(worker.name, "Expected the Worker to have a name");
				return worker.name;
			});
			vitePreviewServer.middlewares.use(DEBUG_PATH, async (_, res, next) => {
				const resolvedInspectorPort = await ctx.getResolvedInspectorPort();
				if (resolvedInspectorPort) {
					const html = getDebugPathHtml(workerNames, resolvedInspectorPort);
					res.setHeader("Content-Type", "text/html");
					res.end(html);
				} else next();
			});
		}
	};
});

//#endregion
//#region ../containers-shared/src/client/core/ApiError.ts
var ApiError = class extends Error {
	url;
	status;
	statusText;
	body;
	request;
	constructor(request$1, response, message) {
		super(message);
		this.name = "ApiError";
		this.url = response.url;
		this.status = response.status;
		this.statusText = response.statusText;
		this.body = response.body;
		this.request = request$1;
	}
};

//#endregion
//#region ../containers-shared/src/client/core/CancelablePromise.ts
/* istanbul ignore file */
var CancelError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "CancelError";
	}
	get isCancelled() {
		return true;
	}
};
var CancelablePromise = class {
	#isResolved;
	#isRejected;
	#isCancelled;
	#cancelHandlers;
	#promise;
	#resolve;
	#reject;
	constructor(executor) {
		this.#isResolved = false;
		this.#isRejected = false;
		this.#isCancelled = false;
		this.#cancelHandlers = [];
		this.#promise = new Promise((resolve$1, reject) => {
			this.#resolve = resolve$1;
			this.#reject = reject;
			const onResolve = (value) => {
				if (this.#isResolved || this.#isRejected || this.#isCancelled) return;
				this.#isResolved = true;
				this.#resolve?.(value);
			};
			const onReject = (reason) => {
				if (this.#isResolved || this.#isRejected || this.#isCancelled) return;
				this.#isRejected = true;
				this.#reject?.(reason);
			};
			const onCancel = (cancelHandler) => {
				if (this.#isResolved || this.#isRejected || this.#isCancelled) return;
				this.#cancelHandlers.push(cancelHandler);
			};
			Object.defineProperty(onCancel, "isResolved", { get: () => this.#isResolved });
			Object.defineProperty(onCancel, "isRejected", { get: () => this.#isRejected });
			Object.defineProperty(onCancel, "isCancelled", { get: () => this.#isCancelled });
			return executor(onResolve, onReject, onCancel);
		});
	}
	get [Symbol.toStringTag]() {
		return "Cancellable Promise";
	}
	then(onFulfilled, onRejected) {
		return this.#promise.then(onFulfilled, onRejected);
	}
	catch(onRejected) {
		return this.#promise.catch(onRejected);
	}
	finally(onFinally) {
		return this.#promise.finally(onFinally);
	}
	cancel() {
		if (this.#isResolved || this.#isRejected || this.#isCancelled) return;
		this.#isCancelled = true;
		if (this.#cancelHandlers.length) try {
			for (const cancelHandler of this.#cancelHandlers) cancelHandler();
		} catch (error) {
			console.warn("Cancellation threw an error", error);
			return;
		}
		this.#cancelHandlers.length = 0;
		this.#reject?.(new CancelError("Request aborted"));
	}
	get isCancelled() {
		return this.#isCancelled;
	}
};

//#endregion
//#region ../containers-shared/src/client/core/OpenAPI.ts
const OpenAPI = {
	BASE: "",
	VERSION: "1.0.0",
	WITH_CREDENTIALS: false,
	CREDENTIALS: "include",
	TOKEN: void 0,
	USERNAME: void 0,
	PASSWORD: void 0,
	HEADERS: void 0,
	ENCODE_PATH: void 0,
	LOGGER: void 0
};

//#endregion
//#region ../containers-shared/src/client/models/ApplicationRollout.ts
let ApplicationRollout;
(function(_ApplicationRollout) {
	_ApplicationRollout.kind = /* @__PURE__ */ function(kind) {
		kind["FULL_AUTO"] = "full_auto";
		kind["FULL_MANUAL"] = "full_manual";
		kind["DURABLE_OBJECTS_AUTO"] = "durable_objects_auto";
		return kind;
	}({});
	_ApplicationRollout.strategy = /* @__PURE__ */ function(strategy) {
		strategy["ROLLING"] = "rolling";
		return strategy;
	}({});
	_ApplicationRollout.status = /* @__PURE__ */ function(status) {
		status["PENDING"] = "pending";
		status["PROGRESSING"] = "progressing";
		status["COMPLETED"] = "completed";
		status["REVERTED"] = "reverted";
		status["REPLACED"] = "replaced";
		return status;
	}({});
})(ApplicationRollout || (ApplicationRollout = {}));

//#endregion
//#region ../containers-shared/src/client/models/BadRequestWithCodeError.ts
let BadRequestWithCodeError;
(function(_BadRequestWithCodeError) {
	_BadRequestWithCodeError.error = /* @__PURE__ */ function(error) {
		error["VALIDATE_INPUT"] = "VALIDATE_INPUT";
		return error;
	}({});
})(BadRequestWithCodeError || (BadRequestWithCodeError = {}));

//#endregion
//#region ../containers-shared/src/client/models/CreateApplicationRolloutRequest.ts
let CreateApplicationRolloutRequest;
(function(_CreateApplicationRolloutRequest) {
	_CreateApplicationRolloutRequest.strategy = /* @__PURE__ */ function(strategy) {
		strategy["ROLLING"] = "rolling";
		return strategy;
	}({});
	_CreateApplicationRolloutRequest.step_percentage = /* @__PURE__ */ function(step_percentage) {
		step_percentage[step_percentage["_5"] = 5] = "_5";
		step_percentage[step_percentage["_10"] = 10] = "_10";
		step_percentage[step_percentage["_20"] = 20] = "_20";
		step_percentage[step_percentage["_25"] = 25] = "_25";
		step_percentage[step_percentage["_50"] = 50] = "_50";
		step_percentage[step_percentage["_100"] = 100] = "_100";
		return step_percentage;
	}({});
	_CreateApplicationRolloutRequest.kind = /* @__PURE__ */ function(kind) {
		kind["FULL_AUTO"] = "full_auto";
		kind["FULL_MANUAL"] = "full_manual";
		return kind;
	}({});
})(CreateApplicationRolloutRequest || (CreateApplicationRolloutRequest = {}));

//#endregion
//#region ../containers-shared/src/client/models/DeploymentNotFoundError.ts
let DeploymentNotFoundError;
(function(_DeploymentNotFoundError) {
	_DeploymentNotFoundError.error = /* @__PURE__ */ function(error) {
		error["DEPLOYMENT_NOT_FOUND"] = "DEPLOYMENT_NOT_FOUND";
		return error;
	}({});
})(DeploymentNotFoundError || (DeploymentNotFoundError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryAlreadyExistsError.ts
let ImageRegistryAlreadyExistsError;
(function(_ImageRegistryAlreadyExistsError) {
	_ImageRegistryAlreadyExistsError.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_ALREADY_EXISTS"] = "IMAGE_REGISTRY_ALREADY_EXISTS";
		return error;
	}({});
})(ImageRegistryAlreadyExistsError || (ImageRegistryAlreadyExistsError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryIsPublic.ts
let ImageRegistryIsPublic;
(function(_ImageRegistryIsPublic) {
	_ImageRegistryIsPublic.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_IS_PUBLIC"] = "IMAGE_REGISTRY_IS_PUBLIC";
		return error;
	}({});
})(ImageRegistryIsPublic || (ImageRegistryIsPublic = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryNotAllowedError.ts
let ImageRegistryNotAllowedError;
(function(_ImageRegistryNotAllowedError) {
	_ImageRegistryNotAllowedError.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_NOT_ALLOWED"] = "IMAGE_REGISTRY_NOT_ALLOWED";
		return error;
	}({});
})(ImageRegistryNotAllowedError || (ImageRegistryNotAllowedError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryNotFoundError.ts
let ImageRegistryNotFoundError;
(function(_ImageRegistryNotFoundError) {
	_ImageRegistryNotFoundError.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_NOT_FOUND"] = "IMAGE_REGISTRY_NOT_FOUND";
		return error;
	}({});
})(ImageRegistryNotFoundError || (ImageRegistryNotFoundError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryPermissions.ts
/* istanbul ignore file */
let ImageRegistryPermissions = /* @__PURE__ */ function(ImageRegistryPermissions$1) {
	ImageRegistryPermissions$1["PULL"] = "pull";
	ImageRegistryPermissions$1["PUSH"] = "push";
	return ImageRegistryPermissions$1;
}({});

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryProtocolAlreadyExists.ts
let ImageRegistryProtocolAlreadyExists;
(function(_ImageRegistryProtocolAlreadyExists) {
	_ImageRegistryProtocolAlreadyExists.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_PROTOCOL_ALREADY_EXISTS"] = "IMAGE_REGISTRY_PROTOCOL_ALREADY_EXISTS";
		return error;
	}({});
})(ImageRegistryProtocolAlreadyExists || (ImageRegistryProtocolAlreadyExists = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryProtocolIsReferencedError.ts
let ImageRegistryProtocolIsReferencedError;
(function(_ImageRegistryProtocolIsReferencedError) {
	_ImageRegistryProtocolIsReferencedError.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_PROTO_IS_REFERENCED"] = "IMAGE_REGISTRY_PROTO_IS_REFERENCED";
		return error;
	}({});
})(ImageRegistryProtocolIsReferencedError || (ImageRegistryProtocolIsReferencedError = {}));

//#endregion
//#region ../containers-shared/src/client/models/ImageRegistryProtocolNotFound.ts
let ImageRegistryProtocolNotFound;
(function(_ImageRegistryProtocolNotFound) {
	_ImageRegistryProtocolNotFound.error = /* @__PURE__ */ function(error) {
		error["IMAGE_REGISTRY_PROTOCOL_NOT_FOUND"] = "IMAGE_REGISTRY_PROTOCOL_NOT_FOUND";
		return error;
	}({});
})(ImageRegistryProtocolNotFound || (ImageRegistryProtocolNotFound = {}));

//#endregion
//#region ../containers-shared/src/client/models/ProvisionerConfiguration.ts
let ProvisionerConfiguration;
(function(_ProvisionerConfiguration) {
	_ProvisionerConfiguration.type = /* @__PURE__ */ function(type) {
		type["NONE"] = "none";
		type["CLOUDINIT"] = "cloudinit";
		return type;
	}({});
})(ProvisionerConfiguration || (ProvisionerConfiguration = {}));

//#endregion
//#region ../containers-shared/src/client/models/RolloutStep.ts
let RolloutStep;
(function(_RolloutStep) {
	_RolloutStep.status = /* @__PURE__ */ function(status) {
		status["PENDING"] = "pending";
		status["PROGRESSING"] = "progressing";
		status["REVERTING"] = "reverting";
		status["COMPLETED"] = "completed";
		status["REVERTED"] = "reverted";
		return status;
	}({});
})(RolloutStep || (RolloutStep = {}));

//#endregion
//#region ../containers-shared/src/client/models/SecretNameAlreadyExists.ts
let SecretNameAlreadyExists;
(function(_SecretNameAlreadyExists) {
	_SecretNameAlreadyExists.error = /* @__PURE__ */ function(error) {
		error["SECRET_NAME_ALREADY_EXISTS"] = "SECRET_NAME_ALREADY_EXISTS";
		return error;
	}({});
})(SecretNameAlreadyExists || (SecretNameAlreadyExists = {}));

//#endregion
//#region ../containers-shared/src/client/models/SecretNotFound.ts
let SecretNotFound;
(function(_SecretNotFound) {
	_SecretNotFound.error = /* @__PURE__ */ function(error) {
		error["SECRET_NAME_NOT_FOUND"] = "SECRET_NAME_NOT_FOUND";
		return error;
	}({});
})(SecretNotFound || (SecretNotFound = {}));

//#endregion
//#region ../containers-shared/src/client/models/SSHPublicKeyNotFoundError.ts
let SSHPublicKeyNotFoundError;
(function(_SSHPublicKeyNotFoundError) {
	_SSHPublicKeyNotFoundError.error = /* @__PURE__ */ function(error) {
		error["SSH_PUBLIC_KEY_NOT_FOUND"] = "SSH_PUBLIC_KEY_NOT_FOUND";
		return error;
	}({});
})(SSHPublicKeyNotFoundError || (SSHPublicKeyNotFoundError = {}));

//#endregion
//#region ../containers-shared/src/client/models/UpdateApplicationRolloutRequest.ts
let UpdateApplicationRolloutRequest;
(function(_UpdateApplicationRolloutRequest) {
	_UpdateApplicationRolloutRequest.action = /* @__PURE__ */ function(action) {
		action["NEXT"] = "next";
		action["PREVIOUS"] = "previous";
		action["REVERT"] = "revert";
		return action;
	}({});
})(UpdateApplicationRolloutRequest || (UpdateApplicationRolloutRequest = {}));

//#endregion
//#region ../containers-shared/src/client/core/request.ts
/* istanbul ignore file */
const isDefined = (value) => {
	return value !== void 0 && value !== null;
};
const isString = (value) => {
	return typeof value === "string";
};
const isStringWithValue = (value) => {
	return isString(value) && value !== "";
};
const isBlob = (value) => {
	return typeof value === "object" && typeof value.type === "string" && typeof value.stream === "function" && typeof value.arrayBuffer === "function" && typeof value.constructor === "function" && typeof value.constructor.name === "string" && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);
};
const base64 = (str) => {
	try {
		return btoa(str);
	} catch (err) {
		return Buffer.from(str).toString("base64");
	}
};
const getQueryString = (params) => {
	const qs = [];
	const append = (key, value) => {
		qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
	};
	const process$2 = (key, value) => {
		if (isDefined(value)) if (Array.isArray(value)) value.forEach((v) => {
			process$2(key, v);
		});
		else if (typeof value === "object") Object.entries(value).forEach(([k, v]) => {
			process$2(`${key}[${k}]`, v);
		});
		else append(key, value);
	};
	Object.entries(params).forEach(([key, value]) => {
		process$2(key, value);
	});
	if (qs.length > 0) return `?${qs.join("&")}`;
	return "";
};
const getUrl = (config, options) => {
	const encoder = config.ENCODE_PATH || encodeURI;
	const path$3 = options.url.replace("{api-version}", config.VERSION).replace(/{(.*?)}/g, (substring, group) => {
		if (options.path?.hasOwnProperty(group)) return encoder(String(options.path[group]));
		return substring;
	});
	const url = `${config.BASE}${path$3}`;
	if (options.query) return `${url}${getQueryString(options.query)}`;
	return url;
};
const getFormData = (options) => {
	if (options.formData) {
		const formData = new FormData();
		const process$2 = async (key, value) => {
			if (isString(value)) formData.append(key, value);
			else formData.append(key, JSON.stringify(value));
		};
		Object.entries(options.formData).filter(([_, value]) => isDefined(value)).forEach(([key, value]) => {
			if (Array.isArray(value)) value.forEach((v) => process$2(key, v));
			else process$2(key, value);
		});
		return formData;
	}
};
const resolve = async (options, resolver) => {
	if (typeof resolver === "function") return resolver(options);
	return resolver;
};
const getHeaders = async (config, options) => {
	const token = await resolve(options, config.TOKEN);
	const username = await resolve(options, config.USERNAME);
	const password = await resolve(options, config.PASSWORD);
	const additionalHeaders = await resolve(options, config.HEADERS);
	const headers = Object.entries({
		Accept: "application/json",
		...additionalHeaders,
		...options.headers
	}).filter(([_, value]) => isDefined(value)).reduce((headers$1, [key, value]) => ({
		...headers$1,
		[key]: String(value)
	}), {});
	if (isStringWithValue(token)) headers["Authorization"] = `Bearer ${token}`;
	if (isStringWithValue(username) && isStringWithValue(password)) headers["Authorization"] = `Basic ${base64(`${username}:${password}`)}`;
	if (options.body) if (options.mediaType) headers["Content-Type"] = options.mediaType;
	else if (isBlob(options.body)) headers["Content-Type"] = options.body.type || "application/octet-stream";
	else if (isString(options.body)) headers["Content-Type"] = "text/plain";
	else headers["Content-Type"] = "application/json";
	return new Headers(headers);
};
const getRequestBody = (options) => {
	if (options.body !== void 0) if (options.mediaType?.includes("/json")) return JSON.stringify(options.body);
	else if (isString(options.body) || isBlob(options.body)) return options.body;
	else return JSON.stringify(options.body);
};
const isResponseSchemaV4 = (config, _options) => {
	return config.BASE.endsWith("/containers");
};
const parseResponseSchemaV4 = (url, response, responseHeader, responseBody) => {
	const fetchResult = typeof responseBody === "object" ? responseBody : JSON.parse(responseBody);
	const ok = response.ok && fetchResult.success;
	let result;
	if (ok) if (fetchResult.result !== void 0) result = fetchResult.result;
	else result = {};
	else result = { error: fetchResult.errors?.[0]?.message };
	return {
		url,
		ok,
		status: response.status,
		statusText: response.statusText,
		body: responseHeader ?? result
	};
};
const sendRequest = async (config, options, url, body, formData, headers, onCancel) => {
	const controller = new AbortController();
	const request$1 = {
		headers,
		body: body ?? formData,
		method: options.method,
		signal: controller.signal
	};
	if (config.WITH_CREDENTIALS) request$1.credentials = config.CREDENTIALS;
	onCancel(() => controller.abort());
	return await fetch(url, request$1);
};
const getResponseHeader = (response, responseHeader) => {
	if (responseHeader) {
		const content = response.headers.get(responseHeader);
		if (isString(content)) return content;
	}
};
const getResponseBody = async (response) => {
	if (response.status !== 204) try {
		const contentType = response.headers.get("Content-Type");
		if (contentType) if (["application/json", "application/problem+json"].some((type) => contentType.toLowerCase().startsWith(type))) return await response.json();
		else return await response.text();
	} catch (error) {
		console.error(error);
	}
};
const catchErrorCodes = (options, result) => {
	const error = {
		400: "Bad Request",
		401: "Unauthorized",
		403: "Forbidden",
		404: "Not Found",
		500: "Internal Server Error",
		502: "Bad Gateway",
		503: "Service Unavailable",
		...options.errors
	}[result.status];
	if (error) throw new ApiError(options, result, error);
	if (!result.ok) throw new ApiError(options, result, "Generic Error");
};
/**
* Request method
* @param config The OpenAPI configuration object
* @param options The request options from the service
* @returns CancelablePromise<T>
* @throws ApiError
*/
const request = (config, options) => {
	return new CancelablePromise(async (resolve$1, reject, onCancel) => {
		try {
			const url = getUrl(config, options);
			const formData = getFormData(options);
			const body = getRequestBody(options);
			const headers = await getHeaders(config, options);
			debugLogRequest(config, url, headers, formData ?? body ?? {});
			if (!onCancel.isCancelled) {
				const response = await sendRequest(config, options, url, body, formData, headers, onCancel);
				const responseBody = await getResponseBody(response);
				const responseHeader = getResponseHeader(response, options.responseHeader);
				let result;
				if (isResponseSchemaV4(config, options)) result = parseResponseSchemaV4(url, response, responseHeader, responseBody);
				else result = {
					url,
					ok: response.ok,
					status: response.status,
					statusText: response.statusText,
					body: responseHeader ?? responseBody
				};
				debugLogResponse(config, result);
				catchErrorCodes(options, result);
				resolve$1(result.body);
			}
		} catch (error) {
			reject(error);
		}
	});
};
const debugLogRequest = async (config, url, headers, body) => {
	config.LOGGER?.debug(`-- START CF API REQUEST: ${url}`);
	const logHeaders = new Headers(headers);
	logHeaders.delete("Authorization");
	config.LOGGER?.debugWithSanitization("HEADERS:", JSON.stringify(logHeaders, null, 2));
	config.LOGGER?.debugWithSanitization("BODY:", JSON.stringify(body instanceof FormData ? await new Response(body).text() : body, null, 2));
	config.LOGGER?.debug("-- END CF API REQUEST");
};
const debugLogResponse = (config, response) => {
	config.LOGGER?.debug("-- START CF API RESPONSE:", response.statusText, response.status);
	config.LOGGER?.debugWithSanitization("RESPONSE:", response.body);
	config.LOGGER?.debug("-- END CF API RESPONSE");
};

//#endregion
//#region ../containers-shared/src/client/services/ImageRegistriesService.ts
/* istanbul ignore file */
var ImageRegistriesService = class {
	/**
	* Create an image registry protocol that resolves to multiple domains.
	* @param requestBody
	* @returns ImageRegistryProtocol The image registry protocol was created
	* @throws ApiError
	*/
	static createImageRegistryProtocol(requestBody) {
		return request(OpenAPI, {
			method: "POST",
			url: "/registries/protos",
			body: requestBody,
			mediaType: "application/json",
			errors: {
				400: `Bad Request that contains a specific constant code and details object about the error.`,
				403: `The registry that is being added is not allowed`,
				409: `Image registry protocol already exists`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* List all image registry protocols.
	* @returns ImageRegistryProtocols The image registry protocols in the account
	* @throws ApiError
	*/
	static listImageRegistryProtocols() {
		return request(OpenAPI, {
			method: "GET",
			url: "/registries/protos",
			errors: { 500: `There has been an internal error` }
		});
	}
	/**
	* Modify an image registry protocol. The previous list of domains will be replaced by the ones you specify in this endpoint.
	* @param requestBody
	* @returns ImageRegistryProtocol The image registry protocol was modified
	* @throws ApiError
	*/
	static modifyImageRegistryProtocol(requestBody) {
		return request(OpenAPI, {
			method: "PUT",
			url: "/registries/protos",
			body: requestBody,
			mediaType: "application/json",
			errors: {
				400: `Bad Request that contains a specific constant code and details object about the error.`,
				403: `The registry that is being added is not allowed`,
				404: `Image registry protocol doesn't exist`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* Delete an image registry protocol. Be careful, if there is deployments running referencing this protocol they won't be able to pull the image.
	* @param proto
	* @returns EmptyResponse Image registry protocol was deleted successfully
	* @throws ApiError
	*/
	static deleteImageRegistryProto(proto) {
		return request(OpenAPI, {
			method: "DELETE",
			url: "/registries/protos/{proto}",
			path: { proto },
			errors: {
				400: `The image registry protocol couldn't be deleted because it's referenced by a deployment or application`,
				404: `Image registry protocol doesn't exist`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* Get a JWT to pull from the image registry
	* Get a JWT to pull from the image registry specifying its domain
	* @param domain
	* @param requestBody
	* @returns AccountRegistryToken Credentials with 'pull' or 'push' permissions to access the registry
	* @throws ApiError
	*/
	static generateImageRegistryCredentials(domain, requestBody) {
		return request(OpenAPI, {
			method: "POST",
			url: "/registries/{domain}/credentials",
			path: { domain },
			body: requestBody,
			mediaType: "application/json",
			errors: {
				400: `Bad Request that contains a specific constant code and details object about the error.`,
				404: `The image registry does not exist`,
				409: `The registry was configured as public, so credentials can not be generated`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* Delete a registry from the account
	* Delete a registry from the account, this will make Cloudchamber unable to pull images from the registry
	* @param domain
	* @returns EmptyResponse The image registry is deleted
	* @throws ApiError
	*/
	static deleteImageRegistry(domain) {
		return request(OpenAPI, {
			method: "DELETE",
			url: "/registries/{domain}",
			path: { domain },
			errors: {
				404: `The image registry does not exist`,
				500: `There has been an internal error`
			}
		});
	}
	/**
	* Get the list of configured registries in the account
	* Get the list of configured registries in the account
	* @returns CustomerImageRegistry The list of registries that are added in the account
	* @throws ApiError
	*/
	static listImageRegistries() {
		return request(OpenAPI, {
			method: "GET",
			url: "/registries",
			errors: { 500: `There has been an internal error` }
		});
	}
	/**
	* Add a new image registry configuration
	* Add a new image registry into your account, so then Cloudflare can pull docker images with public key JWT authentication
	* @param requestBody
	* @returns CustomerImageRegistry Created a new image registry in the account
	* @throws ApiError
	*/
	static createImageRegistry(requestBody) {
		return request(OpenAPI, {
			method: "POST",
			url: "/registries",
			body: requestBody,
			mediaType: "application/json",
			errors: {
				400: `Image registry input is malformed, see the error details`,
				403: `The registry that is being added is not allowed`,
				409: `The image registry already exists in the account`,
				500: `There has been an internal error`
			}
		});
	}
};

//#endregion
//#region ../containers-shared/src/error.ts
/**
* Base class for errors where the user has done something wrong. These are not
* reported to Sentry. API errors are intentionally *not* `UserError`s, and are
* reported to Sentry. This will help us understand which API errors need better
* messaging.
*/
var UserError = class extends Error {
	telemetryMessage;
	constructor(message, options) {
		super(message, options);
		Object.setPrototypeOf(this, new.target.prototype);
		this.telemetryMessage = options?.telemetryMessage === true ? message : options?.telemetryMessage;
	}
};

//#endregion
//#region ../containers-shared/src/build.ts
async function constructBuildCommand(options, logger) {
	const platform = options.platform ?? "linux/amd64";
	const buildCmd = [
		"build",
		"--load",
		"-t",
		options.tag,
		"--platform",
		platform,
		"--provenance=false"
	];
	if (options.args) for (const arg in options.args) buildCmd.push("--build-arg", `${arg}=${options.args[arg]}`);
	if (options.setNetworkToHost) buildCmd.push("--network", "host");
	const dockerfile = readFileSync$1(options.pathToDockerfile, "utf-8");
	buildCmd.push("-f", "-");
	buildCmd.push(options.buildContext);
	logger?.debug(`Building image with command: ${buildCmd.join(" ")}`);
	return {
		buildCmd,
		dockerfile
	};
}
function dockerBuild(dockerPath, options) {
	let errorHandled = false;
	let resolve$1;
	let reject;
	const ready = new Promise((res, rej) => {
		resolve$1 = res;
		reject = rej;
	});
	const child = spawn(dockerPath, options.buildCmd, {
		stdio: [
			"pipe",
			"inherit",
			"inherit"
		],
		detached: true
	});
	if (child.stdin !== null) {
		child.stdin.write(options.dockerfile);
		child.stdin.end();
	}
	child.on("exit", (code) => {
		if (code === 0) resolve$1();
		else if (!errorHandled) {
			errorHandled = true;
			reject(new UserError(`Docker build exited with code: ${code}`));
		}
	});
	child.on("error", (err) => {
		if (!errorHandled) {
			errorHandled = true;
			reject(err);
		}
	});
	return {
		abort: () => {
			child.unref();
			if (child.pid !== void 0) process.kill(-child.pid);
		},
		ready
	};
}
async function buildImage(dockerPath, options) {
	const { buildCmd, dockerfile } = await constructBuildCommand({
		tag: options.image_tag,
		pathToDockerfile: options.dockerfile,
		buildContext: options.image_build_context,
		args: options.image_vars,
		platform: "linux/amd64"
	});
	return dockerBuild(dockerPath, {
		buildCmd,
		dockerfile
	});
}

//#endregion
//#region ../containers-shared/src/login.ts
/**
* Gets push and pull credentials for a configured image registry
* and runs `docker login`, so subsequent image pushes or pulls are
* authenticated
*/
async function dockerLoginImageRegistry(pathToDocker, domain) {
	const credentials = await ImageRegistriesService.generateImageRegistryCredentials(domain, {
		expiration_minutes: 15,
		permissions: [ImageRegistryPermissions.PUSH, ImageRegistryPermissions.PULL]
	});
	const child = spawn$1(pathToDocker, [
		"login",
		"--password-stdin",
		"--username",
		credentials.username,
		domain
	], { stdio: [
		"pipe",
		"inherit",
		"inherit"
	] }).on("error", (err) => {
		throw err;
	});
	child.stdin.write(credentials.password);
	child.stdin.end();
	await new Promise((resolve$1, reject) => {
		child.on("close", (code) => {
			if (code === 0) resolve$1();
			else reject(new UserError(`Login failed with code: ${code}`));
		});
	});
}

//#endregion
//#region ../containers-shared/src/registry.ts
const MF_DEV_CONTAINER_PREFIX = "cloudflare-dev";

//#endregion
//#region ../containers-shared/src/knobs.ts
/** Prefixes with the cloudflare-dev namespace. The name should be the container's DO classname, and the tag a build uuid. */
const getDevContainerImageName = (name, tag) => {
	return `${MF_DEV_CONTAINER_PREFIX}/${name.toLowerCase()}:${tag}`;
};

//#endregion
//#region ../containers-shared/src/inspect.ts
async function dockerImageInspect(dockerPath, options) {
	return new Promise((resolve$1, reject) => {
		const proc = spawn(dockerPath, [
			"image",
			"inspect",
			options.imageTag,
			"--format",
			options.formatString
		], { stdio: [
			"ignore",
			"pipe",
			"pipe"
		] });
		let stdout = "";
		let stderr = "";
		proc.stdout.on("data", (chunk) => stdout += chunk);
		proc.stderr.on("data", (chunk) => stderr += chunk);
		proc.on("close", (code) => {
			if (code !== 0) return reject(new UserError(`failed inspecting image locally: ${stderr.trim()}`));
			resolve$1(stdout.trim());
		});
		proc.on("error", (err) => reject(err));
	});
}

//#endregion
//#region ../containers-shared/src/utils.ts
/** helper for simple docker command call that don't require any io handling */
const runDockerCmd = (dockerPath, args, stdio) => {
	let aborted = false;
	let resolve$1;
	let reject;
	const ready = new Promise((res, rej) => {
		resolve$1 = res;
		reject = rej;
	});
	const child = spawn(dockerPath, args, {
		stdio: stdio ?? "inherit",
		detached: true
	});
	let errorHandled = false;
	child.on("close", (code) => {
		if (code === 0 || aborted) resolve$1({ aborted });
		else if (!errorHandled) {
			errorHandled = true;
			reject(new UserError(`Docker command exited with code: ${code}`));
		}
	});
	child.on("error", (err) => {
		if (!errorHandled) {
			errorHandled = true;
			reject(new UserError(`Docker command failed: ${err.message}`));
		}
	});
	return {
		abort: () => {
			aborted = true;
			child.unref();
			if (child.pid !== void 0) process.kill(-child.pid);
		},
		ready,
		then: async (onResolve, onReject) => ready.then(onResolve).catch(onReject)
	};
};
const runDockerCmdWithOutput = (dockerPath, args) => {
	try {
		return execFileSync(dockerPath, args, { encoding: "utf8" }).trim();
	} catch (error) {
		throw new UserError(`Failed running docker command: ${error.message}. Command: ${dockerPath} ${args.join(" ")}`);
	}
};
/** Checks whether docker is running on the system */
const isDockerRunning = async (dockerPath) => {
	try {
		await runDockerCmd(dockerPath, ["info"], [
			"inherit",
			"pipe",
			"pipe"
		]);
	} catch {
		return false;
	}
	return true;
};
/** throws when docker is not installed */
const verifyDockerInstalled = async (dockerPath, isDev = true) => {
	if (!await isDockerRunning(dockerPath)) throw new UserError(`The Docker CLI could not be launched. Please ensure that the Docker CLI is installed and the daemon is running.
Other container tooling that is compatible with the Docker CLI and engine may work, but is not yet guaranteed to do so. You can specify an executable with the environment variable WRANGLER_DOCKER_BIN and a socket with DOCKER_HOST.${isDev ? "\nTo suppress this error if you do not intend on triggering any container instances, set dev.enable_containers to false in your Wrangler config or passing in --enable-containers=false." : ""}`);
};
function isDir(inputPath) {
	return statSync$1(inputPath).isDirectory();
}
/** returns true if it is a dockerfile, false if it is a registry link, throws if neither */
const isDockerfile = (image, configPath) => {
	const baseDir = configPath ? path$1.dirname(configPath) : process.cwd();
	const maybeDockerfile = path$1.resolve(baseDir, image);
	if (existsSync(maybeDockerfile)) {
		if (isDir(maybeDockerfile)) throw new UserError(`${image} is a directory, you should specify a path to the Dockerfile`);
		return true;
	}
	const errorPrefix = `The image "${image}" does not appear to be a valid path to a Dockerfile, or a valid image registry path:\n`;
	try {
		new URL(`https://${image}`);
	} catch (e) {
		if (e instanceof Error) throw new UserError(errorPrefix + e.message);
		throw e;
	}
	const imageParts = image.split("/");
	if (!imageParts[imageParts.length - 1]?.includes(":")) throw new UserError(errorPrefix + `If this is an image registry path, it needs to include at least a tag ':' (e.g: docker.io/httpd:1)`);
	if (image.includes("://")) throw new UserError(errorPrefix + `Image reference should not include the protocol part (e.g: docker.io/httpd:1, not https://docker.io/httpd:1)`);
	return false;
};
/**
* Kills and removes any containers which come from the given image tag
*/
const cleanupContainers = (dockerPath, imageTags) => {
	try {
		const containerIds = getContainerIdsByImageTags(dockerPath, imageTags);
		if (containerIds.length === 0) return true;
		runDockerCmdWithOutput(dockerPath, [
			"rm",
			"--force",
			...containerIds
		]);
		return true;
	} catch {
		return false;
	}
};
/**
* See https://docs.docker.com/reference/cli/docker/container/ls/#ancestor
*
* @param dockerPath The path to the Docker executable
* @param imageTags A set of ancestor image tags
* @returns The ids of all containers that share the given image tags as ancestors.
*/
function getContainerIdsByImageTags(dockerPath, imageTags) {
	const ids = /* @__PURE__ */ new Set();
	for (const imageTag of imageTags) getContainerIdsFromImage(dockerPath, imageTag).forEach((id) => ids.add(id));
	return Array.from(ids);
}
const getContainerIdsFromImage = (dockerPath, ancestorImage) => {
	return runDockerCmdWithOutput(dockerPath, [
		"ps",
		"-a",
		"--filter",
		`ancestor=${ancestorImage}`,
		"--format",
		"{{.ID}}"
	]).split("\n").filter((line) => line.trim());
};
/**
* While all ports are exposed in prod, a limitation of local dev with docker is that
* users will have to manually expose ports in their Dockerfile.
* We want to fail early and clearly if a user tries to develop with a container
* that has no ports exposed and is definitely not accessible.
*
* (A user could still use `getTCPPort()` on a port that is not exposed, but we leave that error for runtime.)
*/
async function checkExposedPorts(dockerPath, options) {
	if (await dockerImageInspect(dockerPath, {
		imageTag: options.image_tag,
		formatString: "{{ len .Config.ExposedPorts }}"
	}) === "0") throw new UserError(`The container "${options.class_name}" does not expose any ports. In your Dockerfile, please expose any ports you intend to connect to.\nFor additional information please see: https://developers.cloudflare.com/containers/local-dev/#exposing-ports.
`);
}
/**
* Generates a random container build id
*/
function generateContainerBuildId() {
	return randomUUID().slice(0, 8);
}
/**
* Run `docker context ls` to get the socket from the currently active Docker context
* @returns The socket path or null if we are not able to determine it
*/
function getDockerSocketFromContext(dockerPath) {
	try {
		const currentContext = runDockerCmdWithOutput(dockerPath, [
			"context",
			"ls",
			"--format",
			"json"
		]).trim().split("\n").map((line) => JSON.parse(line)).find((context) => context.Current === true);
		if (currentContext && currentContext.DockerEndpoint) return currentContext.DockerEndpoint;
	} catch {}
	return null;
}
/**
* Resolve Docker host as follows:
* 1. Check WRANGLER_DOCKER_HOST environment variable
* 2. Check DOCKER_HOST environment variable
* 3. Try to get socket from active Docker context
* 4. Fall back to platform-specific defaults
*/
function resolveDockerHost(dockerPath) {
	if (process.env.WRANGLER_DOCKER_HOST) return process.env.WRANGLER_DOCKER_HOST;
	if (process.env.DOCKER_HOST) return process.env.DOCKER_HOST;
	const contextSocket = getDockerSocketFromContext(dockerPath);
	if (contextSocket) return contextSocket;
	return process.platform === "win32" ? "//./pipe/docker_engine" : "unix:///var/run/docker.sock";
}
/**
* Get all repository tags for a given image
*/
async function getImageRepoTags(dockerPath, imageTag) {
	try {
		return (await dockerImageInspect(dockerPath, {
			imageTag,
			formatString: "{{ range .RepoTags }}{{ . }}\n{{ end }}"
		})).split("\n").filter((tag) => tag.trim() !== "");
	} catch {
		return [];
	}
}
/**
* Checks if the given image has any duplicate tags from previous dev sessions,
* and remove them if so.
*/
async function cleanupDuplicateImageTags(dockerPath, imageTag) {
	try {
		const tagsToRemove = (await getImageRepoTags(dockerPath, imageTag)).filter((tag) => tag !== imageTag && tag.startsWith("cloudflare-dev"));
		if (tagsToRemove.length > 0) runDockerCmdWithOutput(dockerPath, ["rmi", ...tagsToRemove]);
	} catch {}
}

//#endregion
//#region ../containers-shared/src/images.ts
async function pullImage(dockerPath, options) {
	const domain = new URL(`http://${options.image_uri}`).hostname;
	await dockerLoginImageRegistry(dockerPath, domain);
	const pull = runDockerCmd(dockerPath, [
		"pull",
		options.image_uri,
		"--platform",
		"linux/amd64"
	]);
	return {
		abort: () => {
			pull.abort();
		},
		ready: pull.ready.then(async ({ aborted }) => {
			if (!aborted) await runDockerCmd(dockerPath, [
				"tag",
				options.image_uri,
				options.image_tag
			]);
		})
	};
}
/**
*
* Builds or pulls the container images for local development. This
* will be called before starting the local development server, and by a rebuild
* hotkey during development.
*
* Because this runs when local dev starts, we also do some validation here,
* such as checking if the Docker CLI is installed, and if the container images
* expose any ports.
*/
async function prepareContainerImagesForDev(args) {
	const { dockerPath, containerOptions, onContainerImagePreparationStart, onContainerImagePreparationEnd } = args;
	let aborted = false;
	if (process.platform === "win32") throw new UserError("Local development with containers is currently not supported on Windows. You should use WSL instead. You can also set `enable_containers` to false if you do not need to develop the container part of your application.");
	await verifyDockerInstalled(dockerPath);
	for (const options of containerOptions) {
		if ("dockerfile" in options) {
			const build = await buildImage(dockerPath, options);
			onContainerImagePreparationStart({
				containerOptions: options,
				abort: () => {
					aborted = true;
					build.abort();
				}
			});
			await build.ready;
			onContainerImagePreparationEnd({ containerOptions: options });
		} else {
			const pull = await pullImage(dockerPath, options);
			onContainerImagePreparationStart({
				containerOptions: options,
				abort: () => {
					aborted = true;
					pull.abort();
				}
			});
			await pull.ready;
			onContainerImagePreparationEnd({ containerOptions: options });
		}
		if (!aborted) {
			await cleanupDuplicateImageTags(dockerPath, options.image_tag);
			await checkExposedPorts(dockerPath, options);
		}
	}
}

//#endregion
//#region ../workers-shared/asset-worker/src/utils/rules-engine.ts
const ESCAPE_REGEX_CHARACTERS = /[-/\\^$*+?.()|[\]{}]/g;
const escapeRegex = (str) => {
	return str.replace(ESCAPE_REGEX_CHARACTERS, "\\$&");
};
const generateGlobOnlyRuleRegExp = (rule) => {
	rule = rule.split("*").map(escapeRegex).join(".*");
	rule = "^" + rule + "$";
	return RegExp(rule);
};
const generateStaticRoutingRuleMatcher = (rules) => ({ request: request$1 }) => {
	const { pathname } = new URL(request$1.url);
	for (const rule of rules) try {
		if (generateGlobOnlyRuleRegExp(rule).test(pathname)) return true;
	} catch {}
	return false;
};

//#endregion
//#region src/constants.ts
const ROUTER_WORKER_NAME = "__router-worker__";
const ASSET_WORKER_NAME = "__asset-worker__";
const VITE_PROXY_WORKER_NAME = "__vite_proxy_worker__";
const kRequestType = Symbol("kRequestType");

//#endregion
//#region src/containers.ts
/**
* Returns the path to the Docker executable as defined by the
* `WRANGLER_DOCKER_BIN` environment variable, or the default value
* `"docker"`
*/
function getDockerPath() {
	return process.env["WRANGLER_DOCKER_BIN"] || "docker";
}
/**
* @returns Container options suitable for building or pulling images,
* with image tag set to well-known dev format, or undefined if
* containers are not enabled or not configured.
*/
function getContainerOptions(options) {
	const { containersConfig, containerBuildId, configPath } = options;
	if (!containersConfig?.length) return;
	return containersConfig.map((container) => {
		if (isDockerfile(container.image, configPath)) return {
			dockerfile: container.image,
			image_build_context: container.image_build_context ?? path.dirname(container.image),
			image_vars: container.image_vars,
			class_name: container.class_name,
			image_tag: getDevContainerImageName(container.class_name, containerBuildId)
		};
		else return {
			image_uri: container.image,
			class_name: container.class_name,
			image_tag: getDevContainerImageName(container.class_name, containerBuildId)
		};
	});
}

//#endregion
//#region src/miniflare-options.ts
const INTERNAL_WORKERS_COMPATIBILITY_DATE = "2024-10-04";
const PUBLIC_DIR_PREFIX = "/__vite_public_dir__";
function getPersistenceRoot(root, persistState) {
	if (persistState === false) return;
	return path$2.resolve(root, typeof persistState === "object" ? persistState.path : ".wrangler/state", "v3");
}
const miniflareModulesRoot = process.platform === "win32" ? "Z:\\" : "/";
const ROUTER_WORKER_PATH = "./workers/router-worker.js";
const ASSET_WORKER_PATH = "./workers/asset-worker.js";
const VITE_PROXY_WORKER_PATH = "./workers/vite-proxy-worker.js";
const RUNNER_PATH = "./workers/runner-worker.js";
const WRAPPER_PATH = "__VITE_WORKER_ENTRY__";
function logUnknownTails(tails, userWorkers, log) {
	for (const tailService of tails ?? []) {
		let name;
		if (typeof tailService === "string") name = tailService;
		else if (typeof tailService === "object" && "name" in tailService && typeof tailService.name === "string") name = tailService.name;
		else continue;
		if (!userWorkers.some((w) => w.name === name)) log(colors.dim(colors.yellow(`Tail consumer "${name}" was not found in your config. Make sure you add it to the config or run it in another dev session if you'd like to simulate receiving tail events locally.`)));
	}
}
/** Map that maps worker configPaths to their existing remote proxy session data (if any) */
const remoteProxySessionsDataMap = /* @__PURE__ */ new Map();
async function getDevMiniflareOptions(ctx, viteDevServer) {
	const inputInspectorPort = await getInputInspectorPort(ctx, viteDevServer);
	const { resolvedPluginConfig, resolvedViteConfig, entryWorkerConfig } = ctx;
	const assetsConfig = getAssetsConfig(resolvedPluginConfig, entryWorkerConfig, resolvedViteConfig);
	const assetWorkers = [
		{
			name: ROUTER_WORKER_NAME,
			compatibilityDate: INTERNAL_WORKERS_COMPATIBILITY_DATE,
			modulesRoot: miniflareModulesRoot,
			modules: [{
				type: "ESModule",
				path: path$2.join(miniflareModulesRoot, ROUTER_WORKER_PATH),
				contents: fs$1.readFileSync(fileURLToPath(new URL(ROUTER_WORKER_PATH, import.meta.url)))
			}],
			bindings: { CONFIG: { has_user_worker: resolvedPluginConfig.type === "workers" } },
			serviceBindings: {
				ASSET_WORKER: ASSET_WORKER_NAME,
				...entryWorkerConfig ? { USER_WORKER: entryWorkerConfig.name } : {}
			}
		},
		{
			name: ASSET_WORKER_NAME,
			compatibilityDate: INTERNAL_WORKERS_COMPATIBILITY_DATE,
			modulesRoot: miniflareModulesRoot,
			modules: [{
				type: "ESModule",
				path: path$2.join(miniflareModulesRoot, ASSET_WORKER_PATH),
				contents: fs$1.readFileSync(fileURLToPath(new URL(ASSET_WORKER_PATH, import.meta.url)))
			}],
			bindings: {
				CONFIG: assetsConfig,
				__VITE_HEADERS__: JSON.stringify(viteDevServer.config.server.headers)
			},
			serviceBindings: {
				__VITE_HTML_EXISTS__: async (request$1) => {
					const { pathname } = new URL(request$1.url);
					if (pathname.endsWith(".html")) {
						const { root, publicDir } = resolvedViteConfig;
						const publicDirInRoot = publicDir.startsWith(withTrailingSlash(root));
						const publicPath = withTrailingSlash(publicDir.slice(root.length));
						if (publicDirInRoot && pathname.startsWith(publicPath)) return Response$1.json(null);
						const publicDirFilePath = path$2.join(publicDir, pathname);
						const rootDirFilePath = path$2.join(root, pathname);
						for (const resolvedPath of [publicDirFilePath, rootDirFilePath]) try {
							if ((await fsp.stat(resolvedPath)).isFile()) return Response$1.json(resolvedPath === publicDirFilePath ? `${PUBLIC_DIR_PREFIX}${pathname}` : pathname);
						} catch (error) {}
					}
					return Response$1.json(null);
				},
				__VITE_FETCH_HTML__: async (request$1) => {
					const { pathname } = new URL(request$1.url);
					const { root, publicDir } = resolvedViteConfig;
					const isInPublicDir = pathname.startsWith(PUBLIC_DIR_PREFIX);
					const resolvedPath = isInPublicDir ? path$2.join(publicDir, pathname.slice(20)) : path$2.join(root, pathname);
					try {
						let html = await fsp.readFile(resolvedPath, "utf-8");
						if (!isInPublicDir) html = await viteDevServer.transformIndexHtml(resolvedPath, html);
						return new Response$1(html, { headers: { "Content-Type": "text/html" } });
					} catch (error) {
						throw new Error(`Unexpected error. Failed to load "${pathname}".`);
					}
				}
			}
		},
		{
			name: VITE_PROXY_WORKER_NAME,
			compatibilityDate: INTERNAL_WORKERS_COMPATIBILITY_DATE,
			modulesRoot: miniflareModulesRoot,
			modules: [{
				type: "ESModule",
				path: path$2.join(miniflareModulesRoot, VITE_PROXY_WORKER_PATH),
				contents: fs$1.readFileSync(fileURLToPath(new URL(VITE_PROXY_WORKER_PATH, import.meta.url)))
			}],
			serviceBindings: {
				...entryWorkerConfig ? { ENTRY_USER_WORKER: entryWorkerConfig.name } : {},
				__VITE_MIDDLEWARE__: { node: (req, res) => viteDevServer.middlewares(req, res) }
			}
		}
	];
	const containerTagToOptionsMap = /* @__PURE__ */ new Map();
	const workersFromConfig = resolvedPluginConfig.type === "workers" ? await Promise.all([...resolvedPluginConfig.environmentNameToWorkerMap].map(async ([environmentName, worker]) => {
		const bindings = unstable_convertConfigBindingsToStartWorkerBindings(worker.config);
		const preExistingRemoteProxySession = worker.config.configPath ? remoteProxySessionsDataMap.get(worker.config.configPath) : void 0;
		const remoteProxySessionData = !resolvedPluginConfig.remoteBindings ? null : await maybeStartOrUpdateRemoteProxySession({
			name: worker.config.name,
			bindings: bindings ?? {}
		}, preExistingRemoteProxySession ?? null);
		if (worker.config.configPath && remoteProxySessionData) remoteProxySessionsDataMap.set(worker.config.configPath, remoteProxySessionData);
		let containerBuildId;
		if (worker.config.containers?.length && worker.config.dev.enable_containers) {
			const dockerPath = getDockerPath();
			worker.config.dev.container_engine = resolveDockerHost(dockerPath);
			containerBuildId = generateContainerBuildId();
			const options = getContainerOptions({
				containersConfig: worker.config.containers,
				containerBuildId,
				configPath: worker.config.configPath
			});
			for (const option of options ?? []) containerTagToOptionsMap.set(option.image_tag, option);
		}
		const miniflareWorkerOptions = unstable_getMiniflareWorkerOptions({
			...worker.config,
			assets: void 0
		}, resolvedPluginConfig.cloudflareEnv, {
			remoteProxyConnectionString: remoteProxySessionData?.session?.remoteProxyConnectionString,
			containerBuildId
		});
		const { externalWorkers: externalWorkers$1 } = miniflareWorkerOptions;
		const workerOptions = miniflareWorkerOptions.workerOptions;
		return {
			externalWorkers: externalWorkers$1,
			worker: {
				...workerOptions,
				name: workerOptions.name ?? worker.config.name,
				unsafeInspectorProxy: inputInspectorPort !== false,
				unsafeDirectSockets: environmentName === resolvedPluginConfig.entryWorkerEnvironmentName ? [{
					serviceName: VITE_PROXY_WORKER_NAME,
					entrypoint: void 0,
					proxy: true
				}] : [],
				modulesRoot: miniflareModulesRoot,
				unsafeEvalBinding: "__VITE_UNSAFE_EVAL__",
				serviceBindings: {
					...workerOptions.serviceBindings,
					...environmentName === resolvedPluginConfig.entryWorkerEnvironmentName && worker.config.assets?.binding ? { [worker.config.assets.binding]: { node: (req, res) => {
						req[kRequestType] = "asset";
						viteDevServer.middlewares(req, res);
					} } } : {},
					__VITE_INVOKE_MODULE__: async (request$1) => {
						const payload = await request$1.json();
						const result = await viteDevServer.environments[environmentName].hot.handleInvoke(payload);
						return Response$1.json(result);
					}
				}
			}
		};
	})) : [];
	const userWorkers = workersFromConfig.map((options) => options.worker);
	const externalWorkers = workersFromConfig.flatMap((options) => options.externalWorkers);
	const logger = new ViteMiniflareLogger(resolvedViteConfig);
	return {
		miniflareOptions: {
			log: logger,
			logRequests: false,
			inspectorPort: inputInspectorPort === false ? void 0 : inputInspectorPort,
			unsafeDevRegistryPath: getDefaultDevRegistryPath(),
			unsafeTriggerHandlers: true,
			handleStructuredLogs: getStructuredLogsLogger(logger),
			defaultPersistRoot: getPersistenceRoot(resolvedViteConfig.root, resolvedPluginConfig.persistState),
			workers: [
				...assetWorkers,
				...externalWorkers,
				...userWorkers.map((workerOptions) => {
					const wrappers = [
						`import { createWorkerEntrypointWrapper, createDurableObjectWrapper, createWorkflowEntrypointWrapper } from "${RUNNER_PATH}";`,
						`export { __VITE_RUNNER_OBJECT__ } from "${RUNNER_PATH}";`,
						`export default createWorkerEntrypointWrapper("default");`
					];
					const exportTypes = ctx.workerNameToExportTypesMap.get(workerOptions.name);
					assert(exportTypes, `Expected exportTypes to be defined`);
					for (const [name, type] of Object.entries(exportTypes)) wrappers.push(`export const ${name} = create${type}Wrapper("${name}");`);
					logUnknownTails(workerOptions.tails, userWorkers, viteDevServer.config.logger.warn);
					return {
						...workerOptions,
						durableObjects: {
							...workerOptions.durableObjects,
							__VITE_RUNNER_OBJECT__: {
								className: "__VITE_RUNNER_OBJECT__",
								unsafeUniqueKey: kUnsafeEphemeralUniqueKey,
								unsafePreventEviction: true
							}
						},
						modules: [{
							type: "ESModule",
							path: path$2.join(miniflareModulesRoot, WRAPPER_PATH),
							contents: wrappers.join("\n")
						}, {
							type: "ESModule",
							path: path$2.join(miniflareModulesRoot, RUNNER_PATH),
							contents: fs$1.readFileSync(fileURLToPath(new URL(RUNNER_PATH, import.meta.url)))
						}],
						unsafeUseModuleFallbackService: true
					};
				})
			],
			async unsafeModuleFallbackService(request$1) {
				const rawSpecifier = new URL(request$1.url).searchParams.get("rawSpecifier");
				assert(rawSpecifier, `Unexpected error: no specifier in request to module fallback service.`);
				const match = additionalModuleRE.exec(rawSpecifier);
				assert(match, `Unexpected error: no match for module: ${rawSpecifier}.`);
				const [full, moduleType, modulePath] = match;
				assert(moduleType, `Unexpected error: module type not found in reference: ${full}.`);
				assert(modulePath, `Unexpected error: module path not found in reference: ${full}.`);
				let contents;
				try {
					contents = await fsp.readFile(modulePath);
				} catch (error) {
					throw new Error(`Import "${modulePath}" not found. Does the file exist?`);
				}
				switch (moduleType) {
					case "CompiledWasm": return Response$1.json({ wasm: Array.from(contents) });
					case "Data": return Response$1.json({ data: Array.from(contents) });
					case "Text": return Response$1.json({ text: contents.toString() });
					default: return Response$1.error();
				}
			}
		},
		containerTagToOptionsMap
	};
}
function getPreviewModules(main, modulesRules) {
	assert(modulesRules, `Unexpected error: 'modulesRules' is undefined`);
	const rootPath = path$2.dirname(main);
	const entryPath = path$2.basename(main);
	return {
		rootPath,
		modules: [{
			type: "ESModule",
			path: entryPath
		}, ...modulesRules.flatMap(({ type, include }) => globSync(include, {
			cwd: rootPath,
			ignore: entryPath
		}).map((path$3) => ({
			type,
			path: path$3
		})))]
	};
}
async function getPreviewMiniflareOptions(ctx, vitePreviewServer) {
	const inputInspectorPort = await getInputInspectorPort(ctx, vitePreviewServer);
	const { resolvedPluginConfig, resolvedViteConfig } = ctx;
	const containerTagToOptionsMap = /* @__PURE__ */ new Map();
	const workers = (await Promise.all(resolvedPluginConfig.workers.map(async (workerConfig, i$1) => {
		const bindings = unstable_convertConfigBindingsToStartWorkerBindings(workerConfig);
		const preExistingRemoteProxySessionData = workerConfig.configPath ? remoteProxySessionsDataMap.get(workerConfig.configPath) : void 0;
		const remoteProxySessionData = !resolvedPluginConfig.remoteBindings ? null : await maybeStartOrUpdateRemoteProxySession({
			name: workerConfig.name,
			bindings: bindings ?? {}
		}, preExistingRemoteProxySessionData ?? null);
		if (workerConfig.configPath && remoteProxySessionData) remoteProxySessionsDataMap.set(workerConfig.configPath, remoteProxySessionData);
		let containerBuildId;
		if (workerConfig.containers?.length && workerConfig.dev.enable_containers) {
			const dockerPath = getDockerPath();
			workerConfig.dev.container_engine = resolveDockerHost(dockerPath);
			containerBuildId = generateContainerBuildId();
			const options = getContainerOptions({
				containersConfig: workerConfig.containers,
				containerBuildId,
				configPath: workerConfig.configPath
			});
			for (const option of options ?? []) containerTagToOptionsMap.set(option.image_tag, option);
		}
		const miniflareWorkerOptions = unstable_getMiniflareWorkerOptions(workerConfig, void 0, {
			remoteProxyConnectionString: remoteProxySessionData?.session?.remoteProxyConnectionString,
			containerBuildId
		});
		const { externalWorkers } = miniflareWorkerOptions;
		const { modulesRules,...workerOptions } = miniflareWorkerOptions.workerOptions;
		logUnknownTails(workerOptions.tails, resolvedPluginConfig.workers, vitePreviewServer.config.logger.warn);
		return [{
			...workerOptions,
			name: workerOptions.name ?? workerConfig.name,
			unsafeInspectorProxy: inputInspectorPort !== false,
			unsafeDirectSockets: i$1 === 0 ? [{
				entrypoint: void 0,
				proxy: true
			}] : [],
			...miniflareWorkerOptions.main ? getPreviewModules(miniflareWorkerOptions.main, modulesRules) : {
				modules: true,
				script: ""
			}
		}, ...externalWorkers];
	}))).flat();
	const logger = new ViteMiniflareLogger(resolvedViteConfig);
	return {
		miniflareOptions: {
			log: logger,
			inspectorPort: inputInspectorPort === false ? void 0 : inputInspectorPort,
			unsafeDevRegistryPath: getDefaultDevRegistryPath(),
			unsafeTriggerHandlers: true,
			handleStructuredLogs: getStructuredLogsLogger(logger),
			defaultPersistRoot: getPersistenceRoot(resolvedViteConfig.root, resolvedPluginConfig.persistState),
			workers
		},
		containerTagToOptionsMap
	};
}
/**
* A Miniflare logger that forwards messages onto a Vite logger.
*/
var ViteMiniflareLogger = class extends Log {
	logger;
	constructor(config) {
		super(miniflareLogLevelFromViteLogLevel(config.logLevel));
		this.logger = config.logger;
	}
	logWithLevel(level, message) {
		switch (level) {
			case LogLevel.ERROR: return this.logger.error(message);
			case LogLevel.WARN: return this.logger.warn(message);
			case LogLevel.INFO: return this.logger.info(message);
		}
	}
	logReady() {}
};
function miniflareLogLevelFromViteLogLevel(level = "info") {
	switch (level) {
		case "error": return LogLevel.ERROR;
		case "warn": return LogLevel.WARN;
		case "info": return LogLevel.INFO;
		case "silent": return LogLevel.NONE;
	}
}
/**
* Generates a log handler to be passed as the `handleStructuredLogs` option to miniflare
*
* @param logger the vite logger to use
* @returns the log handler to pass to miniflare
*/
function getStructuredLogsLogger(logger) {
	return ({ level, message }) => {
		if (level === "warn") return logger.warn(message);
		if (level === "error") return logger.logWithLevel(LogLevel.ERROR, message);
		return logger.info(message);
	};
}

//#endregion
//#region src/websockets.ts
/**
* Handles 'upgrade' requests to the Vite HTTP server and forwards WebSocket events between the client and Worker environments.
*/
function handleWebSocket(httpServer, miniflare, entryWorkerName) {
	const nodeWebSocket = new WebSocketServer({ noServer: true });
	httpServer.on("upgrade", async (request$1, socket, head) => {
		const url = new URL(request$1.url ?? "", UNKNOWN_HOST);
		if (request$1.headers["sec-websocket-protocol"]?.startsWith("vite")) return;
		const headers = createHeaders(request$1);
		if (entryWorkerName) headers.set(CoreHeaders.ROUTE_OVERRIDE, entryWorkerName);
		const workerWebSocket = (await miniflare.dispatchFetch(url, {
			headers,
			method: request$1.method
		})).webSocket;
		if (!workerWebSocket) {
			socket.destroy();
			return;
		}
		nodeWebSocket.handleUpgrade(request$1, socket, head, async (clientWebSocket) => {
			coupleWebSocket(clientWebSocket, workerWebSocket);
			nodeWebSocket.emit("connection", clientWebSocket, request$1);
		});
	});
}

//#endregion
//#region src/plugins/dev.ts
let exitCallback$2 = () => {};
process.on("exit", () => {
	exitCallback$2();
});
/**
* Plugin to provide core development functionality
*/
const devPlugin = createPlugin("dev", (ctx) => {
	let containerImageTags = /* @__PURE__ */ new Set();
	return {
		async buildEnd() {
			if (ctx.resolvedViteConfig.command === "serve" && containerImageTags.size) cleanupContainers(getDockerPath(), containerImageTags);
			debuglog("buildEnd:", ctx.isRestartingDevServer ? "restarted" : "disposing");
			if (!ctx.isRestartingDevServer) try {
				await ctx.disposeMiniflare();
			} catch (error) {
				debuglog("Failed to dispose Miniflare instance:", error);
			}
		},
		async configureServer(viteDevServer) {
			assertIsNotPreview(ctx);
			const initialOptions = await getDevMiniflareOptions(ctx, viteDevServer);
			let containerTagToOptionsMap = initialOptions.containerTagToOptionsMap;
			await ctx.startOrUpdateMiniflare(initialOptions.miniflareOptions);
			let preMiddleware;
			if (ctx.resolvedPluginConfig.type === "workers") {
				debuglog("Initializing the Vite module runners");
				await initRunners(ctx.resolvedPluginConfig, viteDevServer, ctx.miniflare);
				const currentWorkerNameToExportTypesMap = await getCurrentWorkerNameToExportTypesMap(ctx.resolvedPluginConfig, viteDevServer, ctx.miniflare);
				if (compareWorkerNameToExportTypesMaps(ctx.workerNameToExportTypesMap, currentWorkerNameToExportTypesMap)) {
					ctx.setWorkerNameToExportTypesMap(currentWorkerNameToExportTypesMap);
					const updatedOptions = await getDevMiniflareOptions(ctx, viteDevServer);
					containerTagToOptionsMap = updatedOptions.containerTagToOptionsMap;
					await ctx.startOrUpdateMiniflare(updatedOptions.miniflareOptions);
					await initRunners(ctx.resolvedPluginConfig, viteDevServer, ctx.miniflare);
				}
				for (const environmentName of ctx.resolvedPluginConfig.environmentNameToWorkerMap.keys()) {
					const environment = viteDevServer.environments[environmentName];
					assert(environment, `Expected environment "${environmentName}" to be defined`);
					environment.hot.on("vite-plugin-cloudflare:worker-export-types", async (newExportTypes) => {
						const workerConfig = ctx.getWorkerConfig(environmentName);
						assert(workerConfig, `Expected workerConfig for environment "${environmentName}" to be defined`);
						const oldExportTypes = ctx.workerNameToExportTypesMap.get(workerConfig.name);
						assert(oldExportTypes, `Expected export types for Worker "${workerConfig.name}" to be defined`);
						if (compareExportTypes(oldExportTypes, newExportTypes)) {
							viteDevServer.config.logger.info(colors.dim(colors.yellow("Worker exports have changed. Restarting dev server.")));
							await viteDevServer.restart();
						}
					});
				}
				const entryWorkerConfig = ctx.entryWorkerConfig;
				assert(entryWorkerConfig, `No entry Worker config`);
				const entryWorkerName = entryWorkerConfig.name;
				if (viteDevServer.httpServer) handleWebSocket(viteDevServer.httpServer, ctx.miniflare, entryWorkerName);
				const staticRouting = entryWorkerConfig.assets?.run_worker_first === true ? { user_worker: ["/*"] } : ctx.resolvedPluginConfig.staticRouting;
				if (staticRouting) {
					const excludeRulesMatcher = generateStaticRoutingRuleMatcher(staticRouting.asset_worker ?? []);
					const includeRulesMatcher = generateStaticRoutingRuleMatcher(staticRouting.user_worker);
					const userWorkerHandler = createRequestHandler(async (request$1) => {
						request$1.headers.set(CoreHeaders.ROUTE_OVERRIDE, entryWorkerName);
						return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
					});
					preMiddleware = async (req, res, next) => {
						assert(req.url, `req.url not defined`);
						const request$1 = new Request(new URL(req.url, UNKNOWN_HOST));
						if (req[kRequestType] === "asset") next();
						else if (excludeRulesMatcher({ request: request$1 })) {
							req[kRequestType] = "asset";
							next();
						} else if (includeRulesMatcher({ request: request$1 })) userWorkerHandler(req, res, next);
						else next();
					};
				}
				if (containerTagToOptionsMap.size) {
					viteDevServer.config.logger.info(colors.dim(colors.yellow("∷ Building container images for local development...\n")));
					await prepareContainerImagesForDev({
						dockerPath: getDockerPath(),
						containerOptions: [...containerTagToOptionsMap.values()],
						onContainerImagePreparationStart: () => {},
						onContainerImagePreparationEnd: () => {}
					});
					containerImageTags = new Set(containerTagToOptionsMap.keys());
					viteDevServer.config.logger.info(colors.dim(colors.yellow("\n⚡️ Containers successfully built. To rebuild your containers during development, restart the Vite dev server (r + enter).")));
					exitCallback$2 = () => {
						if (containerImageTags.size) cleanupContainers(getDockerPath(), containerImageTags);
					};
				}
			}
			return () => {
				if (preMiddleware) {
					const middlewareStack = viteDevServer.middlewares.stack;
					const cachedTransformMiddlewareIndex = middlewareStack.findIndex((middleware) => "name" in middleware.handle && middleware.handle.name === "viteCachedTransformMiddleware");
					assert(cachedTransformMiddlewareIndex !== -1, "Failed to find viteCachedTransformMiddleware");
					middlewareStack.splice(cachedTransformMiddlewareIndex, 0, {
						route: "",
						handle: preMiddleware
					});
				}
				viteDevServer.middlewares.use(createRequestHandler(async (request$1, req) => {
					if (req[kRequestType] === "asset") {
						request$1.headers.set(CoreHeaders.ROUTE_OVERRIDE, ASSET_WORKER_NAME);
						return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
					} else {
						request$1.headers.set(CoreHeaders.ROUTE_OVERRIDE, ROUTER_WORKER_NAME);
						return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
					}
				}));
			};
		}
	};
});

//#endregion
//#region src/plugins/nodejs-compat.ts
/**
* Plugin to support the `nodejs_als` compatibility flag
*/
const nodeJsAlsPlugin = createPlugin("nodejs-als", (ctx) => {
	return { configEnvironment(name) {
		if (hasNodeJsAls(ctx.getWorkerConfig(name))) return {
			resolve: { builtins: ["async_hooks", "node:async_hooks"] },
			optimizeDeps: { exclude: ["async_hooks", "node:async_hooks"] }
		};
	} };
});
/**
* Plugin to support the `nodejs_compat` compatibility flag
*/
const nodeJsCompatPlugin = createPlugin("nodejs-compat", (ctx) => {
	return {
		configEnvironment(name) {
			const nodeJsCompat = ctx.getNodeJsCompat(name);
			if (nodeJsCompat) return {
				resolve: { builtins: [...nodeJsCompat.externals] },
				optimizeDeps: { exclude: [...nodeJsBuiltins] }
			};
		},
		applyToEnvironment(environment) {
			return ctx.getNodeJsCompat(environment.name) !== void 0;
		},
		enforce: "pre",
		async resolveId(source, importer, options) {
			const nodeJsCompat = ctx.getNodeJsCompat(this.environment.name);
			assertHasNodeJsCompat(nodeJsCompat);
			if (nodeJsCompat.isGlobalVirtualModule(source)) return source;
			const result = nodeJsCompat.resolveNodeJsImport(source);
			if (!result) return this.resolve(source, importer, options);
			if (this.environment.mode === "dev") {
				assert(this.environment.depsOptimizer, "depsOptimizer is required in dev mode");
				const { id } = this.environment.depsOptimizer.registerMissingImport(result.unresolved, result.resolved);
				return this.resolve(id, importer, options);
			}
			return this.resolve(result.resolved, importer, options);
		},
		load(id) {
			const nodeJsCompat = ctx.getNodeJsCompat(this.environment.name);
			assertHasNodeJsCompat(nodeJsCompat);
			return nodeJsCompat.getGlobalVirtualModule(id);
		},
		async configureServer(viteDevServer) {
			await Promise.all(Object.values(viteDevServer.environments).flatMap(async (environment) => {
				const nodeJsCompat = ctx.getNodeJsCompat(environment.name);
				if (nodeJsCompat) {
					await environment.depsOptimizer?.init();
					return Array.from(nodeJsCompat.entries).map((entry) => {
						const result = nodeJsCompat.resolveNodeJsImport(entry);
						if (result) return (environment.depsOptimizer?.registerMissingImport(result.unresolved, result.resolved))?.processing;
					});
				}
			}));
		}
	};
});
let exitCallback$1 = () => {};
process.on("exit", () => {
	exitCallback$1();
});
/**
* Plugin to warn if Node.js APIs are used without enabling the `nodejs_compat` compatibility flag
*/
const nodeJsCompatWarningsPlugin = createPlugin("nodejs-compat-warnings", (ctx) => {
	const nodeJsCompatWarningsMap = /* @__PURE__ */ new Map();
	exitCallback$1 = () => {
		for (const nodeJsCompatWarnings of nodeJsCompatWarningsMap.values()) nodeJsCompatWarnings.renderWarnings();
	};
	return {
		enforce: "pre",
		configEnvironment(environmentName) {
			const workerConfig = ctx.getWorkerConfig(environmentName);
			const nodeJsCompat = ctx.getNodeJsCompat(environmentName);
			if (workerConfig && !nodeJsCompat) return { optimizeDeps: { esbuildOptions: { plugins: [{
				name: "vite-plugin-cloudflare:nodejs-compat-warnings-resolver",
				setup(build) {
					build.onResolve({ filter: NODEJS_MODULES_RE }, ({ path: path$3, importer }) => {
						if (hasNodeJsAls(workerConfig) && isNodeAlsModule(path$3)) return;
						nodeJsCompatWarningsMap.get(workerConfig)?.registerImport(path$3, importer);
						return {
							path: path$3,
							external: true
						};
					});
				}
			}] } } };
		},
		configResolved(resolvedViteConfig) {
			for (const environmentName of Object.keys(resolvedViteConfig.environments)) {
				const workerConfig = ctx.getWorkerConfig(environmentName);
				const nodeJsCompat = ctx.getNodeJsCompat(environmentName);
				if (workerConfig && !nodeJsCompat) nodeJsCompatWarningsMap.set(workerConfig, new NodeJsCompatWarnings(environmentName, resolvedViteConfig));
			}
		},
		async resolveId(source, importer) {
			const workerConfig = ctx.getWorkerConfig(this.environment.name);
			const nodeJsCompat = ctx.getNodeJsCompat(this.environment.name);
			if (workerConfig && !nodeJsCompat) {
				if (hasNodeJsAls(workerConfig) && isNodeAlsModule(source)) return;
				const nodeJsCompatWarnings = nodeJsCompatWarningsMap.get(workerConfig);
				if (nodeJsBuiltins.has(source)) {
					nodeJsCompatWarnings?.registerImport(source, importer);
					return {
						id: source,
						external: true
					};
				}
			}
		}
	};
});

//#endregion
//#region src/plugins/output-config.ts
/**
* Plugin to generate additional output files as part of the build, including the output `wrangler.json` file.
*/
const outputConfigPlugin = createPlugin("output-config", (ctx) => {
	return {
		generateBundle(_, bundle) {
			assertIsNotPreview(ctx);
			let outputConfig;
			if (ctx.resolvedPluginConfig.type === "workers") {
				const inputConfig = ctx.getWorkerConfig(this.environment.name);
				if (!inputConfig) return;
				const entryChunk = Object.values(bundle).find((chunk) => chunk.type === "chunk" && chunk.isEntry && chunk.name === MAIN_ENTRY_NAME);
				assert(entryChunk, `Expected entry chunk with name "${MAIN_ENTRY_NAME}"`);
				const isEntryWorker = this.environment.name === ctx.resolvedPluginConfig.entryWorkerEnvironmentName;
				outputConfig = {
					...inputConfig,
					main: entryChunk.fileName,
					no_bundle: true,
					rules: [{
						type: "ESModule",
						globs: ["**/*.js", "**/*.mjs"]
					}],
					assets: isEntryWorker ? {
						...inputConfig.assets,
						directory: getAssetsDirectory(this.environment.config.build.outDir, ctx.resolvedViteConfig)
					} : void 0
				};
				if (inputConfig.configPath) {
					const localDevVars = getLocalDevVarsForPreview(inputConfig.configPath, ctx.resolvedPluginConfig.cloudflareEnv);
					if (localDevVars) this.emitFile({
						type: "asset",
						fileName: ".dev.vars",
						source: localDevVars
					});
				}
			} else if (this.environment.name === "client") {
				const inputConfig = ctx.resolvedPluginConfig.config;
				outputConfig = {
					...inputConfig,
					assets: {
						...inputConfig.assets,
						directory: "."
					}
				};
				this.emitFile({
					type: "asset",
					fileName: ".assetsignore",
					source: `${["wrangler.json", ".dev.vars"].join("\n")}\n`
				});
			}
			if (!outputConfig) return;
			if (outputConfig.unsafe && Object.keys(outputConfig.unsafe).length === 0) outputConfig.unsafe = void 0;
			this.emitFile({
				type: "asset",
				fileName: "wrangler.json",
				source: JSON.stringify(outputConfig)
			});
		},
		writeBundle() {
			assertIsNotPreview(ctx);
			if (this.environment.name === (ctx.resolvedPluginConfig.type === "workers" ? ctx.resolvedPluginConfig.entryWorkerEnvironmentName : "client")) writeDeployConfig(ctx.resolvedPluginConfig, ctx.resolvedViteConfig);
		}
	};
});
function getAssetsDirectory(workerOutputDirectory, resolvedViteConfig) {
	const clientOutputDirectory = resolvedViteConfig.environments.client?.build.outDir;
	assert(clientOutputDirectory, "Unexpected error: client output directory is undefined");
	return path$2.relative(path$2.resolve(resolvedViteConfig.root, workerOutputDirectory), path$2.resolve(resolvedViteConfig.root, clientOutputDirectory));
}

//#endregion
//#region src/plugins/preview.ts
let exitCallback = () => {};
process.on("exit", () => {
	exitCallback();
});
/**
* Plugin to provide core preview functionality
*/
const previewPlugin = createPlugin("preview", (ctx) => {
	return { async configurePreviewServer(vitePreviewServer) {
		assertIsPreview(ctx);
		const closePreviewServer = vitePreviewServer.close.bind(vitePreviewServer);
		vitePreviewServer.close = async () => {
			await Promise.all([ctx.disposeMiniflare(), closePreviewServer()]);
		};
		const { miniflareOptions, containerTagToOptionsMap } = await getPreviewMiniflareOptions(ctx, vitePreviewServer);
		await ctx.startOrUpdateMiniflare(miniflareOptions);
		if (containerTagToOptionsMap.size) {
			const dockerPath = getDockerPath();
			vitePreviewServer.config.logger.info(colors.dim(colors.yellow("∷ Building container images for local preview...\n")));
			await prepareContainerImagesForDev({
				dockerPath: getDockerPath(),
				containerOptions: [...containerTagToOptionsMap.values()],
				onContainerImagePreparationStart: () => {},
				onContainerImagePreparationEnd: () => {}
			});
			const containerImageTags = new Set(containerTagToOptionsMap.keys());
			vitePreviewServer.config.logger.info(colors.dim(colors.yellow("\n⚡️ Containers successfully built.\n")));
			exitCallback = () => {
				if (containerImageTags.size) cleanupContainers(dockerPath, containerImageTags);
			};
		}
		handleWebSocket(vitePreviewServer.httpServer, ctx.miniflare);
		vitePreviewServer.middlewares.use(createRequestHandler((request$1) => {
			return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
		}));
	} };
});

//#endregion
//#region src/plugins/trigger-handlers.ts
/**
* Plugin to forward `/cdn-cgi/handler/*` routes to trigger handlers in development
*/
const triggerHandlersPlugin = createPlugin("trigger-handlers", (ctx) => {
	return {
		enforce: "pre",
		async configureServer(viteDevServer) {
			const entryWorkerConfig = ctx.entryWorkerConfig;
			if (!entryWorkerConfig) return;
			const entryWorkerName = entryWorkerConfig.name;
			const requestHandler = createRequestHandler((request$1) => {
				request$1.headers.set(CoreHeaders.ROUTE_OVERRIDE, entryWorkerName);
				return ctx.miniflare.dispatchFetch(request$1, { redirect: "manual" });
			});
			viteDevServer.middlewares.use("/cdn-cgi/handler/", requestHandler);
		}
	};
});

//#endregion
//#region src/plugins/wasm.ts
/**
* Plugin to support the `.wasm?init` extension
*/
const wasmHelperPlugin = createPlugin("wasm-helper", (ctx) => {
	return {
		enforce: "pre",
		applyToEnvironment(environment) {
			return ctx.getWorkerConfig(environment.name) !== void 0;
		},
		load(id) {
			if (!id.endsWith(".wasm?init")) return;
			return `
					import wasm from "${cleanUrl(id)}";
					export default function(opts = {}) {
						return WebAssembly.instantiate(wasm, opts);
					}
				`;
		}
	};
});

//#endregion
//#region src/index.ts
const sharedContext = {
	hasShownWorkerConfigWarnings: false,
	isRestartingDevServer: false
};
/**
* Vite plugin that enables a full-featured integration between Vite and the Cloudflare Workers runtime.
*
* See the [README](https://github.com/cloudflare/workers-sdk/tree/main/packages/vite-plugin-cloudflare#readme) for more details.
*
* @param pluginConfig An optional {@link PluginConfig} object.
*/
function cloudflare(pluginConfig = {}) {
	const ctx = new PluginContext(sharedContext);
	return [
		{
			name: "vite-plugin-cloudflare",
			sharedDuringBuild: true,
			config(userConfig, env) {
				ctx.setResolvedPluginConfig(resolvePluginConfig(pluginConfig, userConfig, env));
			},
			async configureServer(viteDevServer) {
				const restartServer = viteDevServer.restart.bind(viteDevServer);
				viteDevServer.restart = async () => {
					try {
						ctx.setIsRestartingDevServer(true);
						debuglog("From server.restart(): Restarting server...");
						await restartServer();
						debuglog("From server.restart(): Restarted server...");
					} finally {
						ctx.setIsRestartingDevServer(false);
					}
				};
			}
		},
		configPlugin(ctx),
		devPlugin(ctx),
		previewPlugin(ctx),
		debugPlugin(ctx),
		triggerHandlersPlugin(ctx),
		virtualModulesPlugin(ctx),
		virtualClientFallbackPlugin(ctx),
		outputConfigPlugin(ctx),
		wasmHelperPlugin(ctx),
		additionalModulesPlugin(ctx),
		nodeJsAlsPlugin(ctx),
		nodeJsCompatPlugin(ctx),
		nodeJsCompatWarningsPlugin(ctx)
	];
}

//#endregion
export { cloudflare };
//# sourceMappingURL=index.mjs.map