{
  "version": 3,
  "sources": ["../../@vercel/oidc/dist/get-context.js", "../../@vercel/oidc/dist/index-browser.js", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider/src/json-value/is-json.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/delay.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/generate-id.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/get-from-api.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/handle-fetch-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/get-runtime-environment-user-agent.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/normalize-headers.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/with-user-agent-suffix.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/version.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/inject-json-instruction.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/is-url-supported.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/load-setting.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/media-type-to-extension.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/parse-json.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/secure-json-parse.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/validate-types.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/validator.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/parse-json-event-stream.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/types/tool.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/provider-defined-tool-factory.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/resolve.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/response-handler.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-schema.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/get-relative-path.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/options.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/select-parser.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/any.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/array.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/bigint.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/boolean.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/branded.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/catch.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/date.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/default.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/effects.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/enum.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/intersection.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/literal.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/record.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/string.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/map.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/native-enum.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/never.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/null.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/union.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/nullable.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/number.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/object.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/optional.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/pipeline.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/promise.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/set.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/tuple.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/undefined.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/unknown.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parsers/readonly.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/parse-def.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/refs.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/zod-to-json-schema.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/zod-to-json-schema/index.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/schema.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/is-async-iterable.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/types/execute-tool.ts", "../../@ai-sdk/gateway/node_modules/@ai-sdk/provider-utils/src/index.ts", "../../@ai-sdk/gateway/src/gateway-provider.ts", "../../@ai-sdk/gateway/src/errors/as-gateway-error.ts", "../../@ai-sdk/gateway/src/errors/create-gateway-error.ts", "../../@ai-sdk/gateway/src/errors/gateway-error.ts", "../../@ai-sdk/gateway/src/errors/gateway-authentication-error.ts", "../../@ai-sdk/gateway/src/errors/gateway-invalid-request-error.ts", "../../@ai-sdk/gateway/src/errors/gateway-rate-limit-error.ts", "../../@ai-sdk/gateway/src/errors/gateway-model-not-found-error.ts", "../../@ai-sdk/gateway/src/errors/gateway-internal-server-error.ts", "../../@ai-sdk/gateway/src/errors/gateway-response-error.ts", "../../@ai-sdk/gateway/src/errors/extract-api-call-response.ts", "../../@ai-sdk/gateway/src/errors/parse-auth-method.ts", "../../@ai-sdk/gateway/src/gateway-fetch-metadata.ts", "../../@ai-sdk/gateway/src/gateway-language-model.ts", "../../@ai-sdk/gateway/src/gateway-embedding-model.ts", "../../@ai-sdk/gateway/src/gateway-image-model.ts", "../../@ai-sdk/gateway/src/vercel-environment.ts", "../../@ai-sdk/gateway/src/version.ts", "../../@opentelemetry/api/src/trace/status.ts", "../../@opentelemetry/api/src/platform/node/globalThis.ts", "../../@opentelemetry/api/src/version.ts", "../../@opentelemetry/api/src/internal/semver.ts", "../../@opentelemetry/api/src/internal/global-utils.ts", "../../@opentelemetry/api/src/context/context.ts", "../../@opentelemetry/api/src/context/NoopContextManager.ts", "../../@opentelemetry/api/src/diag/ComponentLogger.ts", "../../@opentelemetry/api/src/diag/types.ts", "../../@opentelemetry/api/src/diag/internal/logLevelLogger.ts", "../../@opentelemetry/api/src/api/diag.ts", "../../@opentelemetry/api/src/api/context.ts", "../../@opentelemetry/api/src/trace/trace_flags.ts", "../../@opentelemetry/api/src/trace/invalid-span-constants.ts", "../../@opentelemetry/api/src/trace/NonRecordingSpan.ts", "../../@opentelemetry/api/src/trace/context-utils.ts", "../../@opentelemetry/api/src/trace/spancontext-utils.ts", "../../@opentelemetry/api/src/trace/NoopTracer.ts", "../../@opentelemetry/api/src/trace/ProxyTracer.ts", "../../@opentelemetry/api/src/trace/NoopTracerProvider.ts", "../../@opentelemetry/api/src/trace/ProxyTracerProvider.ts", "../../@opentelemetry/api/src/api/trace.ts", "../../@opentelemetry/api/src/trace-api.ts", "../../@opentelemetry/api/src/baggage/internal/baggage-impl.ts", "../../@opentelemetry/api/src/baggage/internal/symbol.ts", "../../@opentelemetry/api/src/baggage/utils.ts", "../../@opentelemetry/api/src/metrics/NoopMeter.ts", "../../@opentelemetry/api/src/metrics/Metric.ts", "../../@opentelemetry/api/src/propagation/TextMapPropagator.ts", "../../@opentelemetry/api/src/trace/SamplingResult.ts", "../../@opentelemetry/api/src/trace/span_kind.ts", "../../@opentelemetry/api/src/trace/internal/tracestate-validators.ts", "../../@opentelemetry/api/src/trace/internal/tracestate-impl.ts", "../../@opentelemetry/api/src/context-api.ts", "../../@opentelemetry/api/src/diag-api.ts", "../../@opentelemetry/api/src/metrics/NoopMeterProvider.ts", "../../@opentelemetry/api/src/api/metrics.ts", "../../@opentelemetry/api/src/metrics-api.ts", "../../@opentelemetry/api/src/propagation/NoopTextMapPropagator.ts", "../../@opentelemetry/api/src/baggage/context-helpers.ts", "../../@opentelemetry/api/src/api/propagation.ts", "../../@opentelemetry/api/src/propagation-api.ts"],
  "sourcesContent": ["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar get_context_exports = {};\n__export(get_context_exports, {\n  SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,\n  getContext: () => getContext\n});\nmodule.exports = __toCommonJS(get_context_exports);\nconst SYMBOL_FOR_REQ_CONTEXT = Symbol.for(\"@vercel/request-context\");\nfunction getContext() {\n  const fromSymbol = globalThis;\n  return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  SYMBOL_FOR_REQ_CONTEXT,\n  getContext\n});\n", "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar index_browser_exports = {};\n__export(index_browser_exports, {\n  getContext: () => import_get_context.getContext,\n  getVercelOidcToken: () => getVercelOidcToken,\n  getVercelOidcTokenSync: () => getVercelOidcTokenSync\n});\nmodule.exports = __toCommonJS(index_browser_exports);\nvar import_get_context = require(\"./get-context\");\nasync function getVercelOidcToken() {\n  return \"\";\n}\nfunction getVercelOidcTokenSync() {\n  return \"\";\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  getContext,\n  getVercelOidcToken,\n  getVercelOidcTokenSync\n});\n", "/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType:\n    | 'languageModel'\n    | 'textEmbeddingModel'\n    | 'imageModel'\n    | 'transcriptionModel'\n    | 'speechModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType:\n      | 'languageModel'\n      | 'textEmbeddingModel'\n      | 'imageModel'\n      | 'transcriptionModel'\n      | 'speechModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n", "export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n", "/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  let cancelled = false;\n\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      if (cancelled) return;\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    async cancel(reason?: unknown) {\n      cancelled = true;\n      if (iterator.return) {\n        try {\n          await iterator.return(reason);\n        } catch {\n          // intentionally ignore errors during cancellation\n        }\n      }\n    },\n  });\n}\n", "/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @param signal - Optional AbortSignal to cancel the delay\n * @returns A Promise that resolves after the specified delay\n * @throws {DOMException} When the signal is aborted\n */\nexport async function delay(\n  delayInMs?: number | null,\n  options?: {\n    abortSignal?: AbortSignal;\n  },\n): Promise<void> {\n  if (delayInMs == null) {\n    return Promise.resolve();\n  }\n\n  const signal = options?.abortSignal;\n\n  return new Promise<void>((resolve, reject) => {\n    if (signal?.aborted) {\n      reject(createAbortError());\n      return;\n    }\n\n    const timeoutId = setTimeout(() => {\n      cleanup();\n      resolve();\n    }, delayInMs);\n\n    const cleanup = () => {\n      clearTimeout(timeoutId);\n      signal?.removeEventListener('abort', onAbort);\n    };\n\n    const onAbort = () => {\n      cleanup();\n      reject(createAbortError());\n    };\n\n    signal?.addEventListener('abort', onAbort);\n  });\n}\n\nfunction createAbortError(): DOMException {\n  return new DOMException('Delay was aborted', 'AbortError');\n}\n", "/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(response: Response) {\n  return Object.fromEntries<string>([...response.headers]);\n}\n", "import { InvalidArgumentError } from '@ai-sdk/provider';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNot cryptographically secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Optional.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\nexport const createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): IdGenerator => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[(Math.random() * alphabetLength) | 0];\n    }\n    return chars.join('');\n  };\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return () => `${prefix}${separator}${generator()}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IdGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs.\nNot cryptographically secure.\n */\nexport const generateId = createIdGenerator();\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { handleFetchError } from './handle-fetch-error';\nimport { isAbortError } from './is-abort-error';\nimport { ResponseHandler } from './response-handler';\nimport { getRuntimeEnvironmentUserAgent } from './get-runtime-environment-user-agent';\nimport { withUserAgentSuffix } from './with-user-agent-suffix';\nimport { VERSION } from './version';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent(),\n      ),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: {} });\n  }\n};\n", "import { APICallError } from '@ai-sdk/provider';\nimport { isAbortError } from './is-abort-error';\n\nconst FETCH_FAILED_ERROR_MESSAGES = ['fetch failed', 'failed to fetch'];\n\nexport function handleFetchError({\n  error,\n  url,\n  requestBodyValues,\n}: {\n  error: unknown;\n  url: string;\n  requestBodyValues: unknown;\n}) {\n  if (isAbortError(error)) {\n    return error;\n  }\n\n  // unwrap original error when fetch failed (for easier debugging):\n  if (\n    error instanceof TypeError &&\n    FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())\n  ) {\n    const cause = (error as any).cause;\n\n    if (cause != null) {\n      // Failed to connect to server:\n      return new APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url,\n        requestBodyValues,\n        isRetryable: true, // retry when network error\n      });\n    }\n  }\n\n  return error;\n}\n", "export function isAbortError(error: unknown): error is Error {\n  return (\n    (error instanceof Error || error instanceof DOMException) &&\n    (error.name === 'AbortError' ||\n      error.name === 'ResponseAborted' || // Next.js\n      error.name === 'TimeoutError')\n  );\n}\n", "export function getRuntimeEnvironmentUserAgent(\n  globalThisAny: any = globalThis as any,\n): string {\n  // Browsers\n  if (globalThisAny.window) {\n    return `runtime/browser`;\n  }\n\n  // Cloudflare Workers / Deno / Bun / Node.js >= 21.1\n  if (globalThisAny.navigator?.userAgent) {\n    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;\n  }\n\n  // Nodes.js < 21.1\n  if (globalThisAny.process?.versions?.node) {\n    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;\n  }\n\n  if (globalThisAny.EdgeRuntime) {\n    return `runtime/vercel-edge`;\n  }\n\n  return 'runtime/unknown';\n}\n", "/**\n * Normalizes different header inputs into a plain record with lower-case keys.\n * Entries with `undefined` or `null` values are removed.\n *\n * @param headers - Input headers (`Headers`, tuples array, plain record) to normalize.\n * @returns A record containing the normalized header entries.\n */\nexport function normalizeHeaders(\n  headers:\n    | HeadersInit\n    | Record<string, string | undefined>\n    | Array<[string, string | undefined]>\n    | undefined,\n): Record<string, string> {\n  if (headers == null) {\n    return {};\n  }\n\n  const normalized: Record<string, string> = {};\n\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      normalized[key.toLowerCase()] = value;\n    });\n  } else {\n    if (!Array.isArray(headers)) {\n      headers = Object.entries(headers);\n    }\n\n    for (const [key, value] of headers) {\n      if (value != null) {\n        normalized[key.toLowerCase()] = value;\n      }\n    }\n  }\n\n  return normalized;\n}\n", "import { normalizeHeaders } from './normalize-headers';\n\n/**\n * Appends suffix parts to the `user-agent` header.\n * If a `user-agent` header already exists, the suffix parts are appended to it.\n * If no `user-agent` header exists, a new one is created with the suffix parts.\n * Automatically removes undefined entries from the headers.\n *\n * @param headers - The original headers.\n * @param userAgentSuffixParts - The parts to append to the `user-agent` header.\n * @returns The new headers with the `user-agent` header set or updated.\n */\nexport function withUserAgentSuffix(\n  headers: HeadersInit | Record<string, string | undefined> | undefined,\n  ...userAgentSuffixParts: string[]\n): Record<string, string> {\n  const normalizedHeaders = new Headers(normalizeHeaders(headers));\n\n  const currentUserAgentHeader = normalizedHeaders.get('user-agent') || '';\n\n  normalizedHeaders.set(\n    'user-agent',\n    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(' '),\n  );\n\n  return Object.fromEntries(normalizedHeaders.entries());\n}\n", "// Version string of this package injected at build time.\ndeclare const __PACKAGE_VERSION__: string | undefined;\nexport const VERSION: string =\n  typeof __PACKAGE_VERSION__ !== 'undefined'\n    ? __PACKAGE_VERSION__\n    : '0.0.0-test';\n", "import {\n  JSONSchema7,\n  LanguageModelV2Message,\n  LanguageModelV2Prompt,\n} from '@ai-sdk/provider';\n\nconst DEFAULT_SCHEMA_PREFIX = 'JSON schema:';\nconst DEFAULT_SCHEMA_SUFFIX =\n  'You MUST answer with a JSON object that matches the JSON schema above.';\nconst DEFAULT_GENERIC_SUFFIX = 'You MUST answer with JSON.';\n\nexport function injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : undefined,\n  schemaSuffix = schema != null\n    ? DEFAULT_SCHEMA_SUFFIX\n    : DEFAULT_GENERIC_SUFFIX,\n}: {\n  prompt?: string;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): string {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : undefined,\n    prompt != null && prompt.length > 0 ? '' : undefined, // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : undefined,\n    schemaSuffix,\n  ]\n    .filter(line => line != null)\n    .join('\\n');\n}\n\nexport function injectJsonInstructionIntoMessages({\n  messages,\n  schema,\n  schemaPrefix,\n  schemaSuffix,\n}: {\n  messages: LanguageModelV2Prompt;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): LanguageModelV2Prompt {\n  const systemMessage: LanguageModelV2Message =\n    messages[0]?.role === 'system'\n      ? { ...messages[0] }\n      : { role: 'system', content: '' };\n\n  systemMessage.content = injectJsonInstruction({\n    prompt: systemMessage.content,\n    schema,\n    schemaPrefix,\n    schemaSuffix,\n  });\n\n  return [\n    systemMessage,\n    ...(messages[0]?.role === 'system' ? messages.slice(1) : messages),\n  ];\n}\n", "/**\n * Checks if the given URL is supported natively by the model.\n *\n * @param mediaType - The media type of the URL. Case-sensitive.\n * @param url - The URL to check.\n * @param supportedUrls - A record where keys are case-sensitive media types (or '*')\n *                        and values are arrays of RegExp patterns for URLs.\n *\n * @returns `true` if the URL matches a pattern under the specific media type\n *          or the wildcard '*', `false` otherwise.\n */\nexport function isUrlSupported({\n  mediaType,\n  url,\n  supportedUrls,\n}: {\n  mediaType: string;\n  url: string;\n  supportedUrls: Record<string, RegExp[]>;\n}): boolean {\n  // standardize media type and url to lower case\n  url = url.toLowerCase();\n  mediaType = mediaType.toLowerCase();\n\n  return (\n    Object.entries(supportedUrls)\n      // standardize supported url map into lowercase prefixes:\n      .map(([key, value]) => {\n        const mediaType = key.toLowerCase();\n        return mediaType === '*' || mediaType === '*/*'\n          ? { mediaTypePrefix: '', regexes: value }\n          : { mediaTypePrefix: mediaType.replace(/\\*/, ''), regexes: value };\n      })\n      // gather all regexp pattern from matched media type prefixes:\n      .filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix))\n      .flatMap(({ regexes }) => regexes)\n      // check if any pattern matches the url:\n      .some(pattern => pattern.test(url))\n  );\n}\n", "import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n", "/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n", "import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n", "/**\n * Maps a media type to its corresponding file extension.\n * It was originally introduced to set a filename for audio file uploads\n * in https://github.com/vercel/ai/pull/8159.\n *\n * @param mediaType The media type to map.\n * @returns The corresponding file extension\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/MIME_types/Common_types\n */\nexport function mediaTypeToExtension(mediaType: string) {\n  const [_type, subtype = ''] = mediaType.toLowerCase().split('/');\n\n  return (\n    {\n      mpeg: 'mp3',\n      'x-wav': 'wav',\n      opus: 'ogg',\n      mp4: 'm4a',\n      'x-m4a': 'm4a',\n    }[subtype] ?? subtype\n  );\n}\n", "import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport { secureJsonParse } from './secure-json-parse';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { FlexibleValidator, Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport async function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): Promise<JSONValue>;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {Promise<T>} - The parsed object.\n */\nexport async function parseJSON<T>(options: {\n  text: string;\n  schema: FlexibleValidator<T>;\n}): Promise<T>;\nexport async function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: FlexibleValidator<T>;\n}): Promise<T> {\n  try {\n    const value = secureJsonParse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes<T>({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | {\n      success: false;\n      error: JSONParseError | TypeValidationError;\n      rawValue: unknown;\n    };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {Promise<object>} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport async function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): Promise<ParseResult<JSONValue>>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport async function safeParseJSON<T>(options: {\n  text: string;\n  schema: FlexibleValidator<T>;\n}): Promise<ParseResult<T>>;\nexport async function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: FlexibleValidator<T>;\n}): Promise<ParseResult<T>> {\n  try {\n    const value = secureJsonParse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    return await safeValidateTypes<T>({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n      rawValue: undefined,\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n", "// Licensed under BSD-3-Clause (this file only)\n// Code adapted from https://github.com/fastify/secure-json-parse/blob/783fcb1b5434709466759847cec974381939673a/index.js\n//\n// Copyright (c) Vercel, Inc. (https://vercel.com)\n// Copyright (c) 2019 The Fastify Team\n// Copyright (c) 2019, Sideway Inc, and project contributors\n// All rights reserved.\n//\n// The complete list of contributors can be found at:\n// - https://github.com/hapijs/bourne/graphs/contributors\n// - https://github.com/fastify/secure-json-parse/graphs/contributors\n// - https://github.com/vercel/ai/commits/main/packages/provider-utils/src/secure-parse-json.ts\n//\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nconst suspectProtoRx = /\"__proto__\"\\s*:/;\nconst suspectConstructorRx = /\"constructor\"\\s*:/;\n\nfunction _parse(text: string) {\n  // Parse normally\n  const obj = JSON.parse(text);\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (\n    suspectProtoRx.test(text) === false &&\n    suspectConstructorRx.test(text) === false\n  ) {\n    return obj;\n  }\n\n  // Scan result for proto keys\n  return filter(obj);\n}\n\nfunction filter(obj: any) {\n  let next = [obj];\n\n  while (next.length) {\n    const nodes = next;\n    next = [];\n\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {\n        throw new SyntaxError('Object contains forbidden prototype property');\n      }\n\n      if (\n        Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n        Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')\n      ) {\n        throw new SyntaxError('Object contains forbidden prototype property');\n      }\n\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === 'object') {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\n\nexport function secureJsonParse(text: string) {\n  const { stackTraceLimit } = Error;\n  try {\n    // Performance optimization, see https://github.com/fastify/secure-json-parse/pull/90\n    Error.stackTraceLimit = 0;\n  } catch (e) {\n    // Fallback in case Error is immutable (v8 readonly)\n    return _parse(text);\n  }\n\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\n", "import { TypeValidationError } from '@ai-sdk/provider';\nimport { FlexibleValidator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {Promise<T>} - The typed object.\n */\nexport async function validateTypes<OBJECT>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: FlexibleValidator<OBJECT>;\n}): Promise<OBJECT> {\n  const result = await safeValidateTypes({ value, schema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport async function safeValidateTypes<OBJECT>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: FlexibleValidator<OBJECT>;\n}): Promise<\n  | {\n      success: true;\n      value: OBJECT;\n      rawValue: unknown;\n    }\n  | {\n      success: false;\n      error: TypeValidationError;\n      rawValue: unknown;\n    }\n> {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as OBJECT, rawValue: value };\n    }\n\n    const result = await validator.validate(value);\n\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n      rawValue: value,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n      rawValue: value,\n    };\n  }\n}\n", "import { TypeValidationError } from '@ai-sdk/provider';\nimport { StandardSchemaV1 } from '@standard-schema/spec';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (\n    value: unknown,\n  ) => ValidationResult<OBJECT> | PromiseLike<ValidationResult<OBJECT>>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?:\n    | undefined\n    | ((\n        value: unknown,\n      ) => ValidationResult<OBJECT> | PromiseLike<ValidationResult<OBJECT>>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\n/**\n * Creates a validator with deferred creation.\n * This is important to reduce the startup time of the library\n * and to avoid initializing unused validators.\n *\n * @param createValidator A function that creates a validator.\n * @returns A function that returns a validator.\n */\nexport function lazyValidator<OBJECT>(\n  createValidator: () => Validator<OBJECT>,\n): LazyValidator<OBJECT> {\n  // cache the validator to avoid initializing it multiple times\n  let validator: Validator<OBJECT> | undefined;\n  return () => {\n    if (validator == null) {\n      validator = createValidator();\n    }\n    return validator;\n  };\n}\n\nexport type LazyValidator<OBJECT> = () => Validator<OBJECT>;\n\nexport type FlexibleValidator<OBJECT> =\n  | Validator<OBJECT>\n  | LazyValidator<OBJECT>\n  | StandardSchemaV1<unknown, OBJECT>;\n\nexport type InferValidator<SCHEMA> =\n  SCHEMA extends StandardSchemaV1<unknown, infer T>\n    ? T\n    : SCHEMA extends LazyValidator<infer T>\n      ? T\n      : SCHEMA extends Validator<infer T>\n        ? T\n        : never;\n\nexport function asValidator<OBJECT>(\n  value: FlexibleValidator<OBJECT>,\n): Validator<OBJECT> {\n  return isValidator(value)\n    ? value\n    : typeof value === 'function'\n      ? value()\n      : standardSchemaValidator(value);\n}\n\nexport function standardSchemaValidator<OBJECT>(\n  standardSchema: StandardSchemaV1<unknown, OBJECT>,\n): Validator<OBJECT> {\n  return validator(async value => {\n    const result = await standardSchema['~standard'].validate(value);\n\n    return result.issues == null\n      ? { success: true, value: result.value }\n      : {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: result.issues,\n          }),\n        };\n  });\n}\n", "import {\n  EventSourceMessage,\n  EventSourceParserStream,\n} from 'eventsource-parser/stream';\nimport { ParseResult, safeParseJSON } from './parse-json';\nimport { FlexibleValidator } from './validator';\n\n/**\n * Parses a JSON event stream into a stream of parsed JSON objects.\n */\nexport function parseJsonEventStream<T>({\n  stream,\n  schema,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  schema: FlexibleValidator<T>;\n}): ReadableStream<ParseResult<T>> {\n  return stream\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(new EventSourceParserStream())\n    .pipeThrough(\n      new TransformStream<EventSourceMessage, ParseResult<T>>({\n        async transform({ data }, controller) {\n          // ignore the 'DONE' event that e.g. OpenAI sends:\n          if (data === '[DONE]') {\n            return;\n          }\n\n          controller.enqueue(await safeParseJSON({ text: data, schema }));\n        },\n      }),\n    );\n}\n", "import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { FlexibleValidator } from './validator';\n\nexport async function parseProviderOptions<OPTIONS>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: FlexibleValidator<OPTIONS>;\n}): Promise<OPTIONS | undefined> {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = await safeValidateTypes<OPTIONS | undefined>({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { handleFetchError } from './handle-fetch-error';\nimport { isAbortError } from './is-abort-error';\nimport { ResponseHandler } from './response-handler';\nimport { getRuntimeEnvironmentUserAgent } from './get-runtime-environment-user-agent';\nimport { withUserAgentSuffix } from './with-user-agent-suffix';\nimport { VERSION } from './version';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent(),\n      ),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: body.values });\n  }\n};\n", "import { JSONValue, LanguageModelV2ToolResultPart } from '@ai-sdk/provider';\nimport { FlexibleSchema } from '../schema';\nimport { ModelMessage } from './model-message';\nimport { ProviderOptions } from './provider-options';\n\n/**\n * Additional options that are sent into each tool call.\n */\n// TODO AI SDK 6: rename to ToolExecutionOptions\nexport interface ToolCallOptions {\n  /**\n   * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.\n   */\n  toolCallId: string;\n\n  /**\n   * Messages that were sent to the language model to initiate the response that contained the tool call.\n   * The messages **do not** include the system prompt nor the assistant response that contained the tool call.\n   */\n  messages: ModelMessage[];\n\n  /**\n   * An optional abort signal that indicates that the overall operation should be aborted.\n   */\n  abortSignal?: AbortSignal;\n\n  /**\n   * Additional context.\n   *\n   * Experimental (can break in patch releases).\n   */\n  experimental_context?: unknown;\n}\n\nexport type ToolExecuteFunction<INPUT, OUTPUT> = (\n  input: INPUT,\n  options: ToolCallOptions,\n) => AsyncIterable<OUTPUT> | PromiseLike<OUTPUT> | OUTPUT;\n\n// 0 extends 1 & N checks for any\n// [N] extends [never] checks for never\ntype NeverOptional<N, T> = 0 extends 1 & N\n  ? Partial<T>\n  : [N] extends [never]\n    ? Partial<Record<keyof T, undefined>>\n    : T;\n\ntype ToolOutputProperties<INPUT, OUTPUT> = NeverOptional<\n  OUTPUT,\n  | {\n      /**\nAn async function that is called with the arguments from the tool call and produces a result.\nIf not provided, the tool will not be executed automatically.\n\n@args is the input of the tool call.\n@options.abortSignal is a signal that can be used to abort the tool call.\n    */\n      execute: ToolExecuteFunction<INPUT, OUTPUT>;\n\n      outputSchema?: FlexibleSchema<OUTPUT>;\n    }\n  | {\n      outputSchema: FlexibleSchema<OUTPUT>;\n\n      execute?: never;\n    }\n>;\n\n/**\nA tool contains the description and the schema of the input that the tool expects.\nThis enables the language model to generate the input.\n\nThe tool can also contain an optional execute function for the actual execution function of the tool.\n */\nexport type Tool<\n  INPUT extends JSONValue | unknown | never = any,\n  OUTPUT extends JSONValue | unknown | never = any,\n> = {\n  /**\nAn optional description of what the tool does.\nWill be used by the language model to decide whether to use the tool.\nNot used for provider-defined tools.\n   */\n  description?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n   */\n  providerOptions?: ProviderOptions;\n\n  /**\nThe schema of the input that the tool expects. The language model will use this to generate the input.\nIt is also used to validate the output of the language model.\nUse descriptions to make the input understandable for the language model.\n   */\n  inputSchema: FlexibleSchema<INPUT>;\n\n  /**\n   * Optional function that is called when the argument streaming starts.\n   * Only called when the tool is used in a streaming context.\n   */\n  onInputStart?: (options: ToolCallOptions) => void | PromiseLike<void>;\n\n  /**\n   * Optional function that is called when an argument streaming delta is available.\n   * Only called when the tool is used in a streaming context.\n   */\n  onInputDelta?: (\n    options: { inputTextDelta: string } & ToolCallOptions,\n  ) => void | PromiseLike<void>;\n\n  /**\n   * Optional function that is called when a tool call can be started,\n   * even if the execute function is not provided.\n   */\n  onInputAvailable?: (\n    options: {\n      input: [INPUT] extends [never] ? undefined : INPUT;\n    } & ToolCallOptions,\n  ) => void | PromiseLike<void>;\n} & ToolOutputProperties<INPUT, OUTPUT> & {\n    /**\nOptional conversion function that maps the tool result to an output that can be used by the language model.\n\nIf not provided, the tool result will be sent as a JSON object.\n  */\n    toModelOutput?: (\n      output: 0 extends 1 & OUTPUT\n        ? any\n        : [OUTPUT] extends [never]\n          ? any\n          : NoInfer<OUTPUT>,\n    ) => LanguageModelV2ToolResultPart['output'];\n  } & (\n    | {\n        /**\nTool with user-defined input and output schemas.\n     */\n        type?: undefined | 'function';\n      }\n    | {\n        /**\nTool that is defined at runtime (e.g. an MCP tool).\nThe types of input and output are not known at development time.\n       */\n        type: 'dynamic';\n      }\n    | {\n        /**\nTool with provider-defined input and output schemas.\n     */\n        type: 'provider-defined';\n\n        /**\nThe ID of the tool. Should follow the format `<provider-name>.<unique-tool-name>`.\n   */\n        id: `${string}.${string}`;\n\n        /**\nThe name of the tool that the user must use in the tool set.\n */\n        name: string;\n\n        /**\nThe arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.\n     */\n        args: Record<string, unknown>;\n      }\n  );\n\n/**\n * Infer the input type of a tool.\n */\nexport type InferToolInput<TOOL extends Tool> =\n  TOOL extends Tool<infer INPUT, any> ? INPUT : never;\n\n/**\n * Infer the output type of a tool.\n */\nexport type InferToolOutput<TOOL extends Tool> =\n  TOOL extends Tool<any, infer OUTPUT> ? OUTPUT : never;\n\n/**\nHelper function for inferring the execute args of a tool.\n */\n// Note: overload order is important for auto-completion\nexport function tool<INPUT, OUTPUT>(\n  tool: Tool<INPUT, OUTPUT>,\n): Tool<INPUT, OUTPUT>;\nexport function tool<INPUT>(tool: Tool<INPUT, never>): Tool<INPUT, never>;\nexport function tool<OUTPUT>(tool: Tool<never, OUTPUT>): Tool<never, OUTPUT>;\nexport function tool(tool: Tool<never, never>): Tool<never, never>;\nexport function tool(tool: any): any {\n  return tool;\n}\n\n/**\nHelper function for defining a dynamic tool.\n */\nexport function dynamicTool(tool: {\n  description?: string;\n  providerOptions?: ProviderOptions;\n  inputSchema: FlexibleSchema<unknown>;\n  execute: ToolExecuteFunction<unknown, unknown>;\n  toModelOutput?: (output: unknown) => LanguageModelV2ToolResultPart['output'];\n}): Tool<unknown, unknown> & {\n  type: 'dynamic';\n} {\n  return { ...tool, type: 'dynamic' };\n}\n", "import { tool, Tool, ToolExecuteFunction } from './types/tool';\nimport { FlexibleSchema } from './schema';\n\nexport type ProviderDefinedToolFactory<INPUT, ARGS extends object> = <OUTPUT>(\n  options: ARGS & {\n    execute?: ToolExecuteFunction<INPUT, OUTPUT>;\n    toModelOutput?: Tool<INPUT, OUTPUT>['toModelOutput'];\n    onInputStart?: Tool<INPUT, OUTPUT>['onInputStart'];\n    onInputDelta?: Tool<INPUT, OUTPUT>['onInputDelta'];\n    onInputAvailable?: Tool<INPUT, OUTPUT>['onInputAvailable'];\n  },\n) => Tool<INPUT, OUTPUT>;\n\nexport function createProviderDefinedToolFactory<INPUT, ARGS extends object>({\n  id,\n  name,\n  inputSchema,\n}: {\n  id: `${string}.${string}`;\n  name: string;\n  inputSchema: FlexibleSchema<INPUT>;\n}): ProviderDefinedToolFactory<INPUT, ARGS> {\n  return <OUTPUT>({\n    execute,\n    outputSchema,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }: ARGS & {\n    execute?: ToolExecuteFunction<INPUT, OUTPUT>;\n    outputSchema?: FlexibleSchema<OUTPUT>;\n    toModelOutput?: Tool<INPUT, OUTPUT>['toModelOutput'];\n    onInputStart?: Tool<INPUT, OUTPUT>['onInputStart'];\n    onInputDelta?: Tool<INPUT, OUTPUT>['onInputDelta'];\n    onInputAvailable?: Tool<INPUT, OUTPUT>['onInputAvailable'];\n  }): Tool<INPUT, OUTPUT> =>\n    tool({\n      type: 'provider-defined',\n      id,\n      name,\n      args,\n      inputSchema,\n      outputSchema,\n      execute,\n      toModelOutput,\n      onInputStart,\n      onInputDelta,\n      onInputAvailable,\n    });\n}\n\nexport type ProviderDefinedToolFactoryWithOutputSchema<\n  INPUT,\n  OUTPUT,\n  ARGS extends object,\n> = (\n  options: ARGS & {\n    execute?: ToolExecuteFunction<INPUT, OUTPUT>;\n    toModelOutput?: Tool<INPUT, OUTPUT>['toModelOutput'];\n    onInputStart?: Tool<INPUT, OUTPUT>['onInputStart'];\n    onInputDelta?: Tool<INPUT, OUTPUT>['onInputDelta'];\n    onInputAvailable?: Tool<INPUT, OUTPUT>['onInputAvailable'];\n  },\n) => Tool<INPUT, OUTPUT>;\n\nexport function createProviderDefinedToolFactoryWithOutputSchema<\n  INPUT,\n  OUTPUT,\n  ARGS extends object,\n>({\n  id,\n  name,\n  inputSchema,\n  outputSchema,\n}: {\n  id: `${string}.${string}`;\n  name: string;\n  inputSchema: FlexibleSchema<INPUT>;\n  outputSchema: FlexibleSchema<OUTPUT>;\n}): ProviderDefinedToolFactoryWithOutputSchema<INPUT, OUTPUT, ARGS> {\n  return ({\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }: ARGS & {\n    execute?: ToolExecuteFunction<INPUT, OUTPUT>;\n    toModelOutput?: Tool<INPUT, OUTPUT>['toModelOutput'];\n    onInputStart?: Tool<INPUT, OUTPUT>['onInputStart'];\n    onInputDelta?: Tool<INPUT, OUTPUT>['onInputDelta'];\n    onInputAvailable?: Tool<INPUT, OUTPUT>['onInputAvailable'];\n  }): Tool<INPUT, OUTPUT> =>\n    tool({\n      type: 'provider-defined',\n      id,\n      name,\n      args,\n      inputSchema,\n      outputSchema,\n      execute,\n      toModelOutput,\n      onInputStart,\n      onInputDelta,\n      onInputAvailable,\n    });\n}\n", "/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n", "export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n", "import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodType } from 'zod/v4';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\nimport { parseJsonEventStream } from './parse-json-event-stream';\nimport { FlexibleValidator } from './validator';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: FlexibleValidator<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = await parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: FlexibleValidator<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: parseJsonEventStream({\n        stream: response.body,\n        schema: chunkSchema,\n      }),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodType<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          async transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                await safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: FlexibleValidator<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = await safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n", "import { JSONSchema7 } from '@ai-sdk/provider';\nimport * as z3 from 'zod/v3';\nimport * as z4 from 'zod/v4';\nimport zodToJsonSchema from './zod-to-json-schema';\nimport { jsonSchema, Schema } from './schema';\n\nexport function zod3Schema<OBJECT>(\n  zodSchema: z3.Schema<OBJECT, z3.ZodTypeDef, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  // default to no references (to support openapi conversion for google)\n  const useReferences = options?.useReferences ?? false;\n\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () =>\n      zodToJsonSchema(zodSchema, {\n        $refStrategy: useReferences ? 'root' : 'none',\n      }) as JSONSchema7,\n    {\n      validate: async value => {\n        const result = await zodSchema.safeParseAsync(value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n\nexport function zod4Schema<OBJECT>(\n  zodSchema: z4.core.$ZodType<OBJECT, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  // default to no references (to support openapi conversion for google)\n  const useReferences = options?.useReferences ?? false;\n\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () =>\n      z4.toJSONSchema(zodSchema, {\n        target: 'draft-7',\n        io: 'output',\n        reused: useReferences ? 'ref' : 'inline',\n      }) as JSONSchema7,\n    {\n      validate: async value => {\n        const result = await z4.safeParseAsync(zodSchema, value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n\nexport function isZod4Schema(\n  zodSchema: z4.core.$ZodType<any, any> | z3.Schema<any, z3.ZodTypeDef, any>,\n): zodSchema is z4.core.$ZodType<any, any> {\n  // https://zod.dev/library-authors?id=how-to-support-zod-3-and-zod-4-simultaneously\n  return '_zod' in zodSchema;\n}\n\nexport function zodSchema<OBJECT>(\n  zodSchema:\n    | z4.core.$ZodType<OBJECT, any>\n    | z3.Schema<OBJECT, z3.ZodTypeDef, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  if (isZod4Schema(zodSchema)) {\n    return zod4Schema(zodSchema, options);\n  } else {\n    return zod3Schema(zodSchema, options);\n  }\n}\n", "export const getRelativePath = (pathA: string[], pathB: string[]) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join('/');\n};\n", "import { ZodSchema, ZodTypeDef } from 'zod/v3';\nimport { Refs, Seen } from './refs';\nimport { JsonSchema7Type } from './parse-types';\n\nexport type DateStrategy =\n  | 'format:date-time'\n  | 'format:date'\n  | 'string'\n  | 'integer';\n\nexport const ignoreOverride = Symbol(\n  'Let zodToJsonSchema decide on which parser to use',\n);\n\nexport type OverrideCallback = (\n  def: ZodTypeDef,\n  refs: Refs,\n  seen: Seen | undefined,\n  forceResolution?: boolean,\n) => JsonSchema7Type | undefined | typeof ignoreOverride;\n\nexport type PostProcessCallback = (\n  jsonSchema: JsonSchema7Type | undefined,\n  def: ZodTypeDef,\n  refs: Refs,\n) => JsonSchema7Type | undefined;\n\nexport const jsonDescription: PostProcessCallback = (jsonSchema, def) => {\n  if (def.description) {\n    try {\n      return {\n        ...jsonSchema,\n        ...JSON.parse(def.description),\n      };\n    } catch {}\n  }\n\n  return jsonSchema;\n};\n\nexport type Options = {\n  name: string | undefined;\n  $refStrategy: 'root' | 'relative' | 'none' | 'seen';\n  basePath: string[];\n  effectStrategy: 'input' | 'any';\n  pipeStrategy: 'input' | 'output' | 'all';\n  dateStrategy: DateStrategy | DateStrategy[];\n  mapStrategy: 'entries' | 'record';\n  removeAdditionalStrategy: 'passthrough' | 'strict';\n  allowedAdditionalProperties: true | undefined;\n  rejectedAdditionalProperties: false | undefined;\n  strictUnions: boolean;\n  definitionPath: string;\n  definitions: Record<string, ZodSchema>;\n  errorMessages: boolean;\n  patternStrategy: 'escape' | 'preserve';\n  applyRegexFlags: boolean;\n  emailStrategy: 'format:email' | 'format:idn-email' | 'pattern:zod';\n  base64Strategy: 'format:binary' | 'contentEncoding:base64' | 'pattern:zod';\n  nameStrategy: 'ref' | 'title';\n  override?: OverrideCallback;\n  postProcess?: PostProcessCallback;\n};\n\nexport const defaultOptions: Options = {\n  name: undefined,\n  $refStrategy: 'root',\n  basePath: ['#'],\n  effectStrategy: 'input',\n  pipeStrategy: 'all',\n  dateStrategy: 'format:date-time',\n  mapStrategy: 'entries',\n  removeAdditionalStrategy: 'passthrough',\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: 'definitions',\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  patternStrategy: 'escape',\n  applyRegexFlags: false,\n  emailStrategy: 'format:email',\n  base64Strategy: 'contentEncoding:base64',\n  nameStrategy: 'ref',\n};\n\nexport const getDefaultOptions = (\n  options: Partial<Options> | string | undefined,\n) =>\n  (typeof options === 'string'\n    ? {\n        ...defaultOptions,\n        name: options,\n      }\n    : {\n        ...defaultOptions,\n        ...options,\n      }) as Options;\n", "import { ZodFirstPartyTypeKind } from 'zod/v3';\nimport { parseAnyDef } from './parsers/any';\nimport { parseArrayDef } from './parsers/array';\nimport { parseBigintDef } from './parsers/bigint';\nimport { parseBooleanDef } from './parsers/boolean';\nimport { parseBrandedDef } from './parsers/branded';\nimport { parseCatchDef } from './parsers/catch';\nimport { parseDateDef } from './parsers/date';\nimport { parseDefaultDef } from './parsers/default';\nimport { parseEffectsDef } from './parsers/effects';\nimport { parseEnumDef } from './parsers/enum';\nimport { parseIntersectionDef } from './parsers/intersection';\nimport { parseLiteralDef } from './parsers/literal';\nimport { parseMapDef } from './parsers/map';\nimport { parseNativeEnumDef } from './parsers/native-enum';\nimport { parseNeverDef } from './parsers/never';\nimport { parseNullDef } from './parsers/null';\nimport { parseNullableDef } from './parsers/nullable';\nimport { parseNumberDef } from './parsers/number';\nimport { parseObjectDef } from './parsers/object';\nimport { parseOptionalDef } from './parsers/optional';\nimport { parsePipelineDef } from './parsers/pipeline';\nimport { parsePromiseDef } from './parsers/promise';\nimport { parseRecordDef } from './parsers/record';\nimport { parseSetDef } from './parsers/set';\nimport { parseStringDef } from './parsers/string';\nimport { parseTupleDef } from './parsers/tuple';\nimport { parseUndefinedDef } from './parsers/undefined';\nimport { parseUnionDef } from './parsers/union';\nimport { parseUnknownDef } from './parsers/unknown';\nimport { Refs } from './refs';\nimport { parseReadonlyDef } from './parsers/readonly';\nimport { JsonSchema7Type } from './parse-types';\n\nexport type InnerDefGetter = () => any;\n\nexport const selectParser = (\n  def: any,\n  typeName: ZodFirstPartyTypeKind,\n  refs: Refs,\n): JsonSchema7Type | undefined | InnerDefGetter => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef();\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return () => (def as any).getter()._def;\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return undefined;\n    default:\n      /* c8 ignore next */\n      return ((_: never) => undefined)(typeName);\n  }\n};\n", "export type JsonSchema7AnyType = { $ref?: string };\n\nexport function parseAnyDef(): JsonSchema7AnyType {\n  return {};\n}\n", "import { ZodArrayDef, ZodFirstPartyTypeKind } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport type JsonSchema7ArrayType = {\n  type: 'array';\n  items?: JsonSchema7Type;\n  minItems?: number;\n  maxItems?: number;\n};\n\nexport function parseArrayDef(def: ZodArrayDef, refs: Refs) {\n  const res: JsonSchema7ArrayType = {\n    type: 'array',\n  };\n  if (\n    def.type?._def &&\n    def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny\n  ) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'items'],\n    });\n  }\n\n  if (def.minLength) {\n    res.minItems = def.minLength.value;\n  }\n  if (def.maxLength) {\n    res.maxItems = def.maxLength.value;\n  }\n  if (def.exactLength) {\n    res.minItems = def.exactLength.value;\n    res.maxItems = def.exactLength.value;\n  }\n  return res;\n}\n", "import { ZodBigIntDef } from 'zod/v3';\n\nexport type JsonSchema7BigintType = {\n  type: 'integer';\n  format: 'int64';\n  minimum?: BigInt;\n  exclusiveMinimum?: BigInt;\n  maximum?: BigInt;\n  exclusiveMaximum?: BigInt;\n  multipleOf?: BigInt;\n};\n\nexport function parseBigintDef(def: ZodBigIntDef): JsonSchema7BigintType {\n  const res: JsonSchema7BigintType = {\n    type: 'integer',\n    format: 'int64',\n  };\n\n  if (!def.checks) return res;\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case 'min':\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case 'max':\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n\n        break;\n      case 'multipleOf':\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n", "export type JsonSchema7BooleanType = {\n  type: 'boolean';\n};\n\nexport function parseBooleanDef(): JsonSchema7BooleanType {\n  return { type: 'boolean' };\n}\n", "import { ZodBrandedDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { Refs } from '../refs';\n\nexport function parseBrandedDef(_def: ZodBrandedDef<any>, refs: Refs) {\n  return parseDef(_def.type._def, refs);\n}\n", "import { ZodCatchDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { Refs } from '../refs';\n\nexport const parseCatchDef = (def: ZodCatchDef<any>, refs: Refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n", "import { ZodDateDef } from 'zod/v3';\nimport { Refs } from '../refs';\nimport { DateStrategy } from '../options';\n\nexport type JsonSchema7DateType =\n  | {\n      type: 'integer' | 'string';\n      format: 'unix-time' | 'date-time' | 'date';\n      minimum?: number;\n      maximum?: number;\n    }\n  | {\n      anyOf: JsonSchema7DateType[];\n    };\n\nexport function parseDateDef(\n  def: ZodDateDef,\n  refs: Refs,\n  overrideDateStrategy?: DateStrategy,\n): JsonSchema7DateType {\n  const strategy = overrideDateStrategy ?? refs.dateStrategy;\n\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n    };\n  }\n\n  switch (strategy) {\n    case 'string':\n    case 'format:date-time':\n      return {\n        type: 'string',\n        format: 'date-time',\n      };\n    case 'format:date':\n      return {\n        type: 'string',\n        format: 'date',\n      };\n    case 'integer':\n      return integerDateParser(def);\n  }\n}\n\nconst integerDateParser = (def: ZodDateDef) => {\n  const res: JsonSchema7DateType = {\n    type: 'integer',\n    format: 'unix-time',\n  };\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case 'min':\n        res.minimum = check.value;\n        break;\n      case 'max':\n        res.maximum = check.value;\n        break;\n    }\n  }\n\n  return res;\n};\n", "import { ZodDefaultDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport function parseDefaultDef(\n  _def: ZodDefaultDef,\n  refs: Refs,\n): JsonSchema7Type & { default: any } {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue(),\n  };\n}\n", "import { ZodEffectsDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { parseAnyDef } from './any';\n\nexport function parseEffectsDef(\n  _def: ZodEffectsDef,\n  refs: Refs,\n): JsonSchema7Type | undefined {\n  return refs.effectStrategy === 'input'\n    ? parseDef(_def.schema._def, refs)\n    : parseAnyDef();\n}\n", "import { ZodEnumDef } from 'zod/v3';\n\nexport type JsonSchema7EnumType = {\n  type: 'string';\n  enum: string[];\n};\n\nexport function parseEnumDef(def: ZodEnumDef): JsonSchema7EnumType {\n  return {\n    type: 'string',\n    enum: Array.from(def.values),\n  };\n}\n", "import { ZodIntersectionDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { JsonSchema7StringType } from './string';\n\nexport type JsonSchema7AllOfType = {\n  allOf: JsonSchema7Type[];\n  unevaluatedProperties?: boolean;\n};\n\nconst isJsonSchema7AllOfType = (\n  type: JsonSchema7Type | JsonSchema7StringType,\n): type is JsonSchema7AllOfType => {\n  if ('type' in type && type.type === 'string') return false;\n  return 'allOf' in type;\n};\n\nexport function parseIntersectionDef(\n  def: ZodIntersectionDef,\n  refs: Refs,\n): JsonSchema7AllOfType | JsonSchema7Type | undefined {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'allOf', '0'],\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'allOf', '1'],\n    }),\n  ].filter((x): x is JsonSchema7Type => !!x);\n\n  const mergedAllOf: JsonSchema7Type[] = [];\n  // If either of the schemas is an allOf, merge them into a single allOf\n  allOf.forEach(schema => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n    } else {\n      let nestedSchema: JsonSchema7Type = schema;\n      if (\n        'additionalProperties' in schema &&\n        schema.additionalProperties === false\n      ) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? { allOf: mergedAllOf } : undefined;\n}\n", "import { ZodLiteralDef } from 'zod/v3';\n\nexport type JsonSchema7LiteralType =\n  | {\n      type: 'string' | 'number' | 'integer' | 'boolean';\n      const: string | number | boolean;\n    }\n  | {\n      type: 'object' | 'array';\n    };\n\nexport function parseLiteralDef(def: ZodLiteralDef): JsonSchema7LiteralType {\n  const parsedType = typeof def.value;\n  if (\n    parsedType !== 'bigint' &&\n    parsedType !== 'number' &&\n    parsedType !== 'boolean' &&\n    parsedType !== 'string'\n  ) {\n    return {\n      type: Array.isArray(def.value) ? 'array' : 'object',\n    };\n  }\n\n  return {\n    type: parsedType === 'bigint' ? 'integer' : parsedType,\n    const: def.value,\n  };\n}\n", "import {\n  ZodFirstPartyTypeKind,\n  ZodMapDef,\n  ZodRecordDef,\n  ZodTypeAny,\n} from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { parseBrandedDef } from './branded';\nimport { JsonSchema7EnumType } from './enum';\nimport { JsonSchema7StringType, parseStringDef } from './string';\n\ntype JsonSchema7RecordPropertyNamesType =\n  | Omit<JsonSchema7StringType, 'type'>\n  | Omit<JsonSchema7EnumType, 'type'>;\n\nexport type JsonSchema7RecordType = {\n  type: 'object';\n  additionalProperties?: JsonSchema7Type | true;\n  propertyNames?: JsonSchema7RecordPropertyNamesType;\n};\n\nexport function parseRecordDef(\n  def: ZodRecordDef<ZodTypeAny, ZodTypeAny> | ZodMapDef,\n  refs: Refs,\n): JsonSchema7RecordType {\n  const schema: JsonSchema7RecordType = {\n    type: 'object',\n    additionalProperties:\n      parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, 'additionalProperties'],\n      }) ?? refs.allowedAdditionalProperties,\n  };\n\n  if (\n    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n    def.keyType._def.checks?.length\n  ) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n\n    return {\n      ...schema,\n      propertyNames: keyType,\n    };\n  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values,\n      },\n    };\n  } else if (\n    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n    def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n    def.keyType._def.type._def.checks?.length\n  ) {\n    const { type, ...keyType } = parseBrandedDef(\n      def.keyType._def,\n      refs,\n    ) as JsonSchema7StringType;\n\n    return {\n      ...schema,\n      propertyNames: keyType,\n    };\n  }\n\n  return schema;\n}\n", "import { ZodStringDef } from 'zod/v3';\nimport { Refs } from '../refs';\n\nlet emojiRegex: RegExp | undefined = undefined;\n\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email:\n    /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === undefined) {\n      emojiRegex = RegExp(\n        '^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$',\n        'u',\n      );\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr:\n    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr:\n    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url:\n    /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n} as const;\n\nexport type JsonSchema7StringType = {\n  type: 'string';\n  minLength?: number;\n  maxLength?: number;\n  format?:\n    | 'email'\n    | 'idn-email'\n    | 'uri'\n    | 'uuid'\n    | 'date-time'\n    | 'ipv4'\n    | 'ipv6'\n    | 'date'\n    | 'time'\n    | 'duration';\n  pattern?: string;\n  allOf?: {\n    pattern: string;\n  }[];\n  anyOf?: {\n    format: string;\n  }[];\n  contentEncoding?: string;\n};\n\nexport function parseStringDef(\n  def: ZodStringDef,\n  refs: Refs,\n): JsonSchema7StringType {\n  const res: JsonSchema7StringType = {\n    type: 'string',\n  };\n\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case 'min':\n          res.minLength =\n            typeof res.minLength === 'number'\n              ? Math.max(res.minLength, check.value)\n              : check.value;\n          break;\n        case 'max':\n          res.maxLength =\n            typeof res.maxLength === 'number'\n              ? Math.min(res.maxLength, check.value)\n              : check.value;\n\n          break;\n        case 'email':\n          switch (refs.emailStrategy) {\n            case 'format:email':\n              addFormat(res, 'email', check.message, refs);\n              break;\n            case 'format:idn-email':\n              addFormat(res, 'idn-email', check.message, refs);\n              break;\n            case 'pattern:zod':\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n\n          break;\n        case 'url':\n          addFormat(res, 'uri', check.message, refs);\n          break;\n        case 'uuid':\n          addFormat(res, 'uuid', check.message, refs);\n          break;\n        case 'regex':\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case 'cuid':\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case 'cuid2':\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case 'startsWith':\n          addPattern(\n            res,\n            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),\n            check.message,\n            refs,\n          );\n          break;\n        case 'endsWith':\n          addPattern(\n            res,\n            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),\n            check.message,\n            refs,\n          );\n          break;\n        case 'datetime':\n          addFormat(res, 'date-time', check.message, refs);\n          break;\n        case 'date':\n          addFormat(res, 'date', check.message, refs);\n          break;\n        case 'time':\n          addFormat(res, 'time', check.message, refs);\n          break;\n        case 'duration':\n          addFormat(res, 'duration', check.message, refs);\n          break;\n        case 'length':\n          res.minLength =\n            typeof res.minLength === 'number'\n              ? Math.max(res.minLength, check.value)\n              : check.value;\n          res.maxLength =\n            typeof res.maxLength === 'number'\n              ? Math.min(res.maxLength, check.value)\n              : check.value;\n          break;\n        case 'includes': {\n          addPattern(\n            res,\n            RegExp(escapeLiteralCheckValue(check.value, refs)),\n            check.message,\n            refs,\n          );\n          break;\n        }\n        case 'ip': {\n          if (check.version !== 'v6') {\n            addFormat(res, 'ipv4', check.message, refs);\n          }\n          if (check.version !== 'v4') {\n            addFormat(res, 'ipv6', check.message, refs);\n          }\n          break;\n        }\n        case 'base64url':\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case 'jwt':\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case 'cidr': {\n          if (check.version !== 'v6') {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== 'v4') {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case 'emoji':\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case 'ulid': {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case 'base64': {\n          switch (refs.base64Strategy) {\n            case 'format:binary': {\n              addFormat(res, 'binary' as any, check.message, refs);\n              break;\n            }\n\n            case 'contentEncoding:base64': {\n              res.contentEncoding = 'base64';\n              break;\n            }\n\n            case 'pattern:zod': {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case 'nanoid': {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n        }\n        case 'toLowerCase':\n        case 'toUpperCase':\n        case 'trim':\n          break;\n        default:\n          /* c8 ignore next */\n          ((_: never) => {})(check);\n      }\n    }\n  }\n\n  return res;\n}\n\nfunction escapeLiteralCheckValue(literal: string, refs: Refs): string {\n  return refs.patternStrategy === 'escape'\n    ? escapeNonAlphaNumeric(literal)\n    : literal;\n}\n\nconst ALPHA_NUMERIC = new Set(\n  'ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789',\n);\n\nfunction escapeNonAlphaNumeric(source: string) {\n  let result = '';\n\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += '\\\\';\n    }\n\n    result += source[i];\n  }\n\n  return result;\n}\n\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(\n  schema: JsonSchema7StringType,\n  value: Required<JsonSchema7StringType>['format'],\n  message: string | undefined,\n  refs: Refs,\n) {\n  if (schema.format || schema.anyOf?.some(x => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n\n    if (schema.format) {\n      schema.anyOf!.push({\n        format: schema.format,\n      });\n      delete schema.format;\n    }\n\n    schema.anyOf!.push({\n      format: value,\n      ...(message &&\n        refs.errorMessages && { errorMessage: { format: message } }),\n    });\n  } else {\n    schema.format = value;\n  }\n}\n\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(\n  schema: JsonSchema7StringType,\n  regex: RegExp,\n  message: string | undefined,\n  refs: Refs,\n) {\n  if (schema.pattern || schema.allOf?.some(x => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n\n    if (schema.pattern) {\n      schema.allOf!.push({\n        pattern: schema.pattern,\n      });\n      delete schema.pattern;\n    }\n\n    schema.allOf!.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...(message &&\n        refs.errorMessages && { errorMessage: { pattern: message } }),\n    });\n  } else {\n    schema.pattern = stringifyRegExpWithFlags(regex, refs);\n  }\n}\n\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex: RegExp, refs: Refs): string {\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n\n  // Currently handled flags\n  const flags = {\n    i: regex.flags.includes('i'), // Case-insensitive\n    m: regex.flags.includes('m'), // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes('s'), // `.` matches newlines\n  };\n\n  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = '';\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === '-' && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n\n    if (flags.m) {\n      if (source[i] === '^') {\n        pattern += `(^|(?<=[\\r\\n]))`;\n        continue;\n      } else if (source[i] === '$') {\n        pattern += `($|(?=[\\r\\n]))`;\n        continue;\n      }\n    }\n\n    if (flags.s && source[i] === '.') {\n      pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n      continue;\n    }\n\n    pattern += source[i];\n    if (source[i] === '\\\\') {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === ']') {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === '[') {\n      inCharGroup = true;\n    }\n  }\n\n  try {\n    new RegExp(pattern);\n  } catch {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        '/',\n      )} to a flag-independent form! Falling back to the flag-ignorant source`,\n    );\n    return regex.source;\n  }\n\n  return pattern;\n}\n", "import { ZodMapDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { parseAnyDef } from './any';\nimport { JsonSchema7RecordType, parseRecordDef } from './record';\n\nexport type JsonSchema7MapType = {\n  type: 'array';\n  maxItems: 125;\n  items: {\n    type: 'array';\n    items: [JsonSchema7Type, JsonSchema7Type];\n    minItems: 2;\n    maxItems: 2;\n  };\n};\n\nexport function parseMapDef(\n  def: ZodMapDef,\n  refs: Refs,\n): JsonSchema7MapType | JsonSchema7RecordType {\n  if (refs.mapStrategy === 'record') {\n    return parseRecordDef(def, refs);\n  }\n\n  const keys =\n    parseDef(def.keyType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'items', 'items', '0'],\n    }) || parseAnyDef();\n  const values =\n    parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'items', 'items', '1'],\n    }) || parseAnyDef();\n  return {\n    type: 'array',\n    maxItems: 125,\n    items: {\n      type: 'array',\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2,\n    },\n  };\n}\n", "import { ZodNativeEnumDef } from 'zod/v3';\n\nexport type JsonSchema7NativeEnumType = {\n  type: 'string' | 'number' | ['string', 'number'];\n  enum: (string | number)[];\n};\n\nexport function parseNativeEnumDef(\n  def: ZodNativeEnumDef,\n): JsonSchema7NativeEnumType {\n  const object = def.values;\n  const actualKeys = Object.keys(def.values).filter((key: string) => {\n    return typeof object[object[key]] !== 'number';\n  });\n\n  const actualValues = actualKeys.map((key: string) => object[key]);\n\n  const parsedTypes = Array.from(\n    new Set(actualValues.map((values: string | number) => typeof values)),\n  );\n\n  return {\n    type:\n      parsedTypes.length === 1\n        ? parsedTypes[0] === 'string'\n          ? 'string'\n          : 'number'\n        : ['string', 'number'],\n    enum: actualValues,\n  };\n}\n", "import { JsonSchema7AnyType, parseAnyDef } from './any';\n\nexport type JsonSchema7NeverType = {\n  not: JsonSchema7AnyType;\n};\n\nexport function parseNeverDef(): JsonSchema7NeverType | undefined {\n  return { not: parseAnyDef() };\n}\n", "export type JsonSchema7NullType = {\n  type: 'null';\n};\n\nexport function parseNullDef(): JsonSchema7NullType {\n  return {\n    type: 'null',\n  };\n}\n", "import {\n  ZodDiscriminatedUnionDef,\n  ZodLiteralDef,\n  ZodTypeAny,\n  ZodUnionDef,\n} from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport const primitiveMappings = {\n  ZodString: 'string',\n  ZodNumber: 'number',\n  ZodBigInt: 'integer',\n  ZodBoolean: 'boolean',\n  ZodNull: 'null',\n} as const;\ntype ZodPrimitive = keyof typeof primitiveMappings;\ntype JsonSchema7Primitive =\n  (typeof primitiveMappings)[keyof typeof primitiveMappings];\n\nexport type JsonSchema7UnionType =\n  | JsonSchema7PrimitiveUnionType\n  | JsonSchema7AnyOfType;\n\ntype JsonSchema7PrimitiveUnionType =\n  | {\n      type: JsonSchema7Primitive | JsonSchema7Primitive[];\n    }\n  | {\n      type: JsonSchema7Primitive | JsonSchema7Primitive[];\n      enum: (string | number | bigint | boolean | null)[];\n    };\n\ntype JsonSchema7AnyOfType = {\n  anyOf: JsonSchema7Type[];\n};\n\nexport function parseUnionDef(\n  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,\n  refs: Refs,\n): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined {\n  const options: readonly ZodTypeAny[] =\n    def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n\n  // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n  if (\n    options.every(\n      x =>\n        x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length),\n    )\n  ) {\n    // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n\n    const types = options.reduce((types: JsonSchema7Primitive[], x) => {\n      const type = primitiveMappings[x._def.typeName as ZodPrimitive]; //Can be safely casted due to row 43\n      return type && !types.includes(type) ? [...types, type] : types;\n    }, []);\n\n    return {\n      type: types.length > 1 ? types : types[0],\n    };\n  } else if (\n    options.every(x => x._def.typeName === 'ZodLiteral' && !x.description)\n  ) {\n    // all options literals\n\n    const types = options.reduce(\n      (acc: JsonSchema7Primitive[], x: { _def: ZodLiteralDef }) => {\n        const type = typeof x._def.value;\n        switch (type) {\n          case 'string':\n          case 'number':\n          case 'boolean':\n            return [...acc, type];\n          case 'bigint':\n            return [...acc, 'integer' as const];\n          case 'object':\n            if (x._def.value === null) return [...acc, 'null' as const];\n          case 'symbol':\n          case 'undefined':\n          case 'function':\n          default:\n            return acc;\n        }\n      },\n      [],\n    );\n\n    if (types.length === options.length) {\n      // all the literals are primitive, as far as null can be considered primitive\n\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce(\n          (acc, x) => {\n            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n          },\n          [] as (string | number | bigint | boolean | null)[],\n        ),\n      };\n    }\n  } else if (options.every(x => x._def.typeName === 'ZodEnum')) {\n    return {\n      type: 'string',\n      enum: options.reduce(\n        (acc: string[], x) => [\n          ...acc,\n          ...x._def.values.filter((x: string) => !acc.includes(x)),\n        ],\n        [],\n      ),\n    };\n  }\n\n  return asAnyOf(def, refs);\n}\n\nconst asAnyOf = (\n  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,\n  refs: Refs,\n): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined => {\n  const anyOf = (\n    (def.options instanceof Map\n      ? Array.from(def.options.values())\n      : def.options) as any[]\n  )\n    .map((x, i) =>\n      parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, 'anyOf', `${i}`],\n      }),\n    )\n    .filter(\n      (x): x is JsonSchema7Type =>\n        !!x &&\n        (!refs.strictUnions ||\n          (typeof x === 'object' && Object.keys(x).length > 0)),\n    );\n\n  return anyOf.length ? { anyOf } : undefined;\n};\n", "import { ZodNullableDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { JsonSchema7NullType } from './null';\nimport { primitiveMappings } from './union';\n\nexport type JsonSchema7NullableType =\n  | {\n      anyOf: [JsonSchema7Type, JsonSchema7NullType];\n    }\n  | {\n      type: [string, 'null'];\n    };\n\nexport function parseNullableDef(\n  def: ZodNullableDef,\n  refs: Refs,\n): JsonSchema7NullableType | undefined {\n  if (\n    ['ZodString', 'ZodNumber', 'ZodBigInt', 'ZodBoolean', 'ZodNull'].includes(\n      def.innerType._def.typeName,\n    ) &&\n    (!def.innerType._def.checks || !def.innerType._def.checks.length)\n  ) {\n    return {\n      type: [\n        primitiveMappings[\n          def.innerType._def.typeName as keyof typeof primitiveMappings\n        ],\n        'null',\n      ],\n    };\n  }\n\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'anyOf', '0'],\n  });\n\n  return base && { anyOf: [base, { type: 'null' }] };\n}\n", "import { ZodNumberDef } from 'zod/v3';\n\nexport type JsonSchema7NumberType = {\n  type: 'number' | 'integer';\n  minimum?: number;\n  exclusiveMinimum?: number;\n  maximum?: number;\n  exclusiveMaximum?: number;\n  multipleOf?: number;\n};\n\nexport function parseNumberDef(def: ZodNumberDef): JsonSchema7NumberType {\n  const res: JsonSchema7NumberType = {\n    type: 'number',\n  };\n\n  if (!def.checks) return res;\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case 'int':\n        res.type = 'integer';\n        break;\n      case 'min':\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case 'max':\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case 'multipleOf':\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n", "import { ZodObjectDef, ZodTypeAny } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport type JsonSchema7ObjectType = {\n  type: 'object';\n  properties: Record<string, JsonSchema7Type>;\n  additionalProperties?: boolean | JsonSchema7Type;\n  required?: string[];\n};\n\nexport function parseObjectDef(def: ZodObjectDef, refs: Refs) {\n  const result: JsonSchema7ObjectType = {\n    type: 'object',\n    properties: {},\n  };\n\n  const required: string[] = [];\n\n  const shape = def.shape();\n\n  for (const propName in shape) {\n    let propDef = shape[propName];\n\n    if (propDef === undefined || propDef._def === undefined) {\n      continue;\n    }\n\n    const propOptional = safeIsOptional(propDef);\n\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'properties', propName],\n      propertyPath: [...refs.currentPath, 'properties', propName],\n    });\n\n    if (parsedDef === undefined) {\n      continue;\n    }\n\n    result.properties[propName] = parsedDef;\n\n    if (!propOptional) {\n      required.push(propName);\n    }\n  }\n\n  if (required.length) {\n    result.required = required;\n  }\n\n  const additionalProperties = decideAdditionalProperties(def, refs);\n\n  if (additionalProperties !== undefined) {\n    result.additionalProperties = additionalProperties;\n  }\n\n  return result;\n}\n\nfunction decideAdditionalProperties(def: ZodObjectDef, refs: Refs) {\n  if (def.catchall._def.typeName !== 'ZodNever') {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'additionalProperties'],\n    });\n  }\n\n  switch (def.unknownKeys) {\n    case 'passthrough':\n      return refs.allowedAdditionalProperties;\n    case 'strict':\n      return refs.rejectedAdditionalProperties;\n    case 'strip':\n      return refs.removeAdditionalStrategy === 'strict'\n        ? refs.allowedAdditionalProperties\n        : refs.rejectedAdditionalProperties;\n  }\n}\n\nfunction safeIsOptional(schema: ZodTypeAny): boolean {\n  try {\n    return schema.isOptional();\n  } catch {\n    return true;\n  }\n}\n", "import { ZodOptionalDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { parseAnyDef } from './any';\n\nexport const parseOptionalDef = (\n  def: ZodOptionalDef,\n  refs: Refs,\n): JsonSchema7Type | undefined => {\n  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n    return parseDef(def.innerType._def, refs);\n  }\n\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'anyOf', '1'],\n  });\n\n  return innerSchema\n    ? { anyOf: [{ not: parseAnyDef() }, innerSchema] }\n    : parseAnyDef();\n};\n", "import { ZodPipelineDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\nimport { JsonSchema7AllOfType } from './intersection';\n\nexport const parsePipelineDef = (\n  def: ZodPipelineDef<any, any>,\n  refs: Refs,\n): JsonSchema7AllOfType | JsonSchema7Type | undefined => {\n  if (refs.pipeStrategy === 'input') {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === 'output') {\n    return parseDef(def.out._def, refs);\n  }\n\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'allOf', '0'],\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'allOf', a ? '1' : '0'],\n  });\n\n  return {\n    allOf: [a, b].filter((x): x is JsonSchema7Type => x !== undefined),\n  };\n};\n", "import { ZodPromiseDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport function parsePromiseDef(\n  def: ZodPromiseDef,\n  refs: Refs,\n): JsonSchema7Type | undefined {\n  return parseDef(def.type._def, refs);\n}\n", "import { ZodSetDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport type JsonSchema7SetType = {\n  type: 'array';\n  uniqueItems: true;\n  items?: JsonSchema7Type;\n  minItems?: number;\n  maxItems?: number;\n};\n\nexport function parseSetDef(def: ZodSetDef, refs: Refs): JsonSchema7SetType {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'items'],\n  });\n\n  const schema: JsonSchema7SetType = {\n    type: 'array',\n    uniqueItems: true,\n    items,\n  };\n\n  if (def.minSize) {\n    schema.minItems = def.minSize.value;\n  }\n\n  if (def.maxSize) {\n    schema.maxItems = def.maxSize.value;\n  }\n\n  return schema;\n}\n", "import { ZodTupleDef, ZodTupleItems, ZodTypeAny } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { JsonSchema7Type } from '../parse-types';\nimport { Refs } from '../refs';\n\nexport type JsonSchema7TupleType = {\n  type: 'array';\n  minItems: number;\n  items: JsonSchema7Type[];\n} & (\n  | {\n      maxItems: number;\n    }\n  | {\n      additionalItems?: JsonSchema7Type;\n    }\n);\n\nexport function parseTupleDef(\n  def: ZodTupleDef<ZodTupleItems | [], ZodTypeAny | null>,\n  refs: Refs,\n): JsonSchema7TupleType {\n  if (def.rest) {\n    return {\n      type: 'array',\n      minItems: def.items.length,\n      items: def.items\n        .map((x, i) =>\n          parseDef(x._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, 'items', `${i}`],\n          }),\n        )\n        .reduce(\n          (acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]),\n          [],\n        ),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, 'additionalItems'],\n      }),\n    };\n  } else {\n    return {\n      type: 'array',\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items\n        .map((x, i) =>\n          parseDef(x._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, 'items', `${i}`],\n          }),\n        )\n        .reduce(\n          (acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]),\n          [],\n        ),\n    };\n  }\n}\n", "import { JsonSchema7AnyType, parseAnyDef } from './any';\n\nexport type JsonSchema7UndefinedType = {\n  not: JsonSchema7AnyType;\n};\n\nexport function parseUndefinedDef(): JsonSchema7UndefinedType {\n  return {\n    not: parseAnyDef(),\n  };\n}\n", "import { JsonSchema7AnyType, parseAnyDef } from './any';\n\nexport type JsonSchema7UnknownType = JsonSchema7AnyType;\n\nexport function parseUnknownDef(): JsonSchema7UnknownType {\n  return parseAnyDef();\n}\n", "import { ZodReadonlyDef } from 'zod/v3';\nimport { parseDef } from '../parse-def';\nimport { Refs } from '../refs';\n\nexport const parseReadonlyDef = (def: ZodReadonlyDef<any>, refs: Refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n", "import { ZodTypeDef } from 'zod/v3';\nimport { Refs, Seen } from './refs';\nimport { ignoreOverride } from './options';\nimport { JsonSchema7Type } from './parse-types';\nimport { selectParser } from './select-parser';\nimport { getRelativePath } from './get-relative-path';\nimport { parseAnyDef } from './parsers/any';\n\nexport function parseDef(\n  def: ZodTypeDef,\n  refs: Refs,\n  forceResolution = false, // Forces a new schema to be instantiated even though its def has been seen. Used for improving refs in definitions. See https://github.com/StefanTerdell/zod-to-json-schema/pull/61.\n): JsonSchema7Type | undefined {\n  const seenItem = refs.seen.get(def);\n\n  if (refs.override) {\n    const overrideResult = refs.override?.(\n      def,\n      refs,\n      seenItem,\n      forceResolution,\n    );\n\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n\n    if (seenSchema !== undefined) {\n      return seenSchema;\n    }\n  }\n\n  const newItem: Seen = { def, path: refs.currentPath, jsonSchema: undefined };\n\n  refs.seen.set(def, newItem);\n\n  const jsonSchemaOrGetter = selectParser(def, (def as any).typeName, refs);\n\n  // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n  const jsonSchema =\n    typeof jsonSchemaOrGetter === 'function'\n      ? parseDef(jsonSchemaOrGetter(), refs)\n      : jsonSchemaOrGetter;\n\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n\n    newItem.jsonSchema = jsonSchema;\n\n    return postProcessResult;\n  }\n\n  newItem.jsonSchema = jsonSchema;\n\n  return jsonSchema;\n}\n\nconst get$ref = (\n  item: Seen,\n  refs: Refs,\n):\n  | {\n      $ref: string;\n    }\n  | {}\n  | undefined => {\n  switch (refs.$refStrategy) {\n    case 'root':\n      return { $ref: item.path.join('/') };\n    case 'relative':\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case 'none':\n    case 'seen': {\n      if (\n        item.path.length < refs.currentPath.length &&\n        item.path.every((value, index) => refs.currentPath[index] === value)\n      ) {\n        console.warn(\n          `Recursive reference detected at ${refs.currentPath.join(\n            '/',\n          )}! Defaulting to any`,\n        );\n\n        return parseAnyDef();\n      }\n\n      return refs.$refStrategy === 'seen' ? parseAnyDef() : undefined;\n    }\n  }\n};\n\nconst addMeta = (\n  def: ZodTypeDef,\n  refs: Refs,\n  jsonSchema: JsonSchema7Type,\n): JsonSchema7Type => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n  }\n  return jsonSchema;\n};\n", "import { ZodTypeDef } from 'zod/v3';\nimport { getDefaultOptions, Options } from './options';\nimport { JsonSchema7Type } from './parse-types';\n\nexport type Refs = {\n  seen: Map<ZodTypeDef, Seen>;\n  currentPath: string[];\n  propertyPath: string[] | undefined;\n} & Options;\n\nexport type Seen = {\n  def: ZodTypeDef;\n  path: string[];\n  jsonSchema: JsonSchema7Type | undefined;\n};\n\nexport const getRefs = (options?: string | Partial<Options>): Refs => {\n  const _options = getDefaultOptions(options);\n  const currentPath =\n    _options.name !== undefined\n      ? [..._options.basePath, _options.definitionPath, _options.name]\n      : _options.basePath;\n  return {\n    ..._options,\n    currentPath: currentPath,\n    propertyPath: undefined,\n    seen: new Map(\n      Object.entries(_options.definitions).map(([name, def]) => [\n        def._def,\n        {\n          def: def._def,\n          path: [..._options.basePath, _options.definitionPath, name],\n          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n          jsonSchema: undefined,\n        },\n      ]),\n    ),\n  };\n};\n", "import { ZodSchema } from 'zod/v3';\nimport { Options } from './options';\nimport { parseDef } from './parse-def';\nimport { JsonSchema7Type } from './parse-types';\nimport { getRefs } from './refs';\nimport { parseAnyDef } from './parsers/any';\n\nconst zodToJsonSchema = (\n  schema: ZodSchema<any>,\n  options?: Partial<Options> | string,\n): JsonSchema7Type & {\n  $schema?: string;\n  definitions?: {\n    [key: string]: JsonSchema7Type;\n  };\n} => {\n  const refs = getRefs(options);\n\n  let definitions =\n    typeof options === 'object' && options.definitions\n      ? Object.entries(options.definitions).reduce(\n          (acc: { [key: string]: JsonSchema7Type }, [name, schema]) => ({\n            ...acc,\n            [name]:\n              parseDef(\n                schema._def,\n                {\n                  ...refs,\n                  currentPath: [...refs.basePath, refs.definitionPath, name],\n                },\n                true,\n              ) ?? parseAnyDef(),\n          }),\n          {},\n        )\n      : undefined;\n\n  const name =\n    typeof options === 'string'\n      ? options\n      : options?.nameStrategy === 'title'\n        ? undefined\n        : options?.name;\n\n  const main =\n    parseDef(\n      schema._def,\n      name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n          },\n      false,\n    ) ?? (parseAnyDef() as JsonSchema7Type);\n\n  const title =\n    typeof options === 'object' &&\n    options.name !== undefined &&\n    options.nameStrategy === 'title'\n      ? options.name\n      : undefined;\n\n  if (title !== undefined) {\n    main.title = title;\n  }\n\n  const combined: ReturnType<typeof zodToJsonSchema> =\n    name === undefined\n      ? definitions\n        ? {\n            ...main,\n            [refs.definitionPath]: definitions,\n          }\n        : main\n      : {\n          $ref: [\n            ...(refs.$refStrategy === 'relative' ? [] : refs.basePath),\n            refs.definitionPath,\n            name,\n          ].join('/'),\n          [refs.definitionPath]: {\n            ...definitions,\n            [name]: main,\n          },\n        };\n\n  combined.$schema = 'http://json-schema.org/draft-07/schema#';\n\n  return combined;\n};\n\nexport { zodToJsonSchema };\n", "export * from './get-relative-path';\nexport * from './options';\nexport * from './parse-def';\nexport * from './parse-types';\nexport * from './parsers/any';\nexport * from './parsers/array';\nexport * from './parsers/bigint';\nexport * from './parsers/boolean';\nexport * from './parsers/branded';\nexport * from './parsers/catch';\nexport * from './parsers/date';\nexport * from './parsers/default';\nexport * from './parsers/effects';\nexport * from './parsers/enum';\nexport * from './parsers/intersection';\nexport * from './parsers/literal';\nexport * from './parsers/map';\nexport * from './parsers/native-enum';\nexport * from './parsers/never';\nexport * from './parsers/null';\nexport * from './parsers/nullable';\nexport * from './parsers/number';\nexport * from './parsers/object';\nexport * from './parsers/optional';\nexport * from './parsers/pipeline';\nexport * from './parsers/promise';\nexport * from './parsers/readonly';\nexport * from './parsers/record';\nexport * from './parsers/set';\nexport * from './parsers/string';\nexport * from './parsers/tuple';\nexport * from './parsers/undefined';\nexport * from './parsers/union';\nexport * from './parsers/unknown';\nexport * from './refs';\nexport * from './select-parser';\nexport * from './zod-to-json-schema';\nimport { zodToJsonSchema } from './zod-to-json-schema';\nexport default zodToJsonSchema;\n", "import { JSONSchema7 } from '@ai-sdk/provider';\nimport * as z3 from 'zod/v3';\nimport * as z4 from 'zod/v4';\nimport { Validator, validatorSymbol, type ValidationResult } from './validator';\nimport { zodSchema } from './zod-schema';\n\n/**\n * Used to mark schemas so we can support both Zod and custom schemas.\n */\nconst schemaSymbol = Symbol.for('vercel.ai.schema');\n\nexport type Schema<OBJECT = unknown> = Validator<OBJECT> & {\n  /**\n   * Used to mark schemas so we can support both Zod and custom schemas.\n   */\n  [schemaSymbol]: true;\n\n  /**\n   * Schema type for inference.\n   */\n  _type: OBJECT;\n\n  /**\n   * The JSON Schema for the schema. It is passed to the providers.\n   */\n  readonly jsonSchema: JSONSchema7;\n};\n\n/**\n * Creates a schema with deferred creation.\n * This is important to reduce the startup time of the library\n * and to avoid initializing unused validators.\n *\n * @param createValidator A function that creates a schema.\n * @returns A function that returns a schema.\n */\nexport function lazySchema<SCHEMA>(\n  createSchema: () => Schema<SCHEMA>,\n): LazySchema<SCHEMA> {\n  // cache the validator to avoid initializing it multiple times\n  let schema: Schema<SCHEMA> | undefined;\n  return () => {\n    if (schema == null) {\n      schema = createSchema();\n    }\n    return schema;\n  };\n}\n\nexport type LazySchema<SCHEMA> = () => Schema<SCHEMA>;\n\n// Note: Zod types here exactly match the types in zod-schema.ts\n// to prevent type errors when using zod schemas with flexible schemas.\nexport type FlexibleSchema<SCHEMA> =\n  | z4.core.$ZodType<SCHEMA, any>\n  | z3.Schema<SCHEMA, z3.ZodTypeDef, any>\n  | Schema<SCHEMA>\n  | LazySchema<SCHEMA>;\n\nexport type InferSchema<SCHEMA> = SCHEMA extends z3.Schema\n  ? z3.infer<SCHEMA>\n  : SCHEMA extends z4.core.$ZodType\n    ? z4.infer<SCHEMA>\n    : SCHEMA extends LazySchema<infer T>\n      ? T\n      : SCHEMA extends Schema<infer T>\n        ? T\n        : never;\n\n/**\n * Create a schema using a JSON Schema.\n *\n * @param jsonSchema The JSON Schema for the schema.\n * @param options.validate Optional. A validation function for the schema.\n */\nexport function jsonSchema<OBJECT = unknown>(\n  jsonSchema: JSONSchema7 | (() => JSONSchema7),\n  {\n    validate,\n  }: {\n    validate?: (\n      value: unknown,\n    ) => ValidationResult<OBJECT> | PromiseLike<ValidationResult<OBJECT>>;\n  } = {},\n): Schema<OBJECT> {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined as OBJECT, // should never be used directly\n    [validatorSymbol]: true,\n    get jsonSchema() {\n      if (typeof jsonSchema === 'function') {\n        jsonSchema = jsonSchema(); // cache the function results\n      }\n      return jsonSchema;\n    },\n    validate,\n  };\n}\n\nfunction isSchema(value: unknown): value is Schema {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    schemaSymbol in value &&\n    value[schemaSymbol] === true &&\n    'jsonSchema' in value &&\n    'validate' in value\n  );\n}\n\nexport function asSchema<OBJECT>(\n  schema: FlexibleSchema<OBJECT> | undefined,\n): Schema<OBJECT> {\n  return schema == null\n    ? jsonSchema({\n        properties: {},\n        additionalProperties: false,\n      })\n    : isSchema(schema)\n      ? schema\n      : typeof schema === 'function'\n        ? schema()\n        : zodSchema(schema);\n}\n", "// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n\nexport function convertToBase64(value: string | Uint8Array): string {\n  return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;\n}\n", "export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n", "export function isAsyncIterable<T = any>(obj: any): obj is AsyncIterable<T> {\n  return obj != null && typeof obj[Symbol.asyncIterator] === 'function';\n}\n", "import { Tool, ToolCallOptions, ToolExecuteFunction } from './tool';\nimport { isAsyncIterable } from '../is-async-iterable';\n\nexport async function* executeTool<INPUT, OUTPUT>({\n  execute,\n  input,\n  options,\n}: {\n  execute: ToolExecuteFunction<INPUT, OUTPUT>;\n  input: INPUT;\n  options: ToolCallOptions;\n}): AsyncGenerator<\n  { type: 'preliminary'; output: OUTPUT } | { type: 'final'; output: OUTPUT }\n> {\n  const result = execute(input, options);\n\n  if (isAsyncIterable(result)) {\n    let lastOutput: OUTPUT | undefined;\n    for await (const output of result) {\n      lastOutput = output;\n      yield { type: 'preliminary', output };\n    }\n    yield { type: 'final', output: lastOutput! };\n  } else {\n    yield { type: 'final', output: await result };\n  }\n}\n", "export * from './combine-headers';\nexport { convertAsyncIteratorToReadableStream } from './convert-async-iterator-to-readable-stream';\nexport * from './delay';\nexport * from './extract-response-headers';\nexport * from './fetch-function';\nexport { createIdGenerator, generateId, type IdGenerator } from './generate-id';\nexport * from './get-error-message';\nexport * from './get-from-api';\nexport { getRuntimeEnvironmentUserAgent } from './get-runtime-environment-user-agent';\nexport { injectJsonInstructionIntoMessages } from './inject-json-instruction';\nexport * from './is-abort-error';\nexport { isUrlSupported } from './is-url-supported';\nexport * from './load-api-key';\nexport { loadOptionalSetting } from './load-optional-setting';\nexport { loadSetting } from './load-setting';\nexport { mediaTypeToExtension } from './media-type-to-extension';\nexport { normalizeHeaders } from './normalize-headers';\nexport * from './parse-json';\nexport { parseJsonEventStream } from './parse-json-event-stream';\nexport { parseProviderOptions } from './parse-provider-options';\nexport * from './post-to-api';\nexport {\n  createProviderDefinedToolFactory,\n  createProviderDefinedToolFactoryWithOutputSchema,\n  type ProviderDefinedToolFactory,\n  type ProviderDefinedToolFactoryWithOutputSchema,\n} from './provider-defined-tool-factory';\nexport * from './remove-undefined-entries';\nexport * from './resolve';\nexport * from './response-handler';\nexport {\n  asSchema,\n  jsonSchema,\n  lazySchema,\n  type FlexibleSchema,\n  type InferSchema,\n  type LazySchema,\n  type Schema,\n} from './schema';\nexport * from './uint8-utils';\nexport * from './validate-types';\nexport {\n  asValidator,\n  isValidator,\n  lazyValidator,\n  standardSchemaValidator,\n  validator,\n  type FlexibleValidator,\n  type InferValidator,\n  type LazyValidator,\n  type ValidationResult,\n  type Validator,\n} from './validator';\nexport { VERSION } from './version';\nexport { withUserAgentSuffix } from './with-user-agent-suffix';\nexport * from './without-trailing-slash';\nexport { zodSchema } from './zod-schema';\n\n// folder re-exports\nexport * from './types';\n\n// external re-exports\nexport * from '@standard-schema/spec';\nexport {\n  EventSourceParserStream,\n  type EventSourceMessage,\n} from 'eventsource-parser/stream';\n", "import {\n  loadOptionalSetting,\n  withoutTrailingSlash,\n  type FetchFunction,\n} from '@ai-sdk/provider-utils';\nimport { asGatewayError, GatewayAuthenticationError } from './errors';\nimport {\n  GATEWAY_AUTH_METHOD_HEADER,\n  parseAuthMethod,\n} from './errors/parse-auth-method';\nimport {\n  GatewayFetchMetadata,\n  type GatewayFetchMetadataResponse,\n  type GatewayCreditsResponse,\n} from './gateway-fetch-metadata';\nimport { GatewayLanguageModel } from './gateway-language-model';\nimport { GatewayEmbeddingModel } from './gateway-embedding-model';\nimport { GatewayImageModel } from './gateway-image-model';\nimport type { GatewayEmbeddingModelId } from './gateway-embedding-model-settings';\nimport type { GatewayImageModelId } from './gateway-image-model-settings';\nimport { getVercelOidcToken, getVercelRequestId } from './vercel-environment';\nimport type { GatewayModelId } from './gateway-language-model-settings';\nimport type {\n  LanguageModelV2,\n  EmbeddingModelV2,\n  ImageModelV2,\n  ProviderV2,\n} from '@ai-sdk/provider';\nimport { withUserAgentSuffix } from '@ai-sdk/provider-utils';\nimport { VERSION } from './version';\n\nexport interface GatewayProvider extends ProviderV2 {\n  (modelId: GatewayModelId): LanguageModelV2;\n\n  /**\nCreates a model for text generation.\n*/\n  languageModel(modelId: GatewayModelId): LanguageModelV2;\n\n  /**\nReturns available providers and models for use with the remote provider.\n */\n  getAvailableModels(): Promise<GatewayFetchMetadataResponse>;\n\n  /**\nReturns credit information for the authenticated user.\n */\n  getCredits(): Promise<GatewayCreditsResponse>;\n\n  /**\nCreates a model for generating text embeddings.\n*/\n  textEmbeddingModel(\n    modelId: GatewayEmbeddingModelId,\n  ): EmbeddingModelV2<string>;\n\n  /**\nCreates a model for generating images.\n*/\n  imageModel(modelId: GatewayImageModelId): ImageModelV2;\n}\n\nexport interface GatewayProviderSettings {\n  /**\nThe base URL prefix for API calls. Defaults to `https://ai-gateway.vercel.sh/v1/ai`.\n   */\n  baseURL?: string;\n\n  /**\nAPI key that is being sent using the `Authorization` header.\n   */\n  apiKey?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n\n  /**\nHow frequently to refresh the metadata cache in milliseconds.\n   */\n  metadataCacheRefreshMillis?: number;\n\n  /**\n   * @internal For testing purposes only\n   */\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\nconst AI_GATEWAY_PROTOCOL_VERSION = '0.0.1';\n\n/**\nCreate a remote provider instance.\n */\nexport function createGatewayProvider(\n  options: GatewayProviderSettings = {},\n): GatewayProvider {\n  let pendingMetadata: Promise<GatewayFetchMetadataResponse> | null = null;\n  let metadataCache: GatewayFetchMetadataResponse | null = null;\n  const cacheRefreshMillis =\n    options.metadataCacheRefreshMillis ?? 1000 * 60 * 5;\n  let lastFetchTime = 0;\n\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ??\n    'https://ai-gateway.vercel.sh/v1/ai';\n\n  const getHeaders = async () => {\n    const auth = await getGatewayAuthToken(options);\n    if (auth) {\n      return withUserAgentSuffix(\n        {\n          Authorization: `Bearer ${auth.token}`,\n          'ai-gateway-protocol-version': AI_GATEWAY_PROTOCOL_VERSION,\n          [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,\n          ...options.headers,\n        },\n        `ai-sdk/gateway/${VERSION}`,\n      );\n    }\n\n    throw GatewayAuthenticationError.createContextualError({\n      apiKeyProvided: false,\n      oidcTokenProvided: false,\n      statusCode: 401,\n    });\n  };\n\n  const createO11yHeaders = () => {\n    const deploymentId = loadOptionalSetting({\n      settingValue: undefined,\n      environmentVariableName: 'VERCEL_DEPLOYMENT_ID',\n    });\n    const environment = loadOptionalSetting({\n      settingValue: undefined,\n      environmentVariableName: 'VERCEL_ENV',\n    });\n    const region = loadOptionalSetting({\n      settingValue: undefined,\n      environmentVariableName: 'VERCEL_REGION',\n    });\n\n    return async () => {\n      const requestId = await getVercelRequestId();\n      return {\n        ...(deploymentId && { 'ai-o11y-deployment-id': deploymentId }),\n        ...(environment && { 'ai-o11y-environment': environment }),\n        ...(region && { 'ai-o11y-region': region }),\n        ...(requestId && { 'ai-o11y-request-id': requestId }),\n      };\n    };\n  };\n\n  const createLanguageModel = (modelId: GatewayModelId) => {\n    return new GatewayLanguageModel(modelId, {\n      provider: 'gateway',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      o11yHeaders: createO11yHeaders(),\n    });\n  };\n\n  const getAvailableModels = async () => {\n    const now = options._internal?.currentDate?.().getTime() ?? Date.now();\n    if (!pendingMetadata || now - lastFetchTime > cacheRefreshMillis) {\n      lastFetchTime = now;\n\n      pendingMetadata = new GatewayFetchMetadata({\n        baseURL,\n        headers: getHeaders,\n        fetch: options.fetch,\n      })\n        .getAvailableModels()\n        .then(metadata => {\n          metadataCache = metadata;\n          return metadata;\n        })\n        .catch(async (error: unknown) => {\n          throw await asGatewayError(\n            error,\n            await parseAuthMethod(await getHeaders()),\n          );\n        });\n    }\n\n    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;\n  };\n\n  const getCredits = async () => {\n    return new GatewayFetchMetadata({\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n    })\n      .getCredits()\n      .catch(async (error: unknown) => {\n        throw await asGatewayError(\n          error,\n          await parseAuthMethod(await getHeaders()),\n        );\n      });\n  };\n\n  const provider = function (modelId: GatewayModelId) {\n    if (new.target) {\n      throw new Error(\n        'The Gateway Provider model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createLanguageModel(modelId);\n  };\n\n  provider.getAvailableModels = getAvailableModels;\n  provider.getCredits = getCredits;\n  provider.imageModel = (modelId: GatewayImageModelId) => {\n    return new GatewayImageModel(modelId, {\n      provider: 'gateway',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      o11yHeaders: createO11yHeaders(),\n    });\n  };\n  provider.languageModel = createLanguageModel;\n  provider.textEmbeddingModel = (modelId: GatewayEmbeddingModelId) => {\n    return new GatewayEmbeddingModel(modelId, {\n      provider: 'gateway',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      o11yHeaders: createO11yHeaders(),\n    });\n  };\n\n  return provider;\n}\n\nexport const gateway = createGatewayProvider();\n\nexport async function getGatewayAuthToken(\n  options: GatewayProviderSettings,\n): Promise<{\n  token: string;\n  authMethod: 'api-key' | 'oidc';\n} | null> {\n  const apiKey = loadOptionalSetting({\n    settingValue: options.apiKey,\n    environmentVariableName: 'AI_GATEWAY_API_KEY',\n  });\n\n  if (apiKey) {\n    return {\n      token: apiKey,\n      authMethod: 'api-key',\n    };\n  }\n\n  try {\n    const oidcToken = await getVercelOidcToken();\n    return {\n      token: oidcToken,\n      authMethod: 'oidc',\n    };\n  } catch {\n    return null;\n  }\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { extractApiCallResponse, GatewayError } from '.';\nimport { createGatewayErrorFromResponse } from './create-gateway-error';\n\nexport function asGatewayError(\n  error: unknown,\n  authMethod?: 'api-key' | 'oidc',\n) {\n  if (GatewayError.isInstance(error)) {\n    return error;\n  }\n\n  if (APICallError.isInstance(error)) {\n    return createGatewayErrorFromResponse({\n      response: extractApiCallResponse(error),\n      statusCode: error.statusCode ?? 500,\n      defaultMessage: 'Gateway request failed',\n      cause: error,\n      authMethod,\n    });\n  }\n\n  return createGatewayErrorFromResponse({\n    response: {},\n    statusCode: 500,\n    defaultMessage:\n      error instanceof Error\n        ? `Gateway request failed: ${error.message}`\n        : 'Unknown Gateway error',\n    cause: error,\n    authMethod,\n  });\n}\n", "import { z } from 'zod/v4';\nimport type { GatewayError } from './gateway-error';\nimport { GatewayAuthenticationError } from './gateway-authentication-error';\nimport { GatewayInvalidRequestError } from './gateway-invalid-request-error';\nimport { GatewayRateLimitError } from './gateway-rate-limit-error';\nimport {\n  GatewayModelNotFoundError,\n  modelNotFoundParamSchema,\n} from './gateway-model-not-found-error';\nimport { GatewayInternalServerError } from './gateway-internal-server-error';\nimport { GatewayResponseError } from './gateway-response-error';\nimport {\n  InferValidator,\n  lazyValidator,\n  safeValidateTypes,\n  validateTypes,\n  zodSchema,\n} from '@ai-sdk/provider-utils';\n\nexport async function createGatewayErrorFromResponse({\n  response,\n  statusCode,\n  defaultMessage = 'Gateway request failed',\n  cause,\n  authMethod,\n}: {\n  response: unknown;\n  statusCode: number;\n  defaultMessage?: string;\n  cause?: unknown;\n  authMethod?: 'api-key' | 'oidc';\n}): Promise<GatewayError> {\n  const parseResult = await safeValidateTypes({\n    value: response,\n    schema: gatewayErrorResponseSchema,\n  });\n\n  if (!parseResult.success) {\n    return new GatewayResponseError({\n      message: `Invalid error response format: ${defaultMessage}`,\n      statusCode,\n      response,\n      validationError: parseResult.error,\n      cause,\n    });\n  }\n\n  const validatedResponse: GatewayErrorResponse = parseResult.value;\n  const errorType = validatedResponse.error.type;\n  const message = validatedResponse.error.message;\n\n  switch (errorType) {\n    case 'authentication_error':\n      return GatewayAuthenticationError.createContextualError({\n        apiKeyProvided: authMethod === 'api-key',\n        oidcTokenProvided: authMethod === 'oidc',\n        statusCode,\n        cause,\n      });\n    case 'invalid_request_error':\n      return new GatewayInvalidRequestError({ message, statusCode, cause });\n    case 'rate_limit_exceeded':\n      return new GatewayRateLimitError({ message, statusCode, cause });\n    case 'model_not_found': {\n      const modelResult = await safeValidateTypes({\n        value: validatedResponse.error.param,\n        schema: modelNotFoundParamSchema,\n      });\n\n      return new GatewayModelNotFoundError({\n        message,\n        statusCode,\n        modelId: modelResult.success ? modelResult.value.modelId : undefined,\n        cause,\n      });\n    }\n    case 'internal_server_error':\n      return new GatewayInternalServerError({ message, statusCode, cause });\n    default:\n      return new GatewayInternalServerError({ message, statusCode, cause });\n  }\n}\n\nconst gatewayErrorResponseSchema = lazyValidator(() =>\n  zodSchema(\n    z.object({\n      error: z.object({\n        message: z.string(),\n        type: z.string().nullish(),\n        param: z.unknown().nullish(),\n        code: z.union([z.string(), z.number()]).nullish(),\n      }),\n    }),\n  ),\n);\n\nexport type GatewayErrorResponse = InferValidator<\n  typeof gatewayErrorResponseSchema\n>;\n", "const marker = 'vercel.ai.gateway.error';\nconst symbol = Symbol.for(marker);\n\nexport abstract class GatewayError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  abstract readonly name: string;\n  abstract readonly type: string;\n  readonly statusCode: number;\n  readonly cause?: unknown;\n\n  constructor({\n    message,\n    statusCode = 500,\n    cause,\n  }: {\n    message: string;\n    statusCode?: number;\n    cause?: unknown;\n  }) {\n    super(message);\n    this.statusCode = statusCode;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is a Gateway Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is a Gateway Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is GatewayError {\n    return GatewayError.hasMarker(error);\n  }\n\n  static hasMarker(error: unknown): error is GatewayError {\n    return (\n      typeof error === 'object' &&\n      error !== null &&\n      symbol in error &&\n      (error as any)[symbol] === true\n    );\n  }\n}\n", "import { GatewayError } from './gateway-error';\n\nconst name = 'GatewayAuthenticationError';\nconst marker = `vercel.ai.gateway.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Authentication failed - invalid API key or OIDC token\n */\nexport class GatewayAuthenticationError extends GatewayError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly name = name;\n  readonly type = 'authentication_error';\n\n  constructor({\n    message = 'Authentication failed',\n    statusCode = 401,\n    cause,\n  }: {\n    message?: string;\n    statusCode?: number;\n    cause?: unknown;\n  } = {}) {\n    super({ message, statusCode, cause });\n  }\n\n  static isInstance(error: unknown): error is GatewayAuthenticationError {\n    return GatewayError.hasMarker(error) && symbol in error;\n  }\n\n  /**\n   * Creates a contextual error message when authentication fails\n   */\n  static createContextualError({\n    apiKeyProvided,\n    oidcTokenProvided,\n    message = 'Authentication failed',\n    statusCode = 401,\n    cause,\n  }: {\n    apiKeyProvided: boolean;\n    oidcTokenProvided: boolean;\n    message?: string;\n    statusCode?: number;\n    cause?: unknown;\n  }): GatewayAuthenticationError {\n    let contextualMessage: string;\n\n    if (apiKeyProvided) {\n      contextualMessage = `AI Gateway authentication failed: Invalid API key.\n\nCreate a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys\n\nProvide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;\n    } else if (oidcTokenProvided) {\n      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.\n\nRun 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.\n\nAlternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;\n    } else {\n      contextualMessage = `AI Gateway authentication failed: No authentication provided.\n\nOption 1 - API key:\nCreate an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys\nProvide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.\n\nOption 2 - OIDC token:\nRun 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;\n    }\n\n    return new GatewayAuthenticationError({\n      message: contextualMessage,\n      statusCode,\n      cause,\n    });\n  }\n}\n", "import { GatewayError } from './gateway-error';\n\nconst name = 'GatewayInvalidRequestError';\nconst marker = `vercel.ai.gateway.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Invalid request - missing headers, malformed data, etc.\n */\nexport class GatewayInvalidRequestError extends GatewayError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly name = name;\n  readonly type = 'invalid_request_error';\n\n  constructor({\n    message = 'Invalid request',\n    statusCode = 400,\n    cause,\n  }: {\n    message?: string;\n    statusCode?: number;\n    cause?: unknown;\n  } = {}) {\n    super({ message, statusCode, cause });\n  }\n\n  static isInstance(error: unknown): error is GatewayInvalidRequestError {\n    return GatewayError.hasMarker(error) && symbol in error;\n  }\n}\n", "import { GatewayError } from './gateway-error';\n\nconst name = 'GatewayRateLimitError';\nconst marker = `vercel.ai.gateway.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Rate limit exceeded.\n */\nexport class GatewayRateLimitError extends GatewayError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly name = name;\n  readonly type = 'rate_limit_exceeded';\n\n  constructor({\n    message = 'Rate limit exceeded',\n    statusCode = 429,\n    cause,\n  }: {\n    message?: string;\n    statusCode?: number;\n    cause?: unknown;\n  } = {}) {\n    super({ message, statusCode, cause });\n  }\n\n  static isInstance(error: unknown): error is GatewayRateLimitError {\n    return GatewayError.hasMarker(error) && symbol in error;\n  }\n}\n", "import { z } from 'zod/v4';\nimport { GatewayError } from './gateway-error';\nimport { lazyValidator, zodSchema } from '@ai-sdk/provider-utils';\n\nconst name = 'GatewayModelNotFoundError';\nconst marker = `vercel.ai.gateway.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport const modelNotFoundParamSchema = lazyValidator(() =>\n  zodSchema(\n    z.object({\n      modelId: z.string(),\n    }),\n  ),\n);\n\n/**\n * Model not found or not available\n */\nexport class GatewayModelNotFoundError extends GatewayError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly name = name;\n  readonly type = 'model_not_found';\n  readonly modelId?: string;\n\n  constructor({\n    message = 'Model not found',\n    statusCode = 404,\n    modelId,\n    cause,\n  }: {\n    message?: string;\n    statusCode?: number;\n    modelId?: string;\n    cause?: unknown;\n  } = {}) {\n    super({ message, statusCode, cause });\n    this.modelId = modelId;\n  }\n\n  static isInstance(error: unknown): error is GatewayModelNotFoundError {\n    return GatewayError.hasMarker(error) && symbol in error;\n  }\n}\n", "import { GatewayError } from './gateway-error';\n\nconst name = 'GatewayInternalServerError';\nconst marker = `vercel.ai.gateway.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Internal server error from the Gateway\n */\nexport class GatewayInternalServerError extends GatewayError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly name = name;\n  readonly type = 'internal_server_error';\n\n  constructor({\n    message = 'Internal server error',\n    statusCode = 500,\n    cause,\n  }: {\n    message?: string;\n    statusCode?: number;\n    cause?: unknown;\n  } = {}) {\n    super({ message, statusCode, cause });\n  }\n\n  static isInstance(error: unknown): error is GatewayInternalServerError {\n    return GatewayError.hasMarker(error) && symbol in error;\n  }\n}\n", "import { TypeValidationError } from '@ai-sdk/provider';\nimport { GatewayError } from './gateway-error';\n\nconst name = 'GatewayResponseError';\nconst marker = `vercel.ai.gateway.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Gateway response parsing error\n */\nexport class GatewayResponseError extends GatewayError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly name = name;\n  readonly type = 'response_error';\n  readonly response?: unknown;\n  readonly validationError?: TypeValidationError;\n\n  constructor({\n    message = 'Invalid response from Gateway',\n    statusCode = 502,\n    response,\n    validationError,\n    cause,\n  }: {\n    message?: string;\n    statusCode?: number;\n    response?: unknown;\n    validationError?: TypeValidationError;\n    cause?: unknown;\n  } = {}) {\n    super({ message, statusCode, cause });\n    this.response = response;\n    this.validationError = validationError;\n  }\n\n  static isInstance(error: unknown): error is GatewayResponseError {\n    return GatewayError.hasMarker(error) && symbol in error;\n  }\n}\n", "import type { APICallError } from '@ai-sdk/provider';\n\nexport function extractApiCallResponse(error: APICallError): unknown {\n  if (error.data !== undefined) {\n    return error.data;\n  }\n  if (error.responseBody != null) {\n    try {\n      return JSON.parse(error.responseBody);\n    } catch {\n      return error.responseBody;\n    }\n  }\n  return {};\n}\n", "import { z } from 'zod/v4';\nimport {\n  lazyValidator,\n  safeValidateTypes,\n  zodSchema,\n} from '@ai-sdk/provider-utils';\n\nexport const GATEWAY_AUTH_METHOD_HEADER = 'ai-gateway-auth-method' as const;\n\nexport async function parseAuthMethod(\n  headers: Record<string, string | undefined>,\n) {\n  const result = await safeValidateTypes({\n    value: headers[GATEWAY_AUTH_METHOD_HEADER],\n    schema: gatewayAuthMethodSchema,\n  });\n\n  return result.success ? result.value : undefined;\n}\n\nconst gatewayAuthMethodSchema = lazyValidator(() =>\n  zodSchema(z.union([z.literal('api-key'), z.literal('oidc')])),\n);\n", "import {\n  createJsonErrorResponseHandler,\n  createJsonResponseHandler,\n  getFromApi,\n  lazyValidator,\n  resolve,\n  zodSchema,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { asGatewayError } from './errors';\nimport type { GatewayConfig } from './gateway-config';\nimport type { GatewayLanguageModelEntry } from './gateway-model-entry';\n\ntype GatewayFetchMetadataConfig = GatewayConfig;\n\nexport interface GatewayFetchMetadataResponse {\n  models: GatewayLanguageModelEntry[];\n}\n\nexport interface GatewayCreditsResponse {\n  /** The remaining gateway credit balance available for API usage */\n  balance: string;\n  /** The total amount of gateway credits that have been consumed */\n  totalUsed: string;\n}\n\nexport class GatewayFetchMetadata {\n  constructor(private readonly config: GatewayFetchMetadataConfig) {}\n\n  async getAvailableModels(): Promise<GatewayFetchMetadataResponse> {\n    try {\n      const { value } = await getFromApi({\n        url: `${this.config.baseURL}/config`,\n        headers: await resolve(this.config.headers()),\n        successfulResponseHandler: createJsonResponseHandler(\n          gatewayAvailableModelsResponseSchema,\n        ),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: z.any(),\n          errorToMessage: data => data,\n        }),\n        fetch: this.config.fetch,\n      });\n\n      return value;\n    } catch (error) {\n      throw await asGatewayError(error);\n    }\n  }\n\n  async getCredits(): Promise<GatewayCreditsResponse> {\n    try {\n      const baseUrl = new URL(this.config.baseURL);\n\n      const { value } = await getFromApi({\n        url: `${baseUrl.origin}/v1/credits`,\n        headers: await resolve(this.config.headers()),\n        successfulResponseHandler: createJsonResponseHandler(\n          gatewayCreditsResponseSchema,\n        ),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: z.any(),\n          errorToMessage: data => data,\n        }),\n        fetch: this.config.fetch,\n      });\n\n      return value;\n    } catch (error) {\n      throw await asGatewayError(error);\n    }\n  }\n}\n\nconst gatewayAvailableModelsResponseSchema = lazyValidator(() =>\n  zodSchema(\n    z.object({\n      models: z.array(\n        z.object({\n          id: z.string(),\n          name: z.string(),\n          description: z.string().nullish(),\n          pricing: z\n            .object({\n              input: z.string(),\n              output: z.string(),\n              input_cache_read: z.string().nullish(),\n              input_cache_write: z.string().nullish(),\n            })\n            .transform(\n              ({ input, output, input_cache_read, input_cache_write }) => ({\n                input,\n                output,\n                ...(input_cache_read\n                  ? { cachedInputTokens: input_cache_read }\n                  : {}),\n                ...(input_cache_write\n                  ? { cacheCreationInputTokens: input_cache_write }\n                  : {}),\n              }),\n            )\n            .nullish(),\n          specification: z.object({\n            specificationVersion: z.literal('v2'),\n            provider: z.string(),\n            modelId: z.string(),\n          }),\n          modelType: z.enum(['language', 'embedding', 'image']).nullish(),\n        }),\n      ),\n    }),\n  ),\n);\n\nconst gatewayCreditsResponseSchema = lazyValidator(() =>\n  zodSchema(\n    z\n      .object({\n        balance: z.string(),\n        total_used: z.string(),\n      })\n      .transform(({ balance, total_used }) => ({\n        balance,\n        totalUsed: total_used,\n      })),\n  ),\n);\n", "import type {\n  LanguageModelV2,\n  LanguageModelV2CallOptions,\n  LanguageModelV2CallWarning,\n  LanguageModelV2FilePart,\n  LanguageModelV2StreamPart,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonErrorResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n  resolve,\n  type ParseResult,\n  type Resolvable,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport type { GatewayConfig } from './gateway-config';\nimport type { GatewayModelId } from './gateway-language-model-settings';\nimport { asGatewayError } from './errors';\nimport { parseAuthMethod } from './errors/parse-auth-method';\n\ntype GatewayChatConfig = GatewayConfig & {\n  provider: string;\n  o11yHeaders: Resolvable<Record<string, string>>;\n};\n\nexport class GatewayLanguageModel implements LanguageModelV2 {\n  readonly specificationVersion = 'v2';\n  readonly supportedUrls = { '*/*': [/.*/] };\n\n  constructor(\n    readonly modelId: GatewayModelId,\n    private readonly config: GatewayChatConfig,\n  ) {}\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private async getArgs(options: Parameters<LanguageModelV2['doGenerate']>[0]) {\n    const { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;\n\n    return {\n      args: this.maybeEncodeFileParts(optionsWithoutSignal),\n      warnings: [],\n    };\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV2['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doGenerate']>>> {\n    const { args, warnings } = await this.getArgs(options);\n    const { abortSignal } = options;\n\n    const resolvedHeaders = await resolve(this.config.headers());\n\n    try {\n      const {\n        responseHeaders,\n        value: responseBody,\n        rawValue: rawResponse,\n      } = await postJsonToApi({\n        url: this.getUrl(),\n        headers: combineHeaders(\n          resolvedHeaders,\n          options.headers,\n          this.getModelConfigHeaders(this.modelId, false),\n          await resolve(this.config.o11yHeaders),\n        ),\n        body: args,\n        successfulResponseHandler: createJsonResponseHandler(z.any()),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: z.any(),\n          errorToMessage: data => data,\n        }),\n        ...(abortSignal && { abortSignal }),\n        fetch: this.config.fetch,\n      });\n\n      return {\n        ...responseBody,\n        request: { body: args },\n        response: { headers: responseHeaders, body: rawResponse },\n        warnings,\n      };\n    } catch (error) {\n      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));\n    }\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV2['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV2['doStream']>>> {\n    const { args, warnings } = await this.getArgs(options);\n    const { abortSignal } = options;\n\n    const resolvedHeaders = await resolve(this.config.headers());\n\n    try {\n      const { value: response, responseHeaders } = await postJsonToApi({\n        url: this.getUrl(),\n        headers: combineHeaders(\n          resolvedHeaders,\n          options.headers,\n          this.getModelConfigHeaders(this.modelId, true),\n          await resolve(this.config.o11yHeaders),\n        ),\n        body: args,\n        successfulResponseHandler: createEventSourceResponseHandler(z.any()),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: z.any(),\n          errorToMessage: data => data,\n        }),\n        ...(abortSignal && { abortSignal }),\n        fetch: this.config.fetch,\n      });\n\n      return {\n        stream: response.pipeThrough(\n          new TransformStream<\n            ParseResult<LanguageModelV2StreamPart>,\n            LanguageModelV2StreamPart\n          >({\n            start(controller) {\n              if (warnings.length > 0) {\n                controller.enqueue({ type: 'stream-start', warnings });\n              }\n            },\n            transform(chunk, controller) {\n              if (chunk.success) {\n                const streamPart = chunk.value;\n\n                // Handle raw chunks: if this is a raw chunk from the gateway API,\n                // only emit it if includeRawChunks is true\n                if (streamPart.type === 'raw' && !options.includeRawChunks) {\n                  return; // Skip raw chunks if not requested\n                }\n\n                if (\n                  streamPart.type === 'response-metadata' &&\n                  streamPart.timestamp &&\n                  typeof streamPart.timestamp === 'string'\n                ) {\n                  streamPart.timestamp = new Date(streamPart.timestamp);\n                }\n\n                controller.enqueue(streamPart);\n              } else {\n                controller.error(\n                  (chunk as { success: false; error: unknown }).error,\n                );\n              }\n            },\n          }),\n        ),\n        request: { body: args },\n        response: { headers: responseHeaders },\n      };\n    } catch (error) {\n      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));\n    }\n  }\n\n  private isFilePart(part: unknown) {\n    return (\n      part && typeof part === 'object' && 'type' in part && part.type === 'file'\n    );\n  }\n\n  /**\n   * Encodes file parts in the prompt to base64. Mutates the passed options\n   * instance directly to avoid copying the file data.\n   * @param options - The options to encode.\n   * @returns The options with the file parts encoded.\n   */\n  private maybeEncodeFileParts(options: LanguageModelV2CallOptions) {\n    for (const message of options.prompt) {\n      for (const part of message.content) {\n        if (this.isFilePart(part)) {\n          const filePart = part as LanguageModelV2FilePart;\n          // If the file part is a URL it will get cleanly converted to a string.\n          // If it's a binary file attachment we convert it to a data url.\n          // In either case, server-side we should only ever see URLs as strings.\n          if (filePart.data instanceof Uint8Array) {\n            const buffer = Uint8Array.from(filePart.data);\n            const base64Data = Buffer.from(buffer).toString('base64');\n            filePart.data = new URL(\n              `data:${filePart.mediaType || 'application/octet-stream'};base64,${base64Data}`,\n            );\n          }\n        }\n      }\n    }\n    return options;\n  }\n\n  private getUrl() {\n    return `${this.config.baseURL}/language-model`;\n  }\n\n  private getModelConfigHeaders(modelId: string, streaming: boolean) {\n    return {\n      'ai-language-model-specification-version': '2',\n      'ai-language-model-id': modelId,\n      'ai-language-model-streaming': String(streaming),\n    };\n  }\n}\n", "import type {\n  EmbeddingModelV2,\n  SharedV2ProviderMetadata,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonErrorResponseHandler,\n  createJsonResponseHandler,\n  lazyValidator,\n  postJsonToApi,\n  resolve,\n  zodSchema,\n  type Resolvable,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { asGatewayError } from './errors';\nimport { parseAuthMethod } from './errors/parse-auth-method';\nimport type { GatewayConfig } from './gateway-config';\n\nexport class GatewayEmbeddingModel implements EmbeddingModelV2<string> {\n  readonly specificationVersion = 'v2';\n  readonly maxEmbeddingsPerCall = 2048;\n  readonly supportsParallelCalls = true;\n\n  constructor(\n    readonly modelId: string,\n    private readonly config: GatewayConfig & {\n      provider: string;\n      o11yHeaders: Resolvable<Record<string, string>>;\n    },\n  ) {}\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n    providerOptions,\n  }: Parameters<EmbeddingModelV2<string>['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV2<string>['doEmbed']>>\n  > {\n    const resolvedHeaders = await resolve(this.config.headers());\n    try {\n      const {\n        responseHeaders,\n        value: responseBody,\n        rawValue,\n      } = await postJsonToApi({\n        url: this.getUrl(),\n        headers: combineHeaders(\n          resolvedHeaders,\n          headers ?? {},\n          this.getModelConfigHeaders(),\n          await resolve(this.config.o11yHeaders),\n        ),\n        body: {\n          input: values.length === 1 ? values[0] : values,\n          ...(providerOptions ? { providerOptions } : {}),\n        },\n        successfulResponseHandler: createJsonResponseHandler(\n          gatewayEmbeddingResponseSchema,\n        ),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: z.any(),\n          errorToMessage: data => data,\n        }),\n        ...(abortSignal && { abortSignal }),\n        fetch: this.config.fetch,\n      });\n\n      return {\n        embeddings: responseBody.embeddings,\n        usage: responseBody.usage ?? undefined,\n        providerMetadata:\n          responseBody.providerMetadata as unknown as SharedV2ProviderMetadata,\n        response: { headers: responseHeaders, body: rawValue },\n      };\n    } catch (error) {\n      throw await asGatewayError(error, await parseAuthMethod(resolvedHeaders));\n    }\n  }\n\n  private getUrl() {\n    return `${this.config.baseURL}/embedding-model`;\n  }\n\n  private getModelConfigHeaders() {\n    return {\n      'ai-embedding-model-specification-version': '2',\n      'ai-model-id': this.modelId,\n    };\n  }\n}\n\nconst gatewayEmbeddingResponseSchema = lazyValidator(() =>\n  zodSchema(\n    z.object({\n      embeddings: z.array(z.array(z.number())),\n      usage: z.object({ tokens: z.number() }).nullish(),\n      providerMetadata: z\n        .record(z.string(), z.record(z.string(), z.unknown()))\n        .optional(),\n    }),\n  ),\n);\n", "import type {\n  ImageModelV2,\n  ImageModelV2CallWarning,\n  ImageModelV2ProviderMetadata,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  createJsonErrorResponseHandler,\n  postJsonToApi,\n  resolve,\n  type Resolvable,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport type { GatewayConfig } from './gateway-config';\nimport { asGatewayError } from './errors';\nimport { parseAuthMethod } from './errors/parse-auth-method';\n\nexport class GatewayImageModel implements ImageModelV2 {\n  readonly specificationVersion = 'v2';\n  // Set a very large number to prevent client-side splitting of requests\n  readonly maxImagesPerCall = Number.MAX_SAFE_INTEGER;\n\n  constructor(\n    readonly modelId: string,\n    private readonly config: GatewayConfig & {\n      provider: string;\n      o11yHeaders: Resolvable<Record<string, string>>;\n    },\n  ) {}\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal,\n  }: Parameters<ImageModelV2['doGenerate']>[0]): Promise<\n    Awaited<ReturnType<ImageModelV2['doGenerate']>>\n  > {\n    const resolvedHeaders = await resolve(this.config.headers());\n    try {\n      const {\n        responseHeaders,\n        value: responseBody,\n        rawValue,\n      } = await postJsonToApi({\n        url: this.getUrl(),\n        headers: combineHeaders(\n          resolvedHeaders,\n          headers ?? {},\n          this.getModelConfigHeaders(),\n          await resolve(this.config.o11yHeaders),\n        ),\n        body: {\n          prompt,\n          n,\n          ...(size && { size }),\n          ...(aspectRatio && { aspectRatio }),\n          ...(seed && { seed }),\n          ...(providerOptions && { providerOptions }),\n        },\n        successfulResponseHandler: createJsonResponseHandler(\n          gatewayImageResponseSchema,\n        ),\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: z.any(),\n          errorToMessage: data => data,\n        }),\n        ...(abortSignal && { abortSignal }),\n        fetch: this.config.fetch,\n      });\n\n      return {\n        images: responseBody.images, // Always base64 strings from server\n        warnings: responseBody.warnings ?? [],\n        providerMetadata:\n          responseBody.providerMetadata as ImageModelV2ProviderMetadata,\n        response: {\n          timestamp: new Date(),\n          modelId: this.modelId,\n          headers: responseHeaders,\n        },\n      };\n    } catch (error) {\n      throw asGatewayError(error, await parseAuthMethod(resolvedHeaders));\n    }\n  }\n\n  private getUrl() {\n    return `${this.config.baseURL}/image-model`;\n  }\n\n  private getModelConfigHeaders() {\n    return {\n      'ai-image-model-specification-version': '2',\n      'ai-model-id': this.modelId,\n    };\n  }\n}\n\nconst providerMetadataEntrySchema = z\n  .object({\n    images: z.array(z.unknown()).optional(),\n  })\n  .catchall(z.unknown());\n\nconst gatewayImageResponseSchema = z.object({\n  images: z.array(z.string()), // Always base64 strings over the wire\n  warnings: z\n    .array(\n      z.object({\n        type: z.literal('other'),\n        message: z.string(),\n      }),\n    )\n    .optional(),\n  providerMetadata: z\n    .record(z.string(), providerMetadataEntrySchema)\n    .optional(),\n});\n", "import { getContext } from '@vercel/oidc';\nexport { getVercelOidcToken } from '@vercel/oidc';\n\nexport async function getVercelRequestId(): Promise<string | undefined> {\n  return getContext().headers?.['x-vercel-id'];\n}\n", "// Version string of this package injected at build time.\ndeclare const __PACKAGE_VERSION__: string | undefined;\nexport const VERSION: string =\n  typeof __PACKAGE_VERSION__ !== 'undefined'\n    ? __PACKAGE_VERSION__\n    : '0.0.0-test';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of status codes.\n */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins\nexport const _globalThis = typeof globalThis === 'object' ? globalThis : global;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.9.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\nimport { Link } from './link';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  addLink(_link: Link): this {\n    return this;\n  }\n\n  addLinks(_links: Link[]): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Baggage, BaggageEntry } from '../types';\n\nexport class BaggageImpl implements Baggage {\n  private _entries: Map<string, BaggageEntry>;\n\n  constructor(entries?: Map<string, BaggageEntry>) {\n    this._entries = entries ? new Map(entries) : new Map();\n  }\n\n  getEntry(key: string): BaggageEntry | undefined {\n    const entry = this._entries.get(key);\n    if (!entry) {\n      return undefined;\n    }\n\n    return Object.assign({}, entry);\n  }\n\n  getAllEntries(): [string, BaggageEntry][] {\n    return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);\n  }\n\n  setEntry(key: string, entry: BaggageEntry): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.set(key, entry);\n    return newBaggage;\n  }\n\n  removeEntry(key: string): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.delete(key);\n    return newBaggage;\n  }\n\n  removeEntries(...keys: string[]): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    for (const key of keys) {\n      newBaggage._entries.delete(key);\n    }\n    return newBaggage;\n  }\n\n  clear(): BaggageImpl {\n    return new BaggageImpl();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Symbol used to make BaggageEntryMetadata an opaque type\n */\nexport const baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagAPI } from '../api/diag';\nimport { BaggageImpl } from './internal/baggage-impl';\nimport { baggageEntryMetadataSymbol } from './internal/symbol';\nimport { Baggage, BaggageEntry, BaggageEntryMetadata } from './types';\n\nconst diag = DiagAPI.instance();\n\n/**\n * Create a new Baggage with optional entries\n *\n * @param entries An array of baggage entries the new baggage should contain\n */\nexport function createBaggage(\n  entries: Record<string, BaggageEntry> = {}\n): Baggage {\n  return new BaggageImpl(new Map(Object.entries(entries)));\n}\n\n/**\n * Create a serializable BaggageEntryMetadata object from a string.\n *\n * @param str string metadata. Format is currently not defined by the spec and has no special meaning.\n *\n */\nexport function baggageEntryMetadataFromString(\n  str: string\n): BaggageEntryMetadata {\n  if (typeof str !== 'string') {\n    diag.error(\n      `Cannot create baggage metadata from unknown type: ${typeof str}`\n    );\n    str = '';\n  }\n\n  return {\n    __TYPE__: baggageEntryMetadataSymbol,\n    toString() {\n      return str;\n    },\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter } from './Meter';\nimport {\n  BatchObservableCallback,\n  Counter,\n  Gauge,\n  Histogram,\n  MetricAttributes,\n  MetricOptions,\n  Observable,\n  ObservableCallback,\n  ObservableCounter,\n  ObservableGauge,\n  ObservableUpDownCounter,\n  UpDownCounter,\n} from './Metric';\n\n/**\n * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses\n * constant NoopMetrics for all of its methods.\n */\nexport class NoopMeter implements Meter {\n  constructor() {}\n\n  /**\n   * @see {@link Meter.createGauge}\n   */\n  createGauge(_name: string, _options?: MetricOptions): Gauge {\n    return NOOP_GAUGE_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createHistogram}\n   */\n  createHistogram(_name: string, _options?: MetricOptions): Histogram {\n    return NOOP_HISTOGRAM_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createCounter}\n   */\n  createCounter(_name: string, _options?: MetricOptions): Counter {\n    return NOOP_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createUpDownCounter}\n   */\n  createUpDownCounter(_name: string, _options?: MetricOptions): UpDownCounter {\n    return NOOP_UP_DOWN_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableGauge}\n   */\n  createObservableGauge(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableGauge {\n    return NOOP_OBSERVABLE_GAUGE_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableCounter}\n   */\n  createObservableCounter(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableCounter {\n    return NOOP_OBSERVABLE_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableUpDownCounter}\n   */\n  createObservableUpDownCounter(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableUpDownCounter {\n    return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.addBatchObservableCallback}\n   */\n  addBatchObservableCallback(\n    _callback: BatchObservableCallback,\n    _observables: Observable[]\n  ): void {}\n\n  /**\n   * @see {@link Meter.removeBatchObservableCallback}\n   */\n  removeBatchObservableCallback(_callback: BatchObservableCallback): void {}\n}\n\nexport class NoopMetric {}\n\nexport class NoopCounterMetric extends NoopMetric implements Counter {\n  add(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopUpDownCounterMetric\n  extends NoopMetric\n  implements UpDownCounter\n{\n  add(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopGaugeMetric extends NoopMetric implements Gauge {\n  record(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopHistogramMetric extends NoopMetric implements Histogram {\n  record(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopObservableMetric {\n  addCallback(_callback: ObservableCallback) {}\n\n  removeCallback(_callback: ObservableCallback) {}\n}\n\nexport class NoopObservableCounterMetric\n  extends NoopObservableMetric\n  implements ObservableCounter {}\n\nexport class NoopObservableGaugeMetric\n  extends NoopObservableMetric\n  implements ObservableGauge {}\n\nexport class NoopObservableUpDownCounterMetric\n  extends NoopObservableMetric\n  implements ObservableUpDownCounter {}\n\nexport const NOOP_METER = new NoopMeter();\n\n// Synchronous instruments\nexport const NOOP_COUNTER_METRIC = new NoopCounterMetric();\nexport const NOOP_GAUGE_METRIC = new NoopGaugeMetric();\nexport const NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();\nexport const NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();\n\n// Asynchronous instruments\nexport const NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();\nexport const NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();\nexport const NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =\n  new NoopObservableUpDownCounterMetric();\n\n/**\n * Create a no-op Meter\n */\nexport function createNoopMeter(): Meter {\n  return NOOP_METER;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes, AttributeValue } from '../common/Attributes';\nimport { Context } from '../context/types';\nimport { BatchObservableResult, ObservableResult } from './ObservableResult';\n\n/**\n * Advisory options influencing aggregation configuration parameters.\n * @experimental\n */\nexport interface MetricAdvice {\n  /**\n   * Hint the explicit bucket boundaries for SDK if the metric is been\n   * aggregated with a HistogramAggregator.\n   */\n  explicitBucketBoundaries?: number[];\n}\n\n/**\n * Options needed for metric creation\n */\nexport interface MetricOptions {\n  /**\n   * The description of the Metric.\n   * @default ''\n   */\n  description?: string;\n\n  /**\n   * The unit of the Metric values.\n   * @default ''\n   */\n  unit?: string;\n\n  /**\n   * Indicates the type of the recorded value.\n   * @default {@link ValueType.DOUBLE}\n   */\n  valueType?: ValueType;\n\n  /**\n   * The advice influencing aggregation configuration parameters.\n   * @experimental\n   */\n  advice?: MetricAdvice;\n}\n\n/** The Type of value. It describes how the data is reported. */\nexport enum ValueType {\n  INT,\n  DOUBLE,\n}\n\n/**\n * Counter is the most common synchronous instrument. This instrument supports\n * an `Add(increment)` function for reporting a sum, and is restricted to\n * non-negative increments. The default aggregation is Sum, as for any additive\n * instrument.\n *\n * Example uses for Counter:\n * <ol>\n *   <li> count the number of bytes received. </li>\n *   <li> count the number of requests completed. </li>\n *   <li> count the number of accounts created. </li>\n *   <li> count the number of checkpoints run. </li>\n *   <li> count the number of 5xx errors. </li>\n * <ol>\n */\nexport interface Counter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs must not be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface UpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs may be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface Gauge<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Records a measurement.\n   */\n  record(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface Histogram<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Records a measurement. Value of the measurement must not be negative.\n   */\n  record(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\n/**\n * @deprecated please use {@link Attributes}\n */\nexport type MetricAttributes = Attributes;\n\n/**\n * @deprecated please use {@link AttributeValue}\n */\nexport type MetricAttributeValue = AttributeValue;\n\n/**\n * The observable callback for Observable instruments.\n */\nexport type ObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: ObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\n/**\n * The observable callback for a batch of Observable instruments.\n */\nexport type BatchObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: BatchObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\nexport interface Observable<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Sets up a function that will be called whenever a metric collection is initiated.\n   *\n   * If the function is already in the list of callbacks for this Observable, the function is not added a second time.\n   */\n  addCallback(callback: ObservableCallback<AttributesTypes>): void;\n\n  /**\n   * Removes a callback previously registered with {@link Observable.addCallback}.\n   */\n  removeCallback(callback: ObservableCallback<AttributesTypes>): void;\n}\n\nexport type ObservableCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableUpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableGauge<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\n\n/**\n * Injects `Context` into and extracts it from carriers that travel\n * in-band across process boundaries. Encoding is expected to conform to the\n * HTTP Header Field semantics. Values are often encoded as RPC/HTTP request\n * headers.\n *\n * The carrier of propagated data on both the client (injector) and server\n * (extractor) side is usually an object such as http headers. Propagation is\n * usually implemented via library-specific request interceptors, where the\n * client-side injects values and the server-side extracts them.\n */\nexport interface TextMapPropagator<Carrier = any> {\n  /**\n   * Injects values from a given `Context` into a carrier.\n   *\n   * OpenTelemetry defines a common set of format values (TextMapPropagator),\n   * and each has an expected `carrier` type.\n   *\n   * @param context the Context from which to extract values to transmit over\n   *     the wire.\n   * @param carrier the carrier of propagation fields, such as http request\n   *     headers.\n   * @param setter an optional {@link TextMapSetter}. If undefined, values will be\n   *     set by direct object assignment.\n   */\n  inject(\n    context: Context,\n    carrier: Carrier,\n    setter: TextMapSetter<Carrier>\n  ): void;\n\n  /**\n   * Given a `Context` and a carrier, extract context values from a\n   * carrier and return a new context, created from the old context, with the\n   * extracted values.\n   *\n   * @param context the Context from which to extract values to transmit over\n   *     the wire.\n   * @param carrier the carrier of propagation fields, such as http request\n   *     headers.\n   * @param getter an optional {@link TextMapGetter}. If undefined, keys will be all\n   *     own properties, and keys will be accessed by direct object access.\n   */\n  extract(\n    context: Context,\n    carrier: Carrier,\n    getter: TextMapGetter<Carrier>\n  ): Context;\n\n  /**\n   * Return a list of all fields which may be used by the propagator.\n   */\n  fields(): string[];\n}\n\n/**\n * A setter is specified by the caller to define a specific method\n * to set key/value pairs on the carrier within a propagator.\n */\nexport interface TextMapSetter<Carrier = any> {\n  /**\n   * Callback used to set a key/value pair on an object.\n   *\n   * Should be called by the propagator each time a key/value pair\n   * should be set, and should set that key/value pair on the propagator.\n   *\n   * @param carrier object or class which carries key/value pairs\n   * @param key string key to modify\n   * @param value value to be set to the key on the carrier\n   */\n  set(carrier: Carrier, key: string, value: string): void;\n}\n\n/**\n * A getter is specified by the caller to define a specific method\n * to get the value of a key from a carrier.\n */\nexport interface TextMapGetter<Carrier = any> {\n  /**\n   * Get a list of all keys available on the carrier.\n   *\n   * @param carrier\n   */\n  keys(carrier: Carrier): string[];\n\n  /**\n   * Get the value of a specific key from the carrier.\n   *\n   * @param carrier\n   * @param key\n   */\n  get(carrier: Carrier, key: string): undefined | string | string[];\n}\n\nexport const defaultTextMapGetter: TextMapGetter = {\n  get(carrier, key) {\n    if (carrier == null) {\n      return undefined;\n    }\n    return carrier[key];\n  },\n\n  keys(carrier) {\n    if (carrier == null) {\n      return [];\n    }\n    return Object.keys(carrier);\n  },\n};\n\nexport const defaultTextMapSetter: TextMapSetter = {\n  set(carrier, key, value) {\n    if (carrier == null) {\n      return;\n    }\n\n    carrier[key] = value;\n  },\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanAttributes } from './attributes';\nimport { TraceState } from './trace_state';\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<SpanAttributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';\nconst VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;\nconst VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;\nconst VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);\nconst VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\nconst INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\n\n/**\n * Key is opaque string up to 256 characters printable. It MUST begin with a\n * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,\n * underscores _, dashes -, asterisks *, and forward slashes /.\n * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the\n * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.\n * see https://www.w3.org/TR/trace-context/#key\n */\nexport function validateKey(key: string): boolean {\n  return VALID_KEY_REGEX.test(key);\n}\n\n/**\n * Value is opaque string up to 256 characters printable ASCII RFC0020\n * characters (i.e., the range 0x20 to 0x7E) except comma , and =.\n */\nexport function validateValue(value: string): boolean {\n  return (\n    VALID_VALUE_BASE_REGEX.test(value) &&\n    !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value)\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TraceState } from '../trace_state';\nimport { validateKey, validateValue } from './tracestate-validators';\n\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceStateImpl implements TraceState {\n  private _internalState: Map<string, string> = new Map();\n\n  constructor(rawTraceState?: string) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  set(key: string, value: string): TraceStateImpl {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n\n  unset(key: string): TraceStateImpl {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n\n  get(key: string): string | undefined {\n    return this._internalState.get(key);\n  }\n\n  serialize(): string {\n    return this._keys()\n      .reduce((agg: string[], key) => {\n        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n        return agg;\n      }, [])\n      .join(LIST_MEMBERS_SEPARATOR);\n  }\n\n  private _parse(rawTraceState: string) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState\n      .split(LIST_MEMBERS_SEPARATOR)\n      .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n      .reduce((agg: Map<string, string>, part: string) => {\n        const listMember = part.trim(); // Optional Whitespace (OWS) handling\n        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n        if (i !== -1) {\n          const key = listMember.slice(0, i);\n          const value = listMember.slice(i + 1, part.length);\n          if (validateKey(key) && validateValue(value)) {\n            agg.set(key, value);\n          } else {\n            // TODO: Consider to add warning log\n          }\n        }\n        return agg;\n      }, new Map());\n\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(\n        Array.from(this._internalState.entries())\n          .reverse() // Use reverse same as original tracestate parse chain\n          .slice(0, MAX_TRACE_STATE_ITEMS)\n      );\n    }\n  }\n\n  private _keys(): string[] {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n\n  private _clone(): TraceStateImpl {\n    const traceState = new TraceStateImpl();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ContextAPI } from './api/context';\n/** Entrypoint for context API */\nexport const context = ContextAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { DiagAPI } from './api/diag';\n/**\n * Entrypoint for Diag API.\n * Defines Diagnostic handler used for internal diagnostic logging operations.\n * The default provides a Noop DiagLogger implementation which may be changed via the\n * diag.setLogger(logger: DiagLogger) function.\n */\nexport const diag = DiagAPI.instance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter, MeterOptions } from './Meter';\nimport { MeterProvider } from './MeterProvider';\nimport { NOOP_METER } from './NoopMeter';\n\n/**\n * An implementation of the {@link MeterProvider} which returns an impotent Meter\n * for all calls to `getMeter`\n */\nexport class NoopMeterProvider implements MeterProvider {\n  getMeter(_name: string, _version?: string, _options?: MeterOptions): Meter {\n    return NOOP_METER;\n  }\n}\n\nexport const NOOP_METER_PROVIDER = new NoopMeterProvider();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter, MeterOptions } from '../metrics/Meter';\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { NOOP_METER_PROVIDER } from '../metrics/NoopMeterProvider';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'metrics';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Metrics API\n */\nexport class MetricsAPI {\n  private static _instance?: MetricsAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Metrics API */\n  public static getInstance(): MetricsAPI {\n    if (!this._instance) {\n      this._instance = new MetricsAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global meter provider.\n   * Returns true if the meter provider was successfully registered, else false.\n   */\n  public setGlobalMeterProvider(provider: MeterProvider): boolean {\n    return registerGlobal(API_NAME, provider, DiagAPI.instance());\n  }\n\n  /**\n   * Returns the global meter provider.\n   */\n  public getMeterProvider(): MeterProvider {\n    return getGlobal(API_NAME) || NOOP_METER_PROVIDER;\n  }\n\n  /**\n   * Returns a meter from the global meter provider.\n   */\n  public getMeter(\n    name: string,\n    version?: string,\n    options?: MeterOptions\n  ): Meter {\n    return this.getMeterProvider().getMeter(name, version, options);\n  }\n\n  /** Remove the global meter provider */\n  public disable(): void {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { MetricsAPI } from './api/metrics';\n/** Entrypoint for metrics API */\nexport const metrics = MetricsAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { TextMapPropagator } from './TextMapPropagator';\n\n/**\n * No-op implementations of {@link TextMapPropagator}.\n */\nexport class NoopTextMapPropagator implements TextMapPropagator {\n  /** Noop inject function does nothing */\n  inject(_context: Context, _carrier: unknown): void {}\n  /** Noop extract function does nothing and returns the input context */\n  extract(context: Context, _carrier: unknown): Context {\n    return context;\n  }\n  fields(): string[] {\n    return [];\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Baggage } from './types';\n\n/**\n * Baggage key\n */\nconst BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');\n\n/**\n * Retrieve the current baggage from the given context\n *\n * @param {Context} Context that manage all context values\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getBaggage(context: Context): Baggage | undefined {\n  return (context.getValue(BAGGAGE_KEY) as Baggage) || undefined;\n}\n\n/**\n * Retrieve the current baggage from the active/current context\n *\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getActiveBaggage(): Baggage | undefined {\n  return getBaggage(ContextAPI.getInstance().active());\n}\n\n/**\n * Store a baggage in the given context\n *\n * @param {Context} Context that manage all context values\n * @param {Baggage} baggage that will be set in the actual context\n */\nexport function setBaggage(context: Context, baggage: Baggage): Context {\n  return context.setValue(BAGGAGE_KEY, baggage);\n}\n\n/**\n * Delete the baggage stored in the given context\n *\n * @param {Context} Context that manage all context values\n */\nexport function deleteBaggage(context: Context): Context {\n  return context.deleteValue(BAGGAGE_KEY);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { NoopTextMapPropagator } from '../propagation/NoopTextMapPropagator';\nimport {\n  defaultTextMapGetter,\n  defaultTextMapSetter,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n} from '../propagation/TextMapPropagator';\nimport {\n  getBaggage,\n  getActiveBaggage,\n  setBaggage,\n  deleteBaggage,\n} from '../baggage/context-helpers';\nimport { createBaggage } from '../baggage/utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'propagation';\nconst NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Propagation API\n */\nexport class PropagationAPI {\n  private static _instance?: PropagationAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Propagator API */\n  public static getInstance(): PropagationAPI {\n    if (!this._instance) {\n      this._instance = new PropagationAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current propagator.\n   *\n   * @returns true if the propagator was successfully registered, else false\n   */\n  public setGlobalPropagator(propagator: TextMapPropagator): boolean {\n    return registerGlobal(API_NAME, propagator, DiagAPI.instance());\n  }\n\n  /**\n   * Inject context into a carrier to be propagated inter-process\n   *\n   * @param context Context carrying tracing data to inject\n   * @param carrier carrier to inject context into\n   * @param setter Function used to set values on the carrier\n   */\n  public inject<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    setter: TextMapSetter<Carrier> = defaultTextMapSetter\n  ): void {\n    return this._getGlobalPropagator().inject(context, carrier, setter);\n  }\n\n  /**\n   * Extract context from a carrier\n   *\n   * @param context Context which the newly created context will inherit from\n   * @param carrier Carrier to extract context from\n   * @param getter Function used to extract keys from a carrier\n   */\n  public extract<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    getter: TextMapGetter<Carrier> = defaultTextMapGetter\n  ): Context {\n    return this._getGlobalPropagator().extract(context, carrier, getter);\n  }\n\n  /**\n   * Return a list of all fields which may be used by the propagator.\n   */\n  public fields(): string[] {\n    return this._getGlobalPropagator().fields();\n  }\n\n  /** Remove the global propagator */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n\n  public createBaggage = createBaggage;\n\n  public getBaggage = getBaggage;\n\n  public getActiveBaggage = getActiveBaggage;\n\n  public setBaggage = setBaggage;\n\n  public deleteBaggage = deleteBaggage;\n\n  private _getGlobalPropagator(): TextMapPropagator {\n    return getGlobal(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { PropagationAPI } from './api/propagation';\n/** Entrypoint for propagation API */\nexport const propagation = PropagationAPI.getInstance();\n"],
  "mappings": "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",
  "names": ["name", "getContext", "name", "getVercelOidcToken", "_AISDKError", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_TypeValidationError", "_a", "symbol", "_a", "_b", "APICallError", "validator", "TypeValidationError", "getOriginalFetch", "getOriginalFetch", "APICallError", "APICallError", "APICallError", "_a", "_b", "ZodFirstPartyTypeKind", "types", "x", "jsonSchema", "name", "schema", "zodSchema", "jsonSchema", "import_oidc", "marker", "symbol", "_a", "name", "_b", "lazyValidator", "zodSchema", "z", "safeValidateTypes", "resolve", "createJsonResponseHandler", "createJsonErrorResponseHandler", "postJsonToApi", "combineHeaders", "VERSION", "SpanStatusCode", "VERSION", "isCompatible", "VERSION", "VERSION", "diag", "_a", "_b", "BaseContext", "context", "NoopContextManager", "DiagComponentLogger", "__spreadArray", "__read", "DiagLogLevel", "DiagAPI", "__spreadArray", "__read", "_a", "_b", "API_NAME", "ContextAPI", "context", "_a", "__spreadArray", "__read", "TraceFlags", "NonRecordingSpan", "context", "_a", "NoopTracer", "name", "context", "ProxyTracer", "name", "context", "NoopTracerProvider", "ProxyTracerProvider", "name", "_a", "API_NAME", "TraceAPI", "name", "BaggageImpl", "_a", "_b", "__read", "NoopMeter", "NoopMetric", "NoopCounterMetric", "NoopUpDownCounterMetric", "NoopGaugeMetric", "NoopHistogramMetric", "NoopObservableMetric", "NoopObservableCounterMetric", "NoopObservableGaugeMetric", "NoopObservableUpDownCounterMetric", "ValueType", "SamplingDecision", "SpanKind", "TraceStateImpl", "diag", "NoopMeterProvider", "API_NAME", "MetricsAPI", "name", "NoopTextMapPropagator", "context", "context", "API_NAME", "PropagationAPI", "context"]
}
