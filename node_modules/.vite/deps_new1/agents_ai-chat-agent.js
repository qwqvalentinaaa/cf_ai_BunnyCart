import {
  Agent,
  MessageType,
  nanoid
} from "./chunk-6BEZ37YT.js";
import "./chunk-DA4ZTVEQ.js";
import "./chunk-4ENGM5Y2.js";
import "./chunk-LM3UEMPC.js";
import "./chunk-G3PMV62Z.js";

// node_modules/agents/dist/ai-chat-v5-migration-BSiGZmYU.js
var STATE_MAP = {
  "partial-call": "input-streaming",
  call: "input-available",
  result: "output-available",
  error: "output-error"
};
function isUIMessage(message) {
  return typeof message === "object" && message !== null && "parts" in message && Array.isArray(message.parts);
}
function autoTransformMessage(message, index = 0) {
  if (isUIMessage(message)) return message;
  const parts = [];
  if (message.reasoning) parts.push({
    type: "reasoning",
    text: message.reasoning
  });
  if (message.toolInvocations && Array.isArray(message.toolInvocations)) message.toolInvocations.forEach((inv) => {
    if (typeof inv === "object" && inv !== null && "toolName" in inv) {
      const invObj = inv;
      parts.push({
        type: `tool-${invObj.toolName}`,
        toolCallId: invObj.toolCallId,
        state: STATE_MAP[invObj.state] || "input-available",
        input: invObj.args,
        output: invObj.result !== void 0 ? invObj.result : null
      });
    }
  });
  if (message.parts && Array.isArray(message.parts)) message.parts.forEach((part) => {
    if (typeof part === "object" && part !== null && "type" in part) {
      const partObj = part;
      if (partObj.type === "file") parts.push({
        type: "file",
        url: partObj.url || (partObj.data ? `data:${partObj.mimeType || partObj.mediaType};base64,${partObj.data}` : void 0),
        mediaType: partObj.mediaType || partObj.mimeType,
        filename: partObj.filename
      });
    }
  });
  if (Array.isArray(message.content)) message.content.forEach((item) => {
    if (typeof item === "object" && item !== null && "text" in item) {
      const itemObj = item;
      parts.push({
        type: itemObj.type || "text",
        text: itemObj.text || ""
      });
    }
  });
  if (!parts.length && message.content !== void 0) parts.push({
    type: "text",
    text: typeof message.content === "string" ? message.content : JSON.stringify(message.content)
  });
  if (!parts.length) parts.push({
    type: "text",
    text: typeof message === "string" ? message : JSON.stringify(message)
  });
  return {
    id: message.id || `msg-${index}`,
    role: message.role === "data" ? "system" : message.role || "user",
    parts
  };
}
function autoTransformMessages(messages) {
  return messages.map((msg, i) => autoTransformMessage(msg, i));
}

// node_modules/agents/dist/ai-chat-agent.js
var CHUNK_BUFFER_SIZE = 10;
var CHUNK_BUFFER_MAX_SIZE = 100;
var STREAM_STALE_THRESHOLD_MS = 300 * 1e3;
var CLEANUP_INTERVAL_MS = 600 * 1e3;
var CLEANUP_AGE_THRESHOLD_MS = 1440 * 60 * 1e3;
var decoder = new TextDecoder();
var AIChatAgent = class extends Agent {
  constructor(ctx, env) {
    super(ctx, env);
    this._activeStreamId = null;
    this._activeRequestId = null;
    this._streamChunkIndex = 0;
    this._chunkBuffer = [];
    this._isFlushingChunks = false;
    this._lastCleanupTime = 0;
    this.sql`create table if not exists cf_ai_chat_agent_messages (
      id text primary key,
      message text not null,
      created_at datetime default current_timestamp
    )`;
    this.sql`create table if not exists cf_ai_chat_stream_chunks (
      id text primary key,
      stream_id text not null,
      body text not null,
      chunk_index integer not null,
      created_at integer not null
    )`;
    this.sql`create table if not exists cf_ai_chat_stream_metadata (
      id text primary key,
      request_id text not null,
      status text not null,
      created_at integer not null,
      completed_at integer
    )`;
    this.sql`create index if not exists idx_stream_chunks_stream_id 
      on cf_ai_chat_stream_chunks(stream_id, chunk_index)`;
    this.messages = autoTransformMessages(this._loadMessagesFromDb());
    this._chatMessageAbortControllers = /* @__PURE__ */ new Map();
    this._restoreActiveStream();
    const _onConnect = this.onConnect.bind(this);
    this.onConnect = async (connection, ctx$1) => {
      if (this._activeStreamId) this._notifyStreamResuming(connection);
      return _onConnect(connection, ctx$1);
    };
    const _onMessage = this.onMessage.bind(this);
    this.onMessage = async (connection, message) => {
      if (typeof message === "string") {
        let data;
        try {
          data = JSON.parse(message);
        } catch (_error) {
          return _onMessage(connection, message);
        }
        if (data.type === MessageType.CF_AGENT_USE_CHAT_REQUEST && data.init.method === "POST") {
          const { body } = data.init;
          const { messages } = JSON.parse(body);
          const transformedMessages = autoTransformMessages(messages);
          this._broadcastChatMessage({
            messages: transformedMessages,
            type: MessageType.CF_AGENT_CHAT_MESSAGES
          }, [connection.id]);
          await this.persistMessages(transformedMessages, [connection.id]);
          this.observability?.emit({
            displayMessage: "Chat message request",
            id: data.id,
            payload: {},
            timestamp: Date.now(),
            type: "message:request"
          }, this.ctx);
          const chatMessageId = data.id;
          const abortSignal = this._getAbortSignal(chatMessageId);
          return this._tryCatchChat(async () => {
            const response = await this.onChatMessage(async (_finishResult) => {
              this._removeAbortController(chatMessageId);
              this.observability?.emit({
                displayMessage: "Chat message response",
                id: data.id,
                payload: {},
                timestamp: Date.now(),
                type: "message:response"
              }, this.ctx);
            }, abortSignal ? { abortSignal } : void 0);
            if (response) await this._reply(data.id, response);
            else {
              console.warn(`[AIChatAgent] onChatMessage returned no response for chatMessageId: ${chatMessageId}`);
              this._broadcastChatMessage({
                body: "No response was generated by the agent.",
                done: true,
                id: data.id,
                type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
              }, [connection.id]);
            }
          });
        }
        if (data.type === MessageType.CF_AGENT_CHAT_CLEAR) {
          this._destroyAbortControllers();
          this.sql`delete from cf_ai_chat_agent_messages`;
          this.sql`delete from cf_ai_chat_stream_chunks`;
          this.sql`delete from cf_ai_chat_stream_metadata`;
          this._activeStreamId = null;
          this._activeRequestId = null;
          this._streamChunkIndex = 0;
          this.messages = [];
          this._broadcastChatMessage({ type: MessageType.CF_AGENT_CHAT_CLEAR }, [connection.id]);
          return;
        }
        if (data.type === MessageType.CF_AGENT_CHAT_MESSAGES) {
          const transformedMessages = autoTransformMessages(data.messages);
          await this.persistMessages(transformedMessages, [connection.id]);
          return;
        }
        if (data.type === MessageType.CF_AGENT_CHAT_REQUEST_CANCEL) {
          this._cancelChatRequest(data.id);
          return;
        }
        if (data.type === MessageType.CF_AGENT_STREAM_RESUME_ACK) {
          if (this._activeStreamId && this._activeRequestId && this._activeRequestId === data.id) this._sendStreamChunks(connection, this._activeStreamId, this._activeRequestId);
          return;
        }
      }
      return _onMessage(connection, message);
    };
  }
  /**
  * Restore active stream state if the agent was restarted during streaming.
  * Called during construction to recover any interrupted streams.
  * Validates stream freshness to avoid sending stale resume notifications.
  */
  _restoreActiveStream() {
    const activeStreams = this.sql`
      select * from cf_ai_chat_stream_metadata 
      where status = 'streaming' 
      order by created_at desc 
      limit 1
    `;
    if (activeStreams && activeStreams.length > 0) {
      const stream = activeStreams[0];
      const streamAge = Date.now() - stream.created_at;
      if (streamAge > STREAM_STALE_THRESHOLD_MS) {
        this.sql`delete from cf_ai_chat_stream_chunks where stream_id = ${stream.id}`;
        this.sql`delete from cf_ai_chat_stream_metadata where id = ${stream.id}`;
        console.warn(`[AIChatAgent] Deleted stale stream ${stream.id} (age: ${Math.round(streamAge / 1e3)}s)`);
        return;
      }
      this._activeStreamId = stream.id;
      this._activeRequestId = stream.request_id;
      const lastChunk = this.sql`
        select max(chunk_index) as max_index 
        from cf_ai_chat_stream_chunks 
        where stream_id = ${this._activeStreamId}
      `;
      this._streamChunkIndex = lastChunk && lastChunk[0]?.max_index != null ? lastChunk[0].max_index + 1 : 0;
    }
  }
  /**
  * Notify a connection about an active stream that can be resumed.
  * The client should respond with CF_AGENT_STREAM_RESUME_ACK to receive chunks.
  * Uses in-memory state for request ID - no extra DB lookup needed.
  * @param connection - The WebSocket connection to notify
  */
  _notifyStreamResuming(connection) {
    if (!this._activeStreamId || !this._activeRequestId) return;
    connection.send(JSON.stringify({
      type: MessageType.CF_AGENT_STREAM_RESUMING,
      id: this._activeRequestId
    }));
  }
  /**
  * Send stream chunks to a connection after receiving ACK.
  * @param connection - The WebSocket connection
  * @param streamId - The stream to replay
  * @param requestId - The original request ID
  */
  _sendStreamChunks(connection, streamId, requestId) {
    this._flushChunkBuffer();
    const chunks = this.sql`
      select * from cf_ai_chat_stream_chunks 
      where stream_id = ${streamId} 
      order by chunk_index asc
    `;
    for (const chunk of chunks || []) connection.send(JSON.stringify({
      body: chunk.body,
      done: false,
      id: requestId,
      type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
    }));
    if (this._activeStreamId !== streamId) connection.send(JSON.stringify({
      body: "",
      done: true,
      id: requestId,
      type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
    }));
  }
  /**
  * Buffer a stream chunk for batch write to SQLite.
  * @param streamId - The stream this chunk belongs to
  * @param body - The serialized chunk body
  */
  _storeStreamChunk(streamId, body) {
    if (this._chunkBuffer.length >= CHUNK_BUFFER_MAX_SIZE) this._flushChunkBuffer();
    this._chunkBuffer.push({
      id: nanoid(),
      streamId,
      body,
      index: this._streamChunkIndex
    });
    this._streamChunkIndex++;
    if (this._chunkBuffer.length >= CHUNK_BUFFER_SIZE) this._flushChunkBuffer();
  }
  /**
  * Flush buffered chunks to SQLite in a single batch.
  * Uses a lock to prevent concurrent flush operations.
  */
  _flushChunkBuffer() {
    if (this._isFlushingChunks || this._chunkBuffer.length === 0) return;
    this._isFlushingChunks = true;
    try {
      const chunks = this._chunkBuffer;
      this._chunkBuffer = [];
      const now = Date.now();
      for (const chunk of chunks) this.sql`
          insert into cf_ai_chat_stream_chunks (id, stream_id, body, chunk_index, created_at)
          values (${chunk.id}, ${chunk.streamId}, ${chunk.body}, ${chunk.index}, ${now})
        `;
    } finally {
      this._isFlushingChunks = false;
    }
  }
  /**
  * Start tracking a new stream for resumable streaming.
  * Creates metadata entry in SQLite and sets up tracking state.
  * @param requestId - The unique ID of the chat request
  * @returns The generated stream ID
  */
  _startStream(requestId) {
    this._flushChunkBuffer();
    const streamId = nanoid();
    this._activeStreamId = streamId;
    this._activeRequestId = requestId;
    this._streamChunkIndex = 0;
    this.sql`
      insert into cf_ai_chat_stream_metadata (id, request_id, status, created_at)
      values (${streamId}, ${requestId}, 'streaming', ${Date.now()})
    `;
    return streamId;
  }
  /**
  * Mark a stream as completed and flush any pending chunks.
  * @param streamId - The stream to mark as completed
  */
  _completeStream(streamId) {
    this._flushChunkBuffer();
    this.sql`
      update cf_ai_chat_stream_metadata 
      set status = 'completed', completed_at = ${Date.now()} 
      where id = ${streamId}
    `;
    this._activeStreamId = null;
    this._activeRequestId = null;
    this._streamChunkIndex = 0;
    this._maybeCleanupOldStreams();
  }
  /**
  * Clean up old completed streams if enough time has passed since last cleanup.
  * This prevents database growth while avoiding cleanup overhead on every stream completion.
  */
  _maybeCleanupOldStreams() {
    const now = Date.now();
    if (now - this._lastCleanupTime < CLEANUP_INTERVAL_MS) return;
    this._lastCleanupTime = now;
    const cutoff = now - CLEANUP_AGE_THRESHOLD_MS;
    this.sql`
      delete from cf_ai_chat_stream_chunks 
      where stream_id in (
        select id from cf_ai_chat_stream_metadata 
        where status = 'completed' and completed_at < ${cutoff}
      )
    `;
    this.sql`
      delete from cf_ai_chat_stream_metadata 
      where status = 'completed' and completed_at < ${cutoff}
    `;
  }
  _broadcastChatMessage(message, exclude) {
    this.broadcast(JSON.stringify(message), exclude);
  }
  _loadMessagesFromDb() {
    return (this.sql`select * from cf_ai_chat_agent_messages order by created_at` || []).map((row) => {
      try {
        return JSON.parse(row.message);
      } catch (error) {
        console.error(`Failed to parse message ${row.id}:`, error);
        return null;
      }
    }).filter((msg) => msg !== null);
  }
  async onRequest(request) {
    return this._tryCatchChat(async () => {
      if (new URL(request.url).pathname.endsWith("/get-messages")) {
        const messages = this._loadMessagesFromDb();
        return Response.json(messages);
      }
      return super.onRequest(request);
    });
  }
  async _tryCatchChat(fn) {
    try {
      return await fn();
    } catch (e) {
      throw this.onError(e);
    }
  }
  /**
  * Handle incoming chat messages and generate a response
  * @param onFinish Callback to be called when the response is finished
  * @param options.signal A signal to pass to any child requests which can be used to cancel them
  * @returns Response to send to the client or undefined
  */
  async onChatMessage(onFinish, options) {
    throw new Error("recieved a chat message, override onChatMessage and return a Response to send to the client");
  }
  /**
  * Save messages on the server side
  * @param messages Chat messages to save
  */
  async saveMessages(messages) {
    await this.persistMessages(messages);
    await this._tryCatchChat(async () => {
      const response = await this.onChatMessage(() => {
      });
      if (response) this._reply(crypto.randomUUID(), response);
    });
  }
  async persistMessages(messages, excludeBroadcastIds = []) {
    for (const message of messages) this.sql`
        insert into cf_ai_chat_agent_messages (id, message)
        values (${message.id}, ${JSON.stringify(message)})
        on conflict(id) do update set message = excluded.message
      `;
    this.messages = autoTransformMessages(this._loadMessagesFromDb());
    this._broadcastChatMessage({
      messages,
      type: MessageType.CF_AGENT_CHAT_MESSAGES
    }, excludeBroadcastIds);
  }
  async _reply(id, response) {
    return this._tryCatchChat(async () => {
      if (!response.body) {
        this._broadcastChatMessage({
          body: "",
          done: true,
          id,
          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
        });
        return;
      }
      const streamId = this._startStream(id);
      const { getToolName, isToolUIPart, parsePartialJson } = await import("./dist-FE3V3CLB.js");
      const reader = response.body.getReader();
      const message = {
        id: `assistant_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`,
        role: "assistant",
        parts: []
      };
      let activeTextParts = {};
      let activeReasoningParts = {};
      const partialToolCalls = {};
      function updateDynamicToolPart(options) {
        const part = message.parts.find((part$1) => part$1.type === "dynamic-tool" && part$1.toolCallId === options.toolCallId);
        const anyOptions = options;
        const anyPart = part;
        if (part != null) {
          part.state = options.state;
          anyPart.toolName = options.toolName;
          anyPart.input = anyOptions.input;
          anyPart.output = anyOptions.output;
          anyPart.errorText = anyOptions.errorText;
          anyPart.rawInput = anyOptions.rawInput ?? anyPart.rawInput;
          anyPart.preliminary = anyOptions.preliminary;
          if (anyOptions.providerMetadata != null && part.state === "input-available") part.callProviderMetadata = anyOptions.providerMetadata;
        } else message.parts.push({
          type: "dynamic-tool",
          toolName: options.toolName,
          toolCallId: options.toolCallId,
          state: options.state,
          input: anyOptions.input,
          output: anyOptions.output,
          errorText: anyOptions.errorText,
          preliminary: anyOptions.preliminary,
          ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
        });
      }
      function updateToolPart(options) {
        const part = message.parts.find((part$1) => isToolUIPart(part$1) && part$1.toolCallId === options.toolCallId);
        const anyOptions = options;
        const anyPart = part;
        if (part != null) {
          part.state = options.state;
          anyPart.input = anyOptions.input;
          anyPart.output = anyOptions.output;
          anyPart.errorText = anyOptions.errorText;
          anyPart.rawInput = anyOptions.rawInput;
          anyPart.preliminary = anyOptions.preliminary;
          anyPart.providerExecuted = anyOptions.providerExecuted ?? part.providerExecuted;
          if (anyOptions.providerMetadata != null && part.state === "input-available") part.callProviderMetadata = anyOptions.providerMetadata;
        } else message.parts.push({
          type: `tool-${options.toolName}`,
          toolCallId: options.toolCallId,
          state: options.state,
          input: anyOptions.input,
          output: anyOptions.output,
          rawInput: anyOptions.rawInput,
          errorText: anyOptions.errorText,
          providerExecuted: anyOptions.providerExecuted,
          preliminary: anyOptions.preliminary,
          ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
        });
      }
      async function updateMessageMetadata(metadata) {
        if (metadata != null) message.metadata = message.metadata != null ? {
          ...message.metadata,
          ...metadata
        } : metadata;
      }
      let streamCompleted = false;
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            this._completeStream(streamId);
            streamCompleted = true;
            this._broadcastChatMessage({
              body: "",
              done: true,
              id,
              type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
            });
            break;
          }
          const chunk = decoder.decode(value);
          if ((response.headers.get("content-type") || "").includes("text/event-stream")) {
            const lines = chunk.split("\n");
            for (const line of lines) if (line.startsWith("data: ") && line !== "data: [DONE]") try {
              const data = JSON.parse(line.slice(6));
              switch (data.type) {
                case "text-start": {
                  const textPart = {
                    type: "text",
                    text: "",
                    providerMetadata: data.providerMetadata,
                    state: "streaming"
                  };
                  activeTextParts[data.id] = textPart;
                  message.parts.push(textPart);
                  break;
                }
                case "text-delta": {
                  const textPart = activeTextParts[data.id];
                  textPart.text += data.delta;
                  textPart.providerMetadata = data.providerMetadata ?? textPart.providerMetadata;
                  break;
                }
                case "text-end": {
                  const textPart = activeTextParts[data.id];
                  textPart.state = "done";
                  textPart.providerMetadata = data.providerMetadata ?? textPart.providerMetadata;
                  delete activeTextParts[data.id];
                  break;
                }
                case "reasoning-start": {
                  const reasoningPart = {
                    type: "reasoning",
                    text: "",
                    providerMetadata: data.providerMetadata,
                    state: "streaming"
                  };
                  activeReasoningParts[data.id] = reasoningPart;
                  message.parts.push(reasoningPart);
                  break;
                }
                case "reasoning-delta": {
                  const reasoningPart = activeReasoningParts[data.id];
                  reasoningPart.text += data.delta;
                  reasoningPart.providerMetadata = data.providerMetadata ?? reasoningPart.providerMetadata;
                  break;
                }
                case "reasoning-end": {
                  const reasoningPart = activeReasoningParts[data.id];
                  reasoningPart.providerMetadata = data.providerMetadata ?? reasoningPart.providerMetadata;
                  reasoningPart.state = "done";
                  delete activeReasoningParts[data.id];
                  break;
                }
                case "file":
                  message.parts.push({
                    type: "file",
                    mediaType: data.mediaType,
                    url: data.url
                  });
                  break;
                case "source-url":
                  message.parts.push({
                    type: "source-url",
                    sourceId: data.sourceId,
                    url: data.url,
                    title: data.title,
                    providerMetadata: data.providerMetadata
                  });
                  break;
                case "source-document":
                  message.parts.push({
                    type: "source-document",
                    sourceId: data.sourceId,
                    mediaType: data.mediaType,
                    title: data.title,
                    filename: data.filename,
                    providerMetadata: data.providerMetadata
                  });
                  break;
                case "tool-input-start": {
                  const toolInvocations = message.parts.filter(isToolUIPart);
                  partialToolCalls[data.toolCallId] = {
                    text: "",
                    toolName: data.toolName,
                    index: toolInvocations.length,
                    dynamic: data.dynamic
                  };
                  if (data.dynamic) updateDynamicToolPart({
                    toolCallId: data.toolCallId,
                    toolName: data.toolName,
                    state: "input-streaming",
                    input: void 0
                  });
                  else updateToolPart({
                    toolCallId: data.toolCallId,
                    toolName: data.toolName,
                    state: "input-streaming",
                    input: void 0
                  });
                  break;
                }
                case "tool-input-delta": {
                  const partialToolCall = partialToolCalls[data.toolCallId];
                  partialToolCall.text += data.inputTextDelta;
                  const partialArgs = (await parsePartialJson(partialToolCall.text)).value;
                  if (partialToolCall.dynamic) updateDynamicToolPart({
                    toolCallId: data.toolCallId,
                    toolName: partialToolCall.toolName,
                    state: "input-streaming",
                    input: partialArgs
                  });
                  else updateToolPart({
                    toolCallId: data.toolCallId,
                    toolName: partialToolCall.toolName,
                    state: "input-streaming",
                    input: partialArgs
                  });
                  break;
                }
                case "tool-input-available":
                  if (data.dynamic) updateDynamicToolPart({
                    toolCallId: data.toolCallId,
                    toolName: data.toolName,
                    state: "input-available",
                    input: data.input,
                    providerMetadata: data.providerMetadata
                  });
                  else updateToolPart({
                    toolCallId: data.toolCallId,
                    toolName: data.toolName,
                    state: "input-available",
                    input: data.input,
                    providerExecuted: data.providerExecuted,
                    providerMetadata: data.providerMetadata
                  });
                  break;
                case "tool-input-error":
                  if (data.dynamic) updateDynamicToolPart({
                    toolCallId: data.toolCallId,
                    toolName: data.toolName,
                    state: "output-error",
                    input: data.input,
                    errorText: data.errorText,
                    providerMetadata: data.providerMetadata
                  });
                  else updateToolPart({
                    toolCallId: data.toolCallId,
                    toolName: data.toolName,
                    state: "output-error",
                    input: void 0,
                    rawInput: data.input,
                    errorText: data.errorText,
                    providerExecuted: data.providerExecuted,
                    providerMetadata: data.providerMetadata
                  });
                  break;
                case "tool-output-available":
                  if (data.dynamic) {
                    const toolInvocation = message.parts.filter((part) => part.type === "dynamic-tool").find((invocation) => invocation.toolCallId === data.toolCallId);
                    if (!toolInvocation) throw new Error("Tool invocation not found");
                    updateDynamicToolPart({
                      toolCallId: data.toolCallId,
                      toolName: toolInvocation.toolName,
                      state: "output-available",
                      input: toolInvocation.input,
                      output: data.output,
                      preliminary: data.preliminary
                    });
                  } else {
                    const toolInvocation = message.parts.filter(isToolUIPart).find((invocation) => invocation.toolCallId === data.toolCallId);
                    if (!toolInvocation) throw new Error("Tool invocation not found");
                    updateToolPart({
                      toolCallId: data.toolCallId,
                      toolName: getToolName(toolInvocation),
                      state: "output-available",
                      input: toolInvocation.input,
                      output: data.output,
                      providerExecuted: data.providerExecuted,
                      preliminary: data.preliminary
                    });
                  }
                  break;
                case "tool-output-error":
                  if (data.dynamic) {
                    const toolInvocation = message.parts.filter((part) => part.type === "dynamic-tool").find((invocation) => invocation.toolCallId === data.toolCallId);
                    if (!toolInvocation) throw new Error("Tool invocation not found");
                    updateDynamicToolPart({
                      toolCallId: data.toolCallId,
                      toolName: toolInvocation.toolName,
                      state: "output-error",
                      input: toolInvocation.input,
                      errorText: data.errorText
                    });
                  } else {
                    const toolInvocation = message.parts.filter(isToolUIPart).find((invocation) => invocation.toolCallId === data.toolCallId);
                    if (!toolInvocation) throw new Error("Tool invocation not found");
                    updateToolPart({
                      toolCallId: data.toolCallId,
                      toolName: getToolName(toolInvocation),
                      state: "output-error",
                      input: toolInvocation.input,
                      rawInput: "rawInput" in toolInvocation ? toolInvocation.rawInput : void 0,
                      errorText: data.errorText
                    });
                  }
                  break;
                case "start-step":
                  message.parts.push({ type: "step-start" });
                  break;
                case "finish-step":
                  activeTextParts = {};
                  activeReasoningParts = {};
                  break;
                case "start":
                  if (data.messageId != null) message.id = data.messageId;
                  await updateMessageMetadata(data.messageMetadata);
                  break;
                case "finish":
                  await updateMessageMetadata(data.messageMetadata);
                  break;
                case "message-metadata":
                  await updateMessageMetadata(data.messageMetadata);
                  break;
                case "error":
                  this._broadcastChatMessage({
                    error: true,
                    body: data.errorText ?? JSON.stringify(data),
                    done: false,
                    id,
                    type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
                  });
                  break;
              }
              let eventToSend = data;
              if (data.type === "finish" && "finishReason" in data) {
                const { finishReason, ...rest } = data;
                eventToSend = {
                  ...rest,
                  type: "finish",
                  messageMetadata: { finishReason }
                };
              }
              const chunkBody = JSON.stringify(eventToSend);
              this._storeStreamChunk(streamId, chunkBody);
              this._broadcastChatMessage({
                body: chunkBody,
                done: false,
                id,
                type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
              });
            } catch (_error) {
            }
          } else if (chunk.length > 0) {
            message.parts.push({
              type: "text",
              text: chunk
            });
            const chunkBody = JSON.stringify({
              type: "text-delta",
              delta: chunk
            });
            this._storeStreamChunk(streamId, chunkBody);
            this._broadcastChatMessage({
              body: chunkBody,
              done: false,
              id,
              type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
            });
          }
        }
      } catch (error) {
        if (!streamCompleted) {
          this._markStreamError(streamId);
          this._broadcastChatMessage({
            body: error instanceof Error ? error.message : "Stream error",
            done: true,
            error: true,
            id,
            type: MessageType.CF_AGENT_USE_CHAT_RESPONSE
          });
        }
        throw error;
      } finally {
        reader.releaseLock();
      }
      if (message.parts.length > 0) await this.persistMessages([...this.messages, message]);
    });
  }
  /**
  * Mark a stream as errored and clean up state.
  * @param streamId - The stream to mark as errored
  */
  _markStreamError(streamId) {
    this._flushChunkBuffer();
    this.sql`
      update cf_ai_chat_stream_metadata 
      set status = 'error', completed_at = ${Date.now()} 
      where id = ${streamId}
    `;
    this._activeStreamId = null;
    this._activeRequestId = null;
    this._streamChunkIndex = 0;
  }
  /**
  * For the given message id, look up its associated AbortController
  * If the AbortController does not exist, create and store one in memory
  *
  * returns the AbortSignal associated with the AbortController
  */
  _getAbortSignal(id) {
    if (typeof id !== "string") return;
    if (!this._chatMessageAbortControllers.has(id)) this._chatMessageAbortControllers.set(id, new AbortController());
    return this._chatMessageAbortControllers.get(id)?.signal;
  }
  /**
  * Remove an abort controller from the cache of pending message responses
  */
  _removeAbortController(id) {
    this._chatMessageAbortControllers.delete(id);
  }
  /**
  * Propagate an abort signal for any requests associated with the given message id
  */
  _cancelChatRequest(id) {
    if (this._chatMessageAbortControllers.has(id)) this._chatMessageAbortControllers.get(id)?.abort();
  }
  /**
  * Abort all pending requests and clear the cache of AbortControllers
  */
  _destroyAbortControllers() {
    for (const controller of this._chatMessageAbortControllers.values()) controller?.abort();
    this._chatMessageAbortControllers.clear();
  }
  /**
  * When the DO is destroyed, cancel all pending requests and clean up resources
  */
  async destroy() {
    this._destroyAbortControllers();
    this._flushChunkBuffer();
    this.sql`drop table if exists cf_ai_chat_stream_chunks`;
    this.sql`drop table if exists cf_ai_chat_stream_metadata`;
    this._activeStreamId = null;
    this._activeRequestId = null;
    await super.destroy();
  }
};
export {
  AIChatAgent
};
//# sourceMappingURL=agents_ai-chat-agent.js.map
