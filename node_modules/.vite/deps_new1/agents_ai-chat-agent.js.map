{
  "version": 3,
  "sources": ["../../agents/src/ai-chat-v5-migration.ts", "../../agents/src/ai-chat-agent.ts"],
  "sourcesContent": ["import type { UIMessage } from \"ai\";\n\n/**\n * AI SDK v5 Migration following https://jhak.im/blog/ai-sdk-migration-handling-previously-saved-messages\n * Using exact types from the official AI SDK documentation\n */\n\n/**\n * AI SDK v5 Message Part types reference (from official AI SDK documentation)\n *\n * The migration logic below transforms legacy messages to match these official AI SDK v5 formats:\n * - TextUIPart: { type: \"text\", text: string, state?: \"streaming\" | \"done\" }\n * - ReasoningUIPart: { type: \"reasoning\", text: string, state?: \"streaming\" | \"done\", providerMetadata?: Record<string, unknown> }\n * - FileUIPart: { type: \"file\", mediaType: string, filename?: string, url: string }\n * - ToolUIPart: { type: `tool-${string}`, toolCallId: string, state: \"input-streaming\" | \"input-available\" | \"output-available\" | \"output-error\", input?: Record<string, unknown>, output?: unknown, errorText?: string, providerExecuted?: boolean }\n */\n\n/**\n * Tool invocation from v4 format\n */\ntype ToolInvocation = {\n  toolCallId: string;\n  toolName: string;\n  args: Record<string, unknown>;\n  result?: unknown;\n  state: \"partial-call\" | \"call\" | \"result\" | \"error\";\n};\n\n/**\n * Legacy part from v4 format\n */\ntype LegacyPart = {\n  type: string;\n  text?: string;\n  url?: string;\n  data?: string;\n  mimeType?: string;\n  mediaType?: string;\n  filename?: string;\n};\n\n/**\n * Legacy message format from AI SDK v4\n */\nexport type LegacyMessage = {\n  id?: string;\n  role: string;\n  content: string;\n  reasoning?: string;\n  toolInvocations?: ToolInvocation[];\n  parts?: LegacyPart[];\n  [key: string]: unknown;\n};\n\n/**\n * Corrupt content item\n */\ntype CorruptContentItem = {\n  type: string;\n  text: string;\n};\n\n/**\n * Corrupted message format - has content as array instead of parts\n */\nexport type CorruptArrayMessage = {\n  id?: string;\n  role: string;\n  content: CorruptContentItem[];\n  reasoning?: string;\n  toolInvocations?: ToolInvocation[];\n  [key: string]: unknown;\n};\n\n/**\n * Union type for messages that could be in any format\n */\nexport type MigratableMessage = LegacyMessage | CorruptArrayMessage | UIMessage;\n\n/**\n * Tool call state mapping for v4 to v5 migration\n */\nconst STATE_MAP = {\n  \"partial-call\": \"input-streaming\",\n  call: \"input-available\",\n  result: \"output-available\",\n  error: \"output-error\"\n} as const;\n\n/**\n * Checks if a message is already in the UIMessage format (has parts array)\n */\nexport function isUIMessage(message: unknown): message is UIMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"parts\" in message &&\n    Array.isArray((message as { parts: unknown }).parts)\n  );\n}\n\n/**\n * Type guard to check if a message is in legacy format (content as string)\n */\nfunction isLegacyMessage(message: unknown): message is LegacyMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"role\" in message &&\n    \"content\" in message &&\n    typeof (message as { role: unknown }).role === \"string\" &&\n    typeof (message as { content: unknown }).content === \"string\"\n  );\n}\n\n/**\n * Type guard to check if a message has corrupted array content format\n * Detects: {role: \"user\", content: [{type: \"text\", text: \"...\"}]}\n */\nfunction isCorruptArrayMessage(\n  message: unknown\n): message is CorruptArrayMessage {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"role\" in message &&\n    \"content\" in message &&\n    typeof (message as { role: unknown }).role === \"string\" &&\n    Array.isArray((message as { content: unknown }).content) &&\n    !(\"parts\" in message) // Ensure it's not already a UIMessage\n  );\n}\n\n/**\n * Internal message part type for transformation\n */\ntype TransformMessagePart = {\n  type: string;\n  text?: string;\n  toolCallId?: string;\n  state?: string;\n  input?: Record<string, unknown>;\n  output?: unknown;\n  url?: string;\n  mediaType?: string;\n  errorText?: string;\n  filename?: string;\n};\n\n/**\n * Input message that could be in any format - using unknown for flexibility\n */\ntype InputMessage = {\n  id?: string;\n  role?: string;\n  content?: unknown;\n  reasoning?: string;\n  toolInvocations?: unknown[];\n  parts?: unknown[];\n  [key: string]: unknown;\n};\n\n/**\n * Automatic message transformer following the blog post pattern\n * Handles comprehensive migration from AI SDK v4 to v5 format\n * @param message - Message in any legacy format\n * @param index - Index for ID generation fallback\n * @returns UIMessage in v5 format\n */\nexport function autoTransformMessage(\n  message: InputMessage,\n  index = 0\n): UIMessage {\n  // Already in v5 format\n  if (isUIMessage(message)) {\n    return message;\n  }\n\n  const parts: TransformMessagePart[] = [];\n\n  // Handle reasoning transformation\n  if (message.reasoning) {\n    parts.push({\n      type: \"reasoning\",\n      text: message.reasoning\n    });\n  }\n\n  // Handle tool invocations transformation\n  if (message.toolInvocations && Array.isArray(message.toolInvocations)) {\n    message.toolInvocations.forEach((inv: unknown) => {\n      if (typeof inv === \"object\" && inv !== null && \"toolName\" in inv) {\n        const invObj = inv as ToolInvocation;\n        parts.push({\n          type: `tool-${invObj.toolName}`,\n          toolCallId: invObj.toolCallId,\n          state:\n            STATE_MAP[invObj.state as keyof typeof STATE_MAP] ||\n            \"input-available\",\n          input: invObj.args,\n          output: invObj.result !== undefined ? invObj.result : null\n        });\n      }\n    });\n  }\n\n  // Handle file parts transformation\n  if (message.parts && Array.isArray(message.parts)) {\n    message.parts.forEach((part: unknown) => {\n      if (typeof part === \"object\" && part !== null && \"type\" in part) {\n        const partObj = part as LegacyPart;\n        if (partObj.type === \"file\") {\n          parts.push({\n            type: \"file\",\n            url:\n              partObj.url ||\n              (partObj.data\n                ? `data:${partObj.mimeType || partObj.mediaType};base64,${partObj.data}`\n                : undefined),\n            mediaType: partObj.mediaType || partObj.mimeType,\n            filename: partObj.filename\n          });\n        }\n      }\n    });\n  }\n\n  // Handle corrupt array format: {role: \"user\", content: [{type: \"text\", text: \"...\"}]}\n  if (Array.isArray(message.content)) {\n    message.content.forEach((item: unknown) => {\n      if (typeof item === \"object\" && item !== null && \"text\" in item) {\n        const itemObj = item as CorruptContentItem;\n        parts.push({\n          type: itemObj.type || \"text\",\n          text: itemObj.text || \"\"\n        });\n      }\n    });\n  }\n\n  // Fallback: convert plain content to text part\n  if (!parts.length && message.content !== undefined) {\n    parts.push({\n      type: \"text\",\n      text:\n        typeof message.content === \"string\"\n          ? message.content\n          : JSON.stringify(message.content)\n    });\n  }\n\n  // If still no parts, create a default text part\n  if (!parts.length) {\n    parts.push({\n      type: \"text\",\n      text: typeof message === \"string\" ? message : JSON.stringify(message)\n    });\n  }\n\n  return {\n    id: message.id || `msg-${index}`,\n    role:\n      message.role === \"data\"\n        ? \"system\"\n        : (message.role as \"user\" | \"assistant\" | \"system\") || \"user\",\n    parts: parts as UIMessage[\"parts\"]\n  };\n}\n\n/**\n * Legacy single message migration for backward compatibility\n */\nexport function migrateToUIMessage(message: MigratableMessage): UIMessage {\n  return autoTransformMessage(message as InputMessage);\n}\n\n/**\n * Automatic message transformer for arrays following the blog post pattern\n * @param messages - Array of messages in any format\n * @returns Array of UIMessages in v5 format\n */\nexport function autoTransformMessages(messages: unknown[]): UIMessage[] {\n  return messages.map((msg, i) => autoTransformMessage(msg as InputMessage, i));\n}\n\n/**\n * Migrates an array of messages to UIMessage format (legacy compatibility)\n * @param messages - Array of messages in old or new format\n * @returns Array of UIMessages in the new format\n */\nexport function migrateMessagesToUIFormat(\n  messages: MigratableMessage[]\n): UIMessage[] {\n  return autoTransformMessages(messages as InputMessage[]);\n}\n\n/**\n * Checks if any messages in an array need migration\n * @param messages - Array of messages to check\n * @returns true if any messages are not in proper UIMessage format\n */\nexport function needsMigration(messages: unknown[]): boolean {\n  return messages.some((message) => {\n    // If it's already a UIMessage, no migration needed\n    if (isUIMessage(message)) {\n      return false;\n    }\n\n    // Check for corrupt array format specifically\n    if (isCorruptArrayMessage(message)) {\n      return true;\n    }\n\n    // Check for legacy string format\n    if (isLegacyMessage(message)) {\n      return true;\n    }\n\n    // Any other format needs migration\n    return true;\n  });\n}\n\n/**\n * Analyzes the corruption types in a message array for debugging\n * @param messages - Array of messages to analyze\n * @returns Statistics about corruption types found\n */\nexport function analyzeCorruption(messages: unknown[]): {\n  total: number;\n  clean: number;\n  legacyString: number;\n  corruptArray: number;\n  unknown: number;\n  examples: {\n    legacyString?: unknown;\n    corruptArray?: unknown;\n    unknown?: unknown;\n  };\n} {\n  const stats = {\n    total: messages.length,\n    clean: 0,\n    legacyString: 0,\n    corruptArray: 0,\n    unknown: 0,\n    examples: {} as {\n      legacyString?: unknown;\n      corruptArray?: unknown;\n      unknown?: unknown;\n    }\n  };\n\n  for (const message of messages) {\n    if (isUIMessage(message)) {\n      stats.clean++;\n    } else if (isCorruptArrayMessage(message)) {\n      stats.corruptArray++;\n      if (!stats.examples.corruptArray) {\n        stats.examples.corruptArray = message;\n      }\n    } else if (isLegacyMessage(message)) {\n      stats.legacyString++;\n      if (!stats.examples.legacyString) {\n        stats.examples.legacyString = message;\n      }\n    } else {\n      stats.unknown++;\n      if (!stats.examples.unknown) {\n        stats.examples.unknown = message;\n      }\n    }\n  }\n\n  return stats;\n}\n", "import type {\n  UIMessage as ChatMessage,\n  DynamicToolUIPart,\n  ProviderMetadata,\n  ReasoningUIPart,\n  StreamTextOnFinishCallback,\n  TextUIPart,\n  ToolSet,\n  ToolUIPart,\n  UIMessageChunk\n} from \"ai\";\nimport {\n  Agent,\n  type AgentContext,\n  type Connection,\n  type ConnectionContext,\n  type WSMessage\n} from \"./\";\nimport {\n  MessageType,\n  type IncomingMessage,\n  type OutgoingMessage\n} from \"./ai-types\";\nimport { autoTransformMessages } from \"./ai-chat-v5-migration\";\nimport { nanoid } from \"nanoid\";\n\n/** Number of chunks to buffer before flushing to SQLite */\nconst CHUNK_BUFFER_SIZE = 10;\n/** Maximum buffer size to prevent memory issues on rapid reconnections */\nconst CHUNK_BUFFER_MAX_SIZE = 100;\n/** Maximum age for a \"streaming\" stream before considering it stale (ms) - 5 minutes */\nconst STREAM_STALE_THRESHOLD_MS = 5 * 60 * 1000;\n/** Default cleanup interval for old streams (ms) - every 10 minutes */\nconst CLEANUP_INTERVAL_MS = 10 * 60 * 1000;\n/** Default age threshold for cleaning up completed streams (ms) - 24 hours */\nconst CLEANUP_AGE_THRESHOLD_MS = 24 * 60 * 60 * 1000;\n\nconst decoder = new TextDecoder();\n\n/**\n * Stored stream chunk for resumable streaming\n */\ntype StreamChunk = {\n  id: string;\n  stream_id: string;\n  body: string;\n  chunk_index: number;\n  created_at: number;\n};\n\n/**\n * Stream metadata for tracking active streams\n */\ntype StreamMetadata = {\n  id: string;\n  request_id: string;\n  status: \"streaming\" | \"completed\" | \"error\";\n  created_at: number;\n  completed_at: number | null;\n};\n\n/**\n * Extension of Agent with built-in chat capabilities\n * @template Env Environment type containing bindings\n */\nexport class AIChatAgent<Env = unknown, State = unknown> extends Agent<\n  Env,\n  State\n> {\n  /**\n   * Map of message `id`s to `AbortController`s\n   * useful to propagate request cancellation signals for any external calls made by the agent\n   */\n  private _chatMessageAbortControllers: Map<string, AbortController>;\n\n  /**\n   * Currently active stream ID for resumable streaming.\n   * Stored in memory for quick access; persisted in stream_metadata table.\n   */\n  private _activeStreamId: string | null = null;\n\n  /**\n   * Request ID associated with the active stream.\n   */\n  private _activeRequestId: string | null = null;\n\n  /**\n   * Current chunk index for the active stream\n   */\n  private _streamChunkIndex = 0;\n\n  /**\n   * Buffer for stream chunks pending write to SQLite.\n   * Chunks are batched and flushed when buffer reaches CHUNK_BUFFER_SIZE.\n   */\n  private _chunkBuffer: Array<{\n    id: string;\n    streamId: string;\n    body: string;\n    index: number;\n  }> = [];\n\n  /**\n   * Lock to prevent concurrent flush operations\n   */\n  private _isFlushingChunks = false;\n\n  /**\n   * Timestamp of the last cleanup operation for old streams\n   */\n  private _lastCleanupTime = 0;\n\n  /** Array of chat messages for the current conversation */\n  messages: ChatMessage[];\n\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n    this.sql`create table if not exists cf_ai_chat_agent_messages (\n      id text primary key,\n      message text not null,\n      created_at datetime default current_timestamp\n    )`;\n\n    // Create tables for automatic resumable streaming\n    this.sql`create table if not exists cf_ai_chat_stream_chunks (\n      id text primary key,\n      stream_id text not null,\n      body text not null,\n      chunk_index integer not null,\n      created_at integer not null\n    )`;\n\n    this.sql`create table if not exists cf_ai_chat_stream_metadata (\n      id text primary key,\n      request_id text not null,\n      status text not null,\n      created_at integer not null,\n      completed_at integer\n    )`;\n\n    this.sql`create index if not exists idx_stream_chunks_stream_id \n      on cf_ai_chat_stream_chunks(stream_id, chunk_index)`;\n\n    // Load messages and automatically transform them to v5 format\n    const rawMessages = this._loadMessagesFromDb();\n\n    // Automatic migration following https://jhak.im/blog/ai-sdk-migration-handling-previously-saved-messages\n    this.messages = autoTransformMessages(rawMessages);\n\n    this._chatMessageAbortControllers = new Map();\n\n    // Check for any active streams from a previous session\n    this._restoreActiveStream();\n    const _onConnect = this.onConnect.bind(this);\n    this.onConnect = async (connection: Connection, ctx: ConnectionContext) => {\n      // Notify client about active streams that can be resumed\n      if (this._activeStreamId) {\n        this._notifyStreamResuming(connection);\n      }\n      // Call consumer's onConnect\n      return _onConnect(connection, ctx);\n    };\n\n    // Wrap onMessage\n    const _onMessage = this.onMessage.bind(this);\n    this.onMessage = async (connection: Connection, message: WSMessage) => {\n      // Handle AIChatAgent's internal messages first\n      if (typeof message === \"string\") {\n        let data: IncomingMessage;\n        try {\n          data = JSON.parse(message) as IncomingMessage;\n        } catch (_error) {\n          // Not JSON, forward to consumer\n          return _onMessage(connection, message);\n        }\n\n        // Handle chat request\n        if (\n          data.type === MessageType.CF_AGENT_USE_CHAT_REQUEST &&\n          data.init.method === \"POST\"\n        ) {\n          const { body } = data.init;\n          const { messages } = JSON.parse(body as string);\n\n          // Automatically transform any incoming messages\n          const transformedMessages = autoTransformMessages(messages);\n\n          this._broadcastChatMessage(\n            {\n              messages: transformedMessages,\n              type: MessageType.CF_AGENT_CHAT_MESSAGES\n            },\n            [connection.id]\n          );\n\n          await this.persistMessages(transformedMessages, [connection.id]);\n\n          this.observability?.emit(\n            {\n              displayMessage: \"Chat message request\",\n              id: data.id,\n              payload: {},\n              timestamp: Date.now(),\n              type: \"message:request\"\n            },\n            this.ctx\n          );\n\n          const chatMessageId = data.id;\n          const abortSignal = this._getAbortSignal(chatMessageId);\n\n          return this._tryCatchChat(async () => {\n            const response = await this.onChatMessage(\n              async (_finishResult) => {\n                this._removeAbortController(chatMessageId);\n\n                this.observability?.emit(\n                  {\n                    displayMessage: \"Chat message response\",\n                    id: data.id,\n                    payload: {},\n                    timestamp: Date.now(),\n                    type: \"message:response\"\n                  },\n                  this.ctx\n                );\n              },\n              abortSignal ? { abortSignal } : undefined\n            );\n\n            if (response) {\n              await this._reply(data.id, response);\n            } else {\n              console.warn(\n                `[AIChatAgent] onChatMessage returned no response for chatMessageId: ${chatMessageId}`\n              );\n              this._broadcastChatMessage(\n                {\n                  body: \"No response was generated by the agent.\",\n                  done: true,\n                  id: data.id,\n                  type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n                },\n                [connection.id]\n              );\n            }\n          });\n        }\n\n        // Handle clear chat\n        if (data.type === MessageType.CF_AGENT_CHAT_CLEAR) {\n          this._destroyAbortControllers();\n          this.sql`delete from cf_ai_chat_agent_messages`;\n          this.sql`delete from cf_ai_chat_stream_chunks`;\n          this.sql`delete from cf_ai_chat_stream_metadata`;\n          this._activeStreamId = null;\n          this._activeRequestId = null;\n          this._streamChunkIndex = 0;\n          this.messages = [];\n          this._broadcastChatMessage(\n            { type: MessageType.CF_AGENT_CHAT_CLEAR },\n            [connection.id]\n          );\n          return;\n        }\n\n        // Handle message replacement\n        if (data.type === MessageType.CF_AGENT_CHAT_MESSAGES) {\n          const transformedMessages = autoTransformMessages(data.messages);\n          await this.persistMessages(transformedMessages, [connection.id]);\n          return;\n        }\n\n        // Handle request cancellation\n        if (data.type === MessageType.CF_AGENT_CHAT_REQUEST_CANCEL) {\n          this._cancelChatRequest(data.id);\n          return;\n        }\n\n        // Handle stream resume acknowledgment\n        if (data.type === MessageType.CF_AGENT_STREAM_RESUME_ACK) {\n          if (\n            this._activeStreamId &&\n            this._activeRequestId &&\n            this._activeRequestId === data.id\n          ) {\n            this._sendStreamChunks(\n              connection,\n              this._activeStreamId,\n              this._activeRequestId\n            );\n          }\n          return;\n        }\n      }\n\n      // Forward unhandled messages to consumer's onMessage\n      return _onMessage(connection, message);\n    };\n  }\n\n  /**\n   * Restore active stream state if the agent was restarted during streaming.\n   * Called during construction to recover any interrupted streams.\n   * Validates stream freshness to avoid sending stale resume notifications.\n   */\n  private _restoreActiveStream() {\n    const activeStreams = this.sql<StreamMetadata>`\n      select * from cf_ai_chat_stream_metadata \n      where status = 'streaming' \n      order by created_at desc \n      limit 1\n    `;\n\n    if (activeStreams && activeStreams.length > 0) {\n      const stream = activeStreams[0];\n      const streamAge = Date.now() - stream.created_at;\n\n      // Check if stream is stale; delete to free storage\n      if (streamAge > STREAM_STALE_THRESHOLD_MS) {\n        this\n          .sql`delete from cf_ai_chat_stream_chunks where stream_id = ${stream.id}`;\n        this\n          .sql`delete from cf_ai_chat_stream_metadata where id = ${stream.id}`;\n        console.warn(\n          `[AIChatAgent] Deleted stale stream ${stream.id} (age: ${Math.round(streamAge / 1000)}s)`\n        );\n        return;\n      }\n\n      this._activeStreamId = stream.id;\n      this._activeRequestId = stream.request_id;\n\n      // Get the last chunk index\n      const lastChunk = this.sql<{ max_index: number }>`\n        select max(chunk_index) as max_index \n        from cf_ai_chat_stream_chunks \n        where stream_id = ${this._activeStreamId}\n      `;\n      this._streamChunkIndex =\n        lastChunk && lastChunk[0]?.max_index != null\n          ? lastChunk[0].max_index + 1\n          : 0;\n    }\n  }\n\n  /**\n   * Notify a connection about an active stream that can be resumed.\n   * The client should respond with CF_AGENT_STREAM_RESUME_ACK to receive chunks.\n   * Uses in-memory state for request ID - no extra DB lookup needed.\n   * @param connection - The WebSocket connection to notify\n   */\n  private _notifyStreamResuming(connection: Connection) {\n    if (!this._activeStreamId || !this._activeRequestId) {\n      return;\n    }\n\n    // Notify client - they will send ACK when ready\n    connection.send(\n      JSON.stringify({\n        type: MessageType.CF_AGENT_STREAM_RESUMING,\n        id: this._activeRequestId\n      })\n    );\n  }\n\n  /**\n   * Send stream chunks to a connection after receiving ACK.\n   * @param connection - The WebSocket connection\n   * @param streamId - The stream to replay\n   * @param requestId - The original request ID\n   */\n  private _sendStreamChunks(\n    connection: Connection,\n    streamId: string,\n    requestId: string\n  ) {\n    // Flush any pending chunks first to ensure we have the latest\n    this._flushChunkBuffer();\n\n    const chunks = this.sql<StreamChunk>`\n      select * from cf_ai_chat_stream_chunks \n      where stream_id = ${streamId} \n      order by chunk_index asc\n    `;\n\n    // Send all stored chunks\n    for (const chunk of chunks || []) {\n      connection.send(\n        JSON.stringify({\n          body: chunk.body,\n          done: false,\n          id: requestId,\n          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n        })\n      );\n    }\n\n    // If the stream is no longer active (completed), send done signal\n    // We track active state in memory, no need to query DB\n    if (this._activeStreamId !== streamId) {\n      connection.send(\n        JSON.stringify({\n          body: \"\",\n          done: true,\n          id: requestId,\n          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n        })\n      );\n    }\n  }\n\n  /**\n   * Buffer a stream chunk for batch write to SQLite.\n   * @param streamId - The stream this chunk belongs to\n   * @param body - The serialized chunk body\n   */\n  private _storeStreamChunk(streamId: string, body: string) {\n    // Force flush if buffer is at max to prevent memory issues\n    if (this._chunkBuffer.length >= CHUNK_BUFFER_MAX_SIZE) {\n      this._flushChunkBuffer();\n    }\n\n    this._chunkBuffer.push({\n      id: nanoid(),\n      streamId,\n      body,\n      index: this._streamChunkIndex\n    });\n    this._streamChunkIndex++;\n\n    // Flush when buffer reaches threshold\n    if (this._chunkBuffer.length >= CHUNK_BUFFER_SIZE) {\n      this._flushChunkBuffer();\n    }\n  }\n\n  /**\n   * Flush buffered chunks to SQLite in a single batch.\n   * Uses a lock to prevent concurrent flush operations.\n   */\n  private _flushChunkBuffer() {\n    // Prevent concurrent flushes\n    if (this._isFlushingChunks || this._chunkBuffer.length === 0) {\n      return;\n    }\n\n    this._isFlushingChunks = true;\n    try {\n      const chunks = this._chunkBuffer;\n      this._chunkBuffer = [];\n\n      // Batch insert all chunks\n      const now = Date.now();\n      for (const chunk of chunks) {\n        this.sql`\n          insert into cf_ai_chat_stream_chunks (id, stream_id, body, chunk_index, created_at)\n          values (${chunk.id}, ${chunk.streamId}, ${chunk.body}, ${chunk.index}, ${now})\n        `;\n      }\n    } finally {\n      this._isFlushingChunks = false;\n    }\n  }\n\n  /**\n   * Start tracking a new stream for resumable streaming.\n   * Creates metadata entry in SQLite and sets up tracking state.\n   * @param requestId - The unique ID of the chat request\n   * @returns The generated stream ID\n   */\n  private _startStream(requestId: string): string {\n    // Flush any pending chunks from previous streams to prevent mixing\n    this._flushChunkBuffer();\n\n    const streamId = nanoid();\n    this._activeStreamId = streamId;\n    this._activeRequestId = requestId;\n    this._streamChunkIndex = 0;\n\n    this.sql`\n      insert into cf_ai_chat_stream_metadata (id, request_id, status, created_at)\n      values (${streamId}, ${requestId}, 'streaming', ${Date.now()})\n    `;\n\n    return streamId;\n  }\n\n  /**\n   * Mark a stream as completed and flush any pending chunks.\n   * @param streamId - The stream to mark as completed\n   */\n  private _completeStream(streamId: string) {\n    // Flush any pending chunks before completing\n    this._flushChunkBuffer();\n\n    this.sql`\n      update cf_ai_chat_stream_metadata \n      set status = 'completed', completed_at = ${Date.now()} \n      where id = ${streamId}\n    `;\n    this._activeStreamId = null;\n    this._activeRequestId = null;\n    this._streamChunkIndex = 0;\n\n    // Periodically clean up old streams (not on every completion)\n    this._maybeCleanupOldStreams();\n  }\n\n  /**\n   * Clean up old completed streams if enough time has passed since last cleanup.\n   * This prevents database growth while avoiding cleanup overhead on every stream completion.\n   */\n  private _maybeCleanupOldStreams() {\n    const now = Date.now();\n    if (now - this._lastCleanupTime < CLEANUP_INTERVAL_MS) {\n      return;\n    }\n    this._lastCleanupTime = now;\n\n    const cutoff = now - CLEANUP_AGE_THRESHOLD_MS;\n    this.sql`\n      delete from cf_ai_chat_stream_chunks \n      where stream_id in (\n        select id from cf_ai_chat_stream_metadata \n        where status = 'completed' and completed_at < ${cutoff}\n      )\n    `;\n    this.sql`\n      delete from cf_ai_chat_stream_metadata \n      where status = 'completed' and completed_at < ${cutoff}\n    `;\n  }\n\n  private _broadcastChatMessage(message: OutgoingMessage, exclude?: string[]) {\n    this.broadcast(JSON.stringify(message), exclude);\n  }\n\n  private _loadMessagesFromDb(): ChatMessage[] {\n    const rows =\n      this.sql`select * from cf_ai_chat_agent_messages order by created_at` ||\n      [];\n    return rows\n      .map((row) => {\n        try {\n          return JSON.parse(row.message as string);\n        } catch (error) {\n          console.error(`Failed to parse message ${row.id}:`, error);\n          return null;\n        }\n      })\n      .filter((msg): msg is ChatMessage => msg !== null);\n  }\n\n  override async onRequest(request: Request): Promise<Response> {\n    return this._tryCatchChat(async () => {\n      const url = new URL(request.url);\n\n      if (url.pathname.endsWith(\"/get-messages\")) {\n        const messages = this._loadMessagesFromDb();\n        return Response.json(messages);\n      }\n\n      return super.onRequest(request);\n    });\n  }\n\n  private async _tryCatchChat<T>(fn: () => T | Promise<T>) {\n    try {\n      return await fn();\n    } catch (e) {\n      throw this.onError(e);\n    }\n  }\n\n  /**\n   * Handle incoming chat messages and generate a response\n   * @param onFinish Callback to be called when the response is finished\n   * @param options.signal A signal to pass to any child requests which can be used to cancel them\n   * @returns Response to send to the client or undefined\n   */\n  async onChatMessage(\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later\n    onFinish: StreamTextOnFinishCallback<ToolSet>,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later\n    options?: { abortSignal: AbortSignal | undefined }\n  ): Promise<Response | undefined> {\n    throw new Error(\n      \"recieved a chat message, override onChatMessage and return a Response to send to the client\"\n    );\n  }\n\n  /**\n   * Save messages on the server side\n   * @param messages Chat messages to save\n   */\n  async saveMessages(messages: ChatMessage[]) {\n    await this.persistMessages(messages);\n    await this._tryCatchChat(async () => {\n      const response = await this.onChatMessage(() => {});\n      if (response) this._reply(crypto.randomUUID(), response);\n    });\n  }\n\n  async persistMessages(\n    messages: ChatMessage[],\n    excludeBroadcastIds: string[] = []\n  ) {\n    for (const message of messages) {\n      this.sql`\n        insert into cf_ai_chat_agent_messages (id, message)\n        values (${message.id}, ${JSON.stringify(message)})\n        on conflict(id) do update set message = excluded.message\n      `;\n    }\n\n    // refresh in-memory messages\n    const persisted = this._loadMessagesFromDb();\n    this.messages = autoTransformMessages(persisted);\n    this._broadcastChatMessage(\n      {\n        messages: messages,\n        type: MessageType.CF_AGENT_CHAT_MESSAGES\n      },\n      excludeBroadcastIds\n    );\n  }\n\n  private async _reply(id: string, response: Response) {\n    return this._tryCatchChat(async () => {\n      if (!response.body) {\n        // Send empty response if no body\n        this._broadcastChatMessage({\n          body: \"\",\n          done: true,\n          id,\n          type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n        });\n        return;\n      }\n\n      // Start tracking this stream for resumability\n      const streamId = this._startStream(id);\n\n      /* Lazy loading ai sdk, because putting it in module scope is\n       * causing issues with startup time.\n       * The only place it's used is in _reply, which only matters after\n       * a chat message is received.\n       * So it's safe to delay loading it until a chat message is received.\n       */\n      const { getToolName, isToolUIPart, parsePartialJson } = await import(\n        \"ai\"\n      );\n\n      const reader = response.body.getReader();\n\n      // Parsing state adapted from:\n      // https://github.com/vercel/ai/blob/main/packages/ai/src/ui-message-stream/ui-message-chunks.ts#L295\n      const message: ChatMessage = {\n        id: `assistant_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`, // default\n        role: \"assistant\",\n        parts: []\n      };\n      let activeTextParts: Record<string, TextUIPart> = {};\n      let activeReasoningParts: Record<string, ReasoningUIPart> = {};\n      const partialToolCalls: Record<\n        string,\n        { text: string; index: number; toolName: string; dynamic?: boolean }\n      > = {};\n\n      function updateDynamicToolPart(\n        options: {\n          toolName: string;\n          toolCallId: string;\n          providerExecuted?: boolean;\n        } & (\n          | {\n              state: \"input-streaming\";\n              input: unknown;\n            }\n          | {\n              state: \"input-available\";\n              input: unknown;\n              providerMetadata?: ProviderMetadata;\n            }\n          | {\n              state: \"output-available\";\n              input: unknown;\n              output: unknown;\n              preliminary: boolean | undefined;\n            }\n          | {\n              state: \"output-error\";\n              input: unknown;\n              errorText: string;\n              providerMetadata?: ProviderMetadata;\n            }\n        )\n      ) {\n        const part = message.parts.find(\n          (part) =>\n            part.type === \"dynamic-tool\" &&\n            part.toolCallId === options.toolCallId\n        ) as DynamicToolUIPart | undefined;\n\n        const anyOptions = options as Record<string, unknown>;\n        const anyPart = part as Record<string, unknown>;\n\n        if (part != null) {\n          part.state = options.state;\n          anyPart.toolName = options.toolName;\n          anyPart.input = anyOptions.input;\n          anyPart.output = anyOptions.output;\n          anyPart.errorText = anyOptions.errorText;\n          anyPart.rawInput = anyOptions.rawInput ?? anyPart.rawInput;\n          anyPart.preliminary = anyOptions.preliminary;\n\n          if (\n            anyOptions.providerMetadata != null &&\n            part.state === \"input-available\"\n          ) {\n            part.callProviderMetadata =\n              anyOptions.providerMetadata as ProviderMetadata;\n          }\n        } else {\n          message.parts.push({\n            type: \"dynamic-tool\",\n            toolName: options.toolName,\n            toolCallId: options.toolCallId,\n            state: options.state,\n            input: anyOptions.input,\n            output: anyOptions.output,\n            errorText: anyOptions.errorText,\n            preliminary: anyOptions.preliminary,\n            ...(anyOptions.providerMetadata != null\n              ? { callProviderMetadata: anyOptions.providerMetadata }\n              : {})\n          } as DynamicToolUIPart);\n        }\n      }\n\n      function updateToolPart(\n        options: {\n          toolName: string;\n          toolCallId: string;\n          providerExecuted?: boolean;\n        } & (\n          | {\n              state: \"input-streaming\";\n              input: unknown;\n              providerExecuted?: boolean;\n            }\n          | {\n              state: \"input-available\";\n              input: unknown;\n              providerExecuted?: boolean;\n              providerMetadata?: ProviderMetadata;\n            }\n          | {\n              state: \"output-available\";\n              input: unknown;\n              output: unknown;\n              providerExecuted?: boolean;\n              preliminary?: boolean;\n            }\n          | {\n              state: \"output-error\";\n              input: unknown;\n              rawInput?: unknown;\n              errorText: string;\n              providerExecuted?: boolean;\n              providerMetadata?: ProviderMetadata;\n            }\n        )\n      ) {\n        const part = message.parts.find(\n          (part) =>\n            isToolUIPart(part) &&\n            (part as ToolUIPart).toolCallId === options.toolCallId\n        ) as ToolUIPart | undefined;\n\n        const anyOptions = options as Record<string, unknown>;\n        const anyPart = part as Record<string, unknown>;\n\n        if (part != null) {\n          part.state = options.state;\n          anyPart.input = anyOptions.input;\n          anyPart.output = anyOptions.output;\n          anyPart.errorText = anyOptions.errorText;\n          anyPart.rawInput = anyOptions.rawInput;\n          anyPart.preliminary = anyOptions.preliminary;\n\n          // once providerExecuted is set, it stays for streaming\n          anyPart.providerExecuted =\n            anyOptions.providerExecuted ?? part.providerExecuted;\n\n          if (\n            anyOptions.providerMetadata != null &&\n            part.state === \"input-available\"\n          ) {\n            part.callProviderMetadata =\n              anyOptions.providerMetadata as ProviderMetadata;\n          }\n        } else {\n          message.parts.push({\n            type: `tool-${options.toolName}`,\n            toolCallId: options.toolCallId,\n            state: options.state,\n            input: anyOptions.input,\n            output: anyOptions.output,\n            rawInput: anyOptions.rawInput,\n            errorText: anyOptions.errorText,\n            providerExecuted: anyOptions.providerExecuted,\n            preliminary: anyOptions.preliminary,\n            ...(anyOptions.providerMetadata != null\n              ? { callProviderMetadata: anyOptions.providerMetadata }\n              : {})\n          } as ToolUIPart);\n        }\n      }\n\n      async function updateMessageMetadata(metadata: unknown) {\n        if (metadata != null) {\n          const mergedMetadata =\n            message.metadata != null\n              ? { ...message.metadata, ...metadata } // TODO: do proper merging\n              : metadata;\n\n          message.metadata = mergedMetadata;\n        }\n      }\n\n      let streamCompleted = false;\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            // Mark the stream as completed\n            this._completeStream(streamId);\n            streamCompleted = true;\n            // Send final completion signal\n            this._broadcastChatMessage({\n              body: \"\",\n              done: true,\n              id,\n              type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n            });\n            break;\n          }\n\n          const chunk = decoder.decode(value);\n\n          // Determine response format based on content-type\n          const contentType = response.headers.get(\"content-type\") || \"\";\n          const isSSE = contentType.includes(\"text/event-stream\");\n\n          // After streaming is complete, persist the complete assistant's response\n          if (isSSE) {\n            // Parse AI SDK v5 SSE format and extract text deltas\n            const lines = chunk.split(\"\\n\");\n            for (const line of lines) {\n              if (line.startsWith(\"data: \") && line !== \"data: [DONE]\") {\n                try {\n                  const data: UIMessageChunk = JSON.parse(line.slice(6)); // Remove 'data: ' prefix\n                  switch (data.type) {\n                    case \"text-start\": {\n                      const textPart: TextUIPart = {\n                        type: \"text\",\n                        text: \"\",\n                        providerMetadata: data.providerMetadata,\n                        state: \"streaming\"\n                      };\n                      activeTextParts[data.id] = textPart;\n                      message.parts.push(textPart);\n                      break;\n                    }\n\n                    case \"text-delta\": {\n                      const textPart = activeTextParts[data.id];\n                      textPart.text += data.delta;\n                      textPart.providerMetadata =\n                        data.providerMetadata ?? textPart.providerMetadata;\n                      break;\n                    }\n\n                    case \"text-end\": {\n                      const textPart = activeTextParts[data.id];\n                      textPart.state = \"done\";\n                      textPart.providerMetadata =\n                        data.providerMetadata ?? textPart.providerMetadata;\n                      delete activeTextParts[data.id];\n                      break;\n                    }\n\n                    case \"reasoning-start\": {\n                      const reasoningPart: ReasoningUIPart = {\n                        type: \"reasoning\",\n                        text: \"\",\n                        providerMetadata: data.providerMetadata,\n                        state: \"streaming\"\n                      };\n                      activeReasoningParts[data.id] = reasoningPart;\n                      message.parts.push(reasoningPart);\n                      break;\n                    }\n\n                    case \"reasoning-delta\": {\n                      const reasoningPart = activeReasoningParts[data.id];\n                      reasoningPart.text += data.delta;\n                      reasoningPart.providerMetadata =\n                        data.providerMetadata ?? reasoningPart.providerMetadata;\n                      break;\n                    }\n\n                    case \"reasoning-end\": {\n                      const reasoningPart = activeReasoningParts[data.id];\n                      reasoningPart.providerMetadata =\n                        data.providerMetadata ?? reasoningPart.providerMetadata;\n                      reasoningPart.state = \"done\";\n                      delete activeReasoningParts[data.id];\n\n                      break;\n                    }\n\n                    case \"file\": {\n                      message.parts.push({\n                        type: \"file\",\n                        mediaType: data.mediaType,\n                        url: data.url\n                      });\n\n                      break;\n                    }\n\n                    case \"source-url\": {\n                      message.parts.push({\n                        type: \"source-url\",\n                        sourceId: data.sourceId,\n                        url: data.url,\n                        title: data.title,\n                        providerMetadata: data.providerMetadata\n                      });\n\n                      break;\n                    }\n\n                    case \"source-document\": {\n                      message.parts.push({\n                        type: \"source-document\",\n                        sourceId: data.sourceId,\n                        mediaType: data.mediaType,\n                        title: data.title,\n                        filename: data.filename,\n                        providerMetadata: data.providerMetadata\n                      });\n\n                      break;\n                    }\n\n                    case \"tool-input-start\": {\n                      const toolInvocations =\n                        message.parts.filter(isToolUIPart);\n\n                      // add the partial tool call to the map\n                      partialToolCalls[data.toolCallId] = {\n                        text: \"\",\n                        toolName: data.toolName,\n                        index: toolInvocations.length,\n                        dynamic: data.dynamic\n                      };\n\n                      if (data.dynamic) {\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"input-streaming\",\n                          input: undefined\n                        });\n                      } else {\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"input-streaming\",\n                          input: undefined\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"tool-input-delta\": {\n                      const partialToolCall = partialToolCalls[data.toolCallId];\n\n                      partialToolCall.text += data.inputTextDelta;\n\n                      const partialArgsResult = await parsePartialJson(\n                        partialToolCall.text\n                      );\n                      const partialArgs = (\n                        partialArgsResult as { value: Record<string, unknown> }\n                      ).value;\n\n                      if (partialToolCall.dynamic) {\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: partialToolCall.toolName,\n                          state: \"input-streaming\",\n                          input: partialArgs\n                        });\n                      } else {\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: partialToolCall.toolName,\n                          state: \"input-streaming\",\n                          input: partialArgs\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"tool-input-available\": {\n                      if (data.dynamic) {\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"input-available\",\n                          input: data.input,\n                          providerMetadata: data.providerMetadata\n                        });\n                      } else {\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"input-available\",\n                          input: data.input,\n                          providerExecuted: data.providerExecuted,\n                          providerMetadata: data.providerMetadata\n                        });\n                      }\n\n                      // TODO: Do we want to expose onToolCall?\n\n                      // invoke the onToolCall callback if it exists. This is blocking.\n                      // In the future we should make this non-blocking, which\n                      // requires additional state management for error handling etc.\n                      // Skip calling onToolCall for provider-executed tools since they are already executed\n                      // if (onToolCall && !data.providerExecuted) {\n                      //   await onToolCall({\n                      //     toolCall: data\n                      //   });\n                      // }\n                      break;\n                    }\n\n                    case \"tool-input-error\": {\n                      if (data.dynamic) {\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"output-error\",\n                          input: data.input,\n                          errorText: data.errorText,\n                          providerMetadata: data.providerMetadata\n                        });\n                      } else {\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: data.toolName,\n                          state: \"output-error\",\n                          input: undefined,\n                          rawInput: data.input,\n                          errorText: data.errorText,\n                          providerExecuted: data.providerExecuted,\n                          providerMetadata: data.providerMetadata\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"tool-output-available\": {\n                      if (data.dynamic) {\n                        const toolInvocations = message.parts.filter(\n                          (part) => part.type === \"dynamic-tool\"\n                        ) as DynamicToolUIPart[];\n\n                        const toolInvocation = toolInvocations.find(\n                          (invocation) =>\n                            invocation.toolCallId === data.toolCallId\n                        );\n\n                        if (!toolInvocation)\n                          throw new Error(\"Tool invocation not found\");\n\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: toolInvocation.toolName,\n                          state: \"output-available\",\n                          input: toolInvocation.input,\n                          output: data.output,\n                          preliminary: data.preliminary\n                        });\n                      } else {\n                        const toolInvocations = message.parts.filter(\n                          isToolUIPart\n                        ) as ToolUIPart[];\n\n                        const toolInvocation = toolInvocations.find(\n                          (invocation) =>\n                            invocation.toolCallId === data.toolCallId\n                        );\n\n                        if (!toolInvocation)\n                          throw new Error(\"Tool invocation not found\");\n\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: getToolName(toolInvocation),\n                          state: \"output-available\",\n                          input: toolInvocation.input,\n                          output: data.output,\n                          providerExecuted: data.providerExecuted,\n                          preliminary: data.preliminary\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"tool-output-error\": {\n                      if (data.dynamic) {\n                        const toolInvocations = message.parts.filter(\n                          (part) => part.type === \"dynamic-tool\"\n                        ) as DynamicToolUIPart[];\n\n                        const toolInvocation = toolInvocations.find(\n                          (invocation) =>\n                            invocation.toolCallId === data.toolCallId\n                        );\n\n                        if (!toolInvocation)\n                          throw new Error(\"Tool invocation not found\");\n\n                        updateDynamicToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: toolInvocation.toolName,\n                          state: \"output-error\",\n                          input: toolInvocation.input,\n                          errorText: data.errorText\n                        });\n                      } else {\n                        const toolInvocations = message.parts.filter(\n                          isToolUIPart\n                        ) as ToolUIPart[];\n\n                        const toolInvocation = toolInvocations.find(\n                          (invocation) =>\n                            invocation.toolCallId === data.toolCallId\n                        );\n\n                        if (!toolInvocation)\n                          throw new Error(\"Tool invocation not found\");\n                        updateToolPart({\n                          toolCallId: data.toolCallId,\n                          toolName: getToolName(toolInvocation),\n                          state: \"output-error\",\n                          input: toolInvocation.input,\n                          rawInput:\n                            \"rawInput\" in toolInvocation\n                              ? toolInvocation.rawInput\n                              : undefined,\n                          errorText: data.errorText\n                        });\n                      }\n\n                      break;\n                    }\n\n                    case \"start-step\": {\n                      // add a step boundary part to the message\n                      message.parts.push({ type: \"step-start\" });\n                      break;\n                    }\n\n                    case \"finish-step\": {\n                      // reset the current text and reasoning parts\n                      activeTextParts = {};\n                      activeReasoningParts = {};\n                      break;\n                    }\n\n                    case \"start\": {\n                      if (data.messageId != null) {\n                        message.id = data.messageId;\n                      }\n\n                      await updateMessageMetadata(data.messageMetadata);\n\n                      break;\n                    }\n\n                    case \"finish\": {\n                      await updateMessageMetadata(data.messageMetadata);\n                      break;\n                    }\n\n                    case \"message-metadata\": {\n                      await updateMessageMetadata(data.messageMetadata);\n                      break;\n                    }\n\n                    case \"error\": {\n                      this._broadcastChatMessage({\n                        error: true,\n                        body: data.errorText ?? JSON.stringify(data),\n                        done: false,\n                        id,\n                        type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n                      });\n\n                      break;\n                    }\n                    // Do we want to handle data parts?\n                  }\n\n                  // Convert internal AI SDK stream events to valid UIMessageStreamPart format.\n                  // The \"finish\" event with \"finishReason\" is an internal LanguageModelV3StreamPart,\n                  // not a UIMessageStreamPart (which expects \"messageMetadata\" instead).\n                  // See: https://github.com/cloudflare/agents/issues/677\n                  let eventToSend: unknown = data;\n                  if (data.type === \"finish\" && \"finishReason\" in data) {\n                    const { finishReason, ...rest } = data as {\n                      finishReason: string;\n                      [key: string]: unknown;\n                    };\n                    eventToSend = {\n                      ...rest,\n                      type: \"finish\",\n                      messageMetadata: { finishReason }\n                    };\n                  }\n\n                  // Store chunk for replay on reconnection\n                  const chunkBody = JSON.stringify(eventToSend);\n                  this._storeStreamChunk(streamId, chunkBody);\n\n                  // Forward the converted event to the client\n                  this._broadcastChatMessage({\n                    body: chunkBody,\n                    done: false,\n                    id,\n                    type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n                  });\n                } catch (_error) {\n                  // Skip malformed JSON lines silently\n                }\n              }\n            }\n          } else {\n            // Handle plain text responses (e.g., from generateText)\n            // Treat the entire chunk as a text delta to preserve exact formatting\n            if (chunk.length > 0) {\n              message.parts.push({ type: \"text\", text: chunk });\n              // Synthesize a text-delta event so clients can stream-render\n              const chunkBody = JSON.stringify({\n                type: \"text-delta\",\n                delta: chunk\n              });\n              // Store chunk for replay on reconnection\n              this._storeStreamChunk(streamId, chunkBody);\n              this._broadcastChatMessage({\n                body: chunkBody,\n                done: false,\n                id,\n                type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n              });\n            }\n          }\n        }\n      } catch (error) {\n        // Mark stream as error if not already completed\n        if (!streamCompleted) {\n          this._markStreamError(streamId);\n          // Notify clients of the error\n          this._broadcastChatMessage({\n            body: error instanceof Error ? error.message : \"Stream error\",\n            done: true,\n            error: true,\n            id,\n            type: MessageType.CF_AGENT_USE_CHAT_RESPONSE\n          });\n        }\n        throw error;\n      } finally {\n        reader.releaseLock();\n      }\n\n      if (message.parts.length > 0) {\n        await this.persistMessages([...this.messages, message]);\n      }\n    });\n  }\n\n  /**\n   * Mark a stream as errored and clean up state.\n   * @param streamId - The stream to mark as errored\n   */\n  private _markStreamError(streamId: string) {\n    // Flush any pending chunks before marking error\n    this._flushChunkBuffer();\n\n    this.sql`\n      update cf_ai_chat_stream_metadata \n      set status = 'error', completed_at = ${Date.now()} \n      where id = ${streamId}\n    `;\n    this._activeStreamId = null;\n    this._activeRequestId = null;\n    this._streamChunkIndex = 0;\n  }\n\n  /**\n   * For the given message id, look up its associated AbortController\n   * If the AbortController does not exist, create and store one in memory\n   *\n   * returns the AbortSignal associated with the AbortController\n   */\n  private _getAbortSignal(id: string): AbortSignal | undefined {\n    // Defensive check, since we're coercing message types at the moment\n    if (typeof id !== \"string\") {\n      return undefined;\n    }\n\n    if (!this._chatMessageAbortControllers.has(id)) {\n      this._chatMessageAbortControllers.set(id, new AbortController());\n    }\n\n    return this._chatMessageAbortControllers.get(id)?.signal;\n  }\n\n  /**\n   * Remove an abort controller from the cache of pending message responses\n   */\n  private _removeAbortController(id: string) {\n    this._chatMessageAbortControllers.delete(id);\n  }\n\n  /**\n   * Propagate an abort signal for any requests associated with the given message id\n   */\n  private _cancelChatRequest(id: string) {\n    if (this._chatMessageAbortControllers.has(id)) {\n      const abortController = this._chatMessageAbortControllers.get(id);\n      abortController?.abort();\n    }\n  }\n\n  /**\n   * Abort all pending requests and clear the cache of AbortControllers\n   */\n  private _destroyAbortControllers() {\n    for (const controller of this._chatMessageAbortControllers.values()) {\n      controller?.abort();\n    }\n    this._chatMessageAbortControllers.clear();\n  }\n\n  /**\n   * When the DO is destroyed, cancel all pending requests and clean up resources\n   */\n  async destroy() {\n    this._destroyAbortControllers();\n\n    // Flush any remaining chunks before cleanup\n    this._flushChunkBuffer();\n\n    // Clean up stream tables\n    this.sql`drop table if exists cf_ai_chat_stream_chunks`;\n    this.sql`drop table if exists cf_ai_chat_stream_metadata`;\n\n    // Clear active stream state\n    this._activeStreamId = null;\n    this._activeRequestId = null;\n\n    await super.destroy();\n  }\n}\n"],
  "mappings": "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",
  "names": ["parts: TransformMessagePart[]", "ctx", "data: IncomingMessage", "message: ChatMessage", "activeTextParts: Record<string, TextUIPart>", "activeReasoningParts: Record<string, ReasoningUIPart>", "partialToolCalls: Record<\n        string,\n        { text: string; index: number; toolName: string; dynamic?: boolean }\n      >", "part", "data: UIMessageChunk", "textPart: TextUIPart", "reasoningPart: ReasoningUIPart", "eventToSend: unknown"]
}
